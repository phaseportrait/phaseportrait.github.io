{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What's this? The idea behind this project was to create a simple way to make phase portraits in 2D and 3D, as we couldn't find something similar on the internet, so we got down to work. Eventually, we did some work on bifurcations, 1D maps and chaos. This idea came while taking a course in non linear dynamics and chaos, during the 3rd year of physics degree, brought by our desire of visualizing things and programming. We want to state that we are self-taught into making this kind of stuff, and we've tried to make things as professionally as possible, any comments about improving our work are welcome! At first, this project was made up in spanish. The spanish version can be found here . Authors V\u00edctor Loras Herrero ( vhloras@gmail.com ) Unai Ler\u00eda Fortea ( unaileria@gmail.com ) Installation Installation via pip: $ pip install phaseportrait Installation via git: Open a terminal on desired route and type the following $ git clone https://github.com/Loracio/phase-portrait Manual installation Visit phase-portrait webpage on GitHub. Click on green button saying Code , and download it in zip format. Save and unzip on desired directory. Examples of use examples.ipynb : Examples showing how to use PhasePortrait2D class. sliderExamples.py : Examples using the slider feature from PhasePortrait2D class. TrajectoryExamples.py : Contains examples of 2D and 3D trajectories with and without sliders.","title":"Home"},{"location":"#whats-this","text":"The idea behind this project was to create a simple way to make phase portraits in 2D and 3D, as we couldn't find something similar on the internet, so we got down to work. Eventually, we did some work on bifurcations, 1D maps and chaos. This idea came while taking a course in non linear dynamics and chaos, during the 3rd year of physics degree, brought by our desire of visualizing things and programming. We want to state that we are self-taught into making this kind of stuff, and we've tried to make things as professionally as possible, any comments about improving our work are welcome! At first, this project was made up in spanish. The spanish version can be found here .","title":"What's this?"},{"location":"#authors","text":"V\u00edctor Loras Herrero ( vhloras@gmail.com ) Unai Ler\u00eda Fortea ( unaileria@gmail.com )","title":"Authors"},{"location":"#installation","text":"Installation via pip: $ pip install phaseportrait Installation via git: Open a terminal on desired route and type the following $ git clone https://github.com/Loracio/phase-portrait Manual installation Visit phase-portrait webpage on GitHub. Click on green button saying Code , and download it in zip format. Save and unzip on desired directory.","title":"Installation"},{"location":"#examples-of-use","text":"examples.ipynb : Examples showing how to use PhasePortrait2D class. sliderExamples.py : Examples using the slider feature from PhasePortrait2D class. TrajectoryExamples.py : Contains examples of 2D and 3D trajectories with and without sliders.","title":"Examples of use"},{"location":"cobweb/","text":"Cobweb class phaseportrait. Cobweb ( dF, initial_position, xrange, *, dF_args={None}, yrange=[], max_steps=100, n_points=100, **kargs ) A class used to represent a Cobweb plot and a time series to study the convergence of a 1D map x(t+1) = f(x) . Parameters dF : callable A dF type funcion. initial_position : float Initial x of the iteration. xrange : list Range of the x axis in the main plot. Key Arguments dF_args : dict If necesary, must contain the kargs for the dF funcion. yrange : list Range of the y axis in the main plot max_steps : int, default=100 Maximun number of points to be represented. n_points : int, default=10000 Number of points in the bisector. Title : str, default='Cobweb plot' Title of the plot. xlabel : str, default=r'$X_{n}$' x label of the plot. ylabel : str, default=r'$X_{n+1}$' y label of the plot. Methods Cobweb .plot Cobweb . plot (*args, **kargs) Creates two figures, one containing the Cobweb plot and other with the time series. Returns tuple(matplotlib Figure (Cobweb plot), matplotlib Axis (Cobweb plot), matplotlib Figure (Time series), matplotlib Axis (Time series)) Cobweb .add_slider Cobweb . add_slider (param_name, *, valinit=None, valstep=0.1, valinterval=10) Adds a slider which can change the value of a parameter in execution time. Parameters param_name : str The string key of the variable. Must be the same as the key in the dF function. Key Arguments valinit : float, default=None Initial value of the parameter. valinterval : Union[float, list], default=0.1 The range of values the slider of the parameter will cover. valstep : float, default=10 Precision in the slider. Returns None Cobweb .initial_position_slider Cobweb . initial_position_slider (*, valinit=None, valstep=0.05, valinterval=None) Adds a slider for changing initial value on a cobweb plot. Key Arguments valinit : numeric Initial position. Default value is the same as initial position given when initializing Cobweb object. valinterval : Union[float, list] The range of values the slider of the parameter will cover. valstep : float Precision in the slider. Returns None Examples Logistic map cobweb plot and time series, defining the logistic map as a 1D dF function . from phaseportrait import Cobweb def Logistic(x, *, r=1.5): return r*x*(1-x) # Cobweb plot and time series. LogisticCobweb = Cobweb(Logistic, 0.2, [0,1], dF_args={'r':1.5}, yrange=[0,1]) LogisticCobweb.add_slider('r', valinit=1.5, valinterval=[0,4]) LogisticCobweb.initial_position_slider(valstep=0.01) LogisticCobweb.plot() This will output the following plots:","title":"Cobweb plots"},{"location":"cobweb/#cobweb","text":"class phaseportrait. Cobweb ( dF, initial_position, xrange, *, dF_args={None}, yrange=[], max_steps=100, n_points=100, **kargs ) A class used to represent a Cobweb plot and a time series to study the convergence of a 1D map x(t+1) = f(x) .","title":"Cobweb"},{"location":"cobweb/#parameters","text":"dF : callable A dF type funcion. initial_position : float Initial x of the iteration. xrange : list Range of the x axis in the main plot.","title":"Parameters"},{"location":"cobweb/#key-arguments","text":"dF_args : dict If necesary, must contain the kargs for the dF funcion. yrange : list Range of the y axis in the main plot max_steps : int, default=100 Maximun number of points to be represented. n_points : int, default=10000 Number of points in the bisector. Title : str, default='Cobweb plot' Title of the plot. xlabel : str, default=r'$X_{n}$' x label of the plot. ylabel : str, default=r'$X_{n+1}$' y label of the plot.","title":"Key Arguments"},{"location":"cobweb/#methods","text":"","title":"Methods"},{"location":"cobweb/#cobwebplot","text":"Cobweb . plot (*args, **kargs) Creates two figures, one containing the Cobweb plot and other with the time series. Returns tuple(matplotlib Figure (Cobweb plot), matplotlib Axis (Cobweb plot), matplotlib Figure (Time series), matplotlib Axis (Time series))","title":"Cobweb.plot"},{"location":"cobweb/#cobwebadd_slider","text":"Cobweb . add_slider (param_name, *, valinit=None, valstep=0.1, valinterval=10) Adds a slider which can change the value of a parameter in execution time. Parameters param_name : str The string key of the variable. Must be the same as the key in the dF function. Key Arguments valinit : float, default=None Initial value of the parameter. valinterval : Union[float, list], default=0.1 The range of values the slider of the parameter will cover. valstep : float, default=10 Precision in the slider. Returns None","title":"Cobweb.add_slider"},{"location":"cobweb/#cobwebinitial_position_slider","text":"Cobweb . initial_position_slider (*, valinit=None, valstep=0.05, valinterval=None) Adds a slider for changing initial value on a cobweb plot. Key Arguments valinit : numeric Initial position. Default value is the same as initial position given when initializing Cobweb object. valinterval : Union[float, list] The range of values the slider of the parameter will cover. valstep : float Precision in the slider. Returns None","title":"Cobweb.initial_position_slider"},{"location":"cobweb/#examples","text":"Logistic map cobweb plot and time series, defining the logistic map as a 1D dF function . from phaseportrait import Cobweb def Logistic(x, *, r=1.5): return r*x*(1-x) # Cobweb plot and time series. LogisticCobweb = Cobweb(Logistic, 0.2, [0,1], dF_args={'r':1.5}, yrange=[0,1]) LogisticCobweb.add_slider('r', valinit=1.5, valinterval=[0,4]) LogisticCobweb.initial_position_slider(valstep=0.01) LogisticCobweb.plot() This will output the following plots:","title":"Examples"},{"location":"contributing/","text":"Contributing The code is open, everyone can download it and use it. You can also contribute if you wish. To do that, several options are offered: Fork the project, add a new feature / improve the existing ones and pull a request via GitHub. Contact us on our emails: vhloras@gmail.com unaileria@gmail.com","title":"Contributing"},{"location":"contributing/#contributing","text":"The code is open, everyone can download it and use it. You can also contribute if you wish. To do that, several options are offered: Fork the project, add a new feature / improve the existing ones and pull a request via GitHub. Contact us on our emails: vhloras@gmail.com unaileria@gmail.com","title":"Contributing"},{"location":"dFfunction/","text":"dF function This function is thought to compute the derivatives of given coordinates: def dF(x,y): return expressionX , expressionY It must contain as much args as returned elements. kargs Kargs can be given. They can be changed using sliders method. For an harmonic oscillator, the dF function will be defined as: def dFOscillator(x, y, *, \u03c9=1): return y, -\u03c9*\u03c9*x Where \u03c9 is the angular frequency of the oscillator. General definiton In general, dF function will be defined the following way: def dF(*args, *, **kargs) -> tuple: Where: len(dF(*args, **kargs)) == len(args)","title":"dF Function"},{"location":"dFfunction/#df-function","text":"This function is thought to compute the derivatives of given coordinates: def dF(x,y): return expressionX , expressionY It must contain as much args as returned elements.","title":"dF function"},{"location":"dFfunction/#kargs","text":"Kargs can be given. They can be changed using sliders method. For an harmonic oscillator, the dF function will be defined as: def dFOscillator(x, y, *, \u03c9=1): return y, -\u03c9*\u03c9*x Where \u03c9 is the angular frequency of the oscillator.","title":"kargs"},{"location":"dFfunction/#general-definiton","text":"In general, dF function will be defined the following way: def dF(*args, *, **kargs) -> tuple: Where: len(dF(*args, **kargs)) == len(args)","title":"General definiton"},{"location":"generator/","text":"_Generator_ class phaseportrait.generator_base. _Generator_ ( dF, initial_position, xrange, *, dF_args={None}, yrange=[], max_steps=100, n_points=100, **kargs ) This class is used internally in Maps and Trajectories. We do not recommend beginners using it directly. A class used to generate and save data. Parameters portrait : Class that uses the _Generator_ objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved. Key Arguments dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. Methods to be overwritten _Generator_ . _next _Generator_ . _next () Generates from self.position its following value Returns None _Generator_ . save _Generator_ . save () Saves self.position in a convenient way for the type of representation. Returns None _Generator_ . clear_values _Generator_ . clear_values () Clears the data arrays. Returns None _Generator_ . _check_limit_cycle _Generator_ . _check_limit_cycle (_delta) (Optional) Checks if the trajectory is on a limit cycle. Returns False int, number of saved points Methods _Generator_ .compute_all _Generator_ . compute_all (*, save_freq=1, limit_cycle_check=False, delta=0.01) Computes _Generator_.max_values and saves them. Key Arguments save_freq : int, optional, by default 1 Number of values computed before saving them. limit_cycle_check : int, optional, by default False Number of points before checking for limit cycles. delta : float, optional, by default 0.01 Diference between two values to be considerated equal. Returns Numpy.ndarray Saved data with size: [ _Generator_.dimension , _Generator_.max_values ] _Generator_ ._create_values_array _Generator_ . _create_values_array (*, max_values: int = None) Creates an array for storaging the values. Key Arguments max_values : int, optional, by default None Max size of the arrays. Returns Numpy.ndarray Empty array with size dimension*max_values _Generator_ .Nnext _Generator_ . Nnext (number, *, save_freq=1, limit_cycle_check=False, delta=0.001) Computes next number pairs of position and velocity values and saves them. Parameters number : int Number of pairs of values saved. Key Arguments delta : float, optional Difference between numbers to be considerated equal. Only if limit_cycle_check=True . save_freq : int, optional, by default 1 Number of values computed before saving them. limit_cycle_check : bool, optional, by default False Whenever to look for limit cycles. Returns int, optional Only if limit_cycle_check is True . It returns the number of points calculated. _Generator_ .next _Generator_ . next (*, index=1) Computes the next usable pair of values and saves them. Parameters index : int, optional, by default 1 Where to save the pair of values. Returns None Examples There are examples of how to implement this class in the folowing files: * phase-portrait/maps/map.py * phase-portrait/trajectories/rungekutta.py","title":"Generator base"},{"location":"generator/#_generator_","text":"class phaseportrait.generator_base. _Generator_ ( dF, initial_position, xrange, *, dF_args={None}, yrange=[], max_steps=100, n_points=100, **kargs ) This class is used internally in Maps and Trajectories. We do not recommend beginners using it directly. A class used to generate and save data.","title":"_Generator_"},{"location":"generator/#parameters","text":"portrait : Class that uses the _Generator_ objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved.","title":"Parameters"},{"location":"generator/#key-arguments","text":"dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0.","title":"Key Arguments"},{"location":"generator/#methods-to-be-overwritten","text":"","title":"Methods to be overwritten"},{"location":"generator/#_generator__next","text":"_Generator_ . _next () Generates from self.position its following value Returns None","title":"_Generator_._next"},{"location":"generator/#_generator_save","text":"_Generator_ . save () Saves self.position in a convenient way for the type of representation. Returns None","title":"_Generator_.save"},{"location":"generator/#_generator_clear_values","text":"_Generator_ . clear_values () Clears the data arrays. Returns None","title":"_Generator_.clear_values"},{"location":"generator/#_generator__check_limit_cycle","text":"_Generator_ . _check_limit_cycle (_delta) (Optional) Checks if the trajectory is on a limit cycle. Returns False int, number of saved points","title":"_Generator_._check_limit_cycle"},{"location":"generator/#methods","text":"","title":"Methods"},{"location":"generator/#_generator_compute_all","text":"_Generator_ . compute_all (*, save_freq=1, limit_cycle_check=False, delta=0.01) Computes _Generator_.max_values and saves them. Key Arguments save_freq : int, optional, by default 1 Number of values computed before saving them. limit_cycle_check : int, optional, by default False Number of points before checking for limit cycles. delta : float, optional, by default 0.01 Diference between two values to be considerated equal. Returns Numpy.ndarray Saved data with size: [ _Generator_.dimension , _Generator_.max_values ]","title":"_Generator_.compute_all"},{"location":"generator/#_generator__create_values_array","text":"_Generator_ . _create_values_array (*, max_values: int = None) Creates an array for storaging the values. Key Arguments max_values : int, optional, by default None Max size of the arrays. Returns Numpy.ndarray Empty array with size dimension*max_values","title":"_Generator_._create_values_array"},{"location":"generator/#_generator_nnext","text":"_Generator_ . Nnext (number, *, save_freq=1, limit_cycle_check=False, delta=0.001) Computes next number pairs of position and velocity values and saves them. Parameters number : int Number of pairs of values saved. Key Arguments delta : float, optional Difference between numbers to be considerated equal. Only if limit_cycle_check=True . save_freq : int, optional, by default 1 Number of values computed before saving them. limit_cycle_check : bool, optional, by default False Whenever to look for limit cycles. Returns int, optional Only if limit_cycle_check is True . It returns the number of points calculated.","title":"_Generator_.Nnext"},{"location":"generator/#_generator_next","text":"_Generator_ . next (*, index=1) Computes the next usable pair of values and saves them. Parameters index : int, optional, by default 1 Where to save the pair of values. Returns None","title":"_Generator_.next"},{"location":"generator/#examples","text":"There are examples of how to implement this class in the folowing files: * phase-portrait/maps/map.py * phase-portrait/trajectories/rungekutta.py","title":"Examples"},{"location":"getting_started/","text":"Instructions Using phaseportrait is easy, it has to be firstly imported, which can be done this way: from phaseportrait import * This will let us use the following classes: PhasePortrait2D Trajectory3D Both of them share their first arg: a function that computes the derivative of given coordinates in a point. dF function def dF(x,y): return expressionX , expressionY Extra variables can also be passed in dictionary form. For example, we can pass \u03c9 parameter for an harmonic oscillator with default value 1 the following way: def dFOscillator(x, y, *, \u03c9=1): return y, -\u03c9*\u03c9*x PhasePortrait2D class phaseportrait. PhasePortrait2D ( dF, Range, *, MeshDim=10, dF_args={}, Density=1, Polar=False, **kargs ) Gives the option to represent a 2D phase portrait given a dF function with 2 args. Trajectory2D class phaseportrait. Trajectory2D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Gives the option to represent 2D trajectories given a dF function with 3 args. Trajectory3D class phaseportrait. Trajectory3D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Gives the option to represent 3D trajectories given a dF function with 3 args.","title":"Getting started"},{"location":"getting_started/#instructions","text":"Using phaseportrait is easy, it has to be firstly imported, which can be done this way: from phaseportrait import * This will let us use the following classes: PhasePortrait2D Trajectory3D Both of them share their first arg: a function that computes the derivative of given coordinates in a point.","title":"Instructions"},{"location":"getting_started/#df-function","text":"def dF(x,y): return expressionX , expressionY Extra variables can also be passed in dictionary form. For example, we can pass \u03c9 parameter for an harmonic oscillator with default value 1 the following way: def dFOscillator(x, y, *, \u03c9=1): return y, -\u03c9*\u03c9*x","title":"dF function"},{"location":"getting_started/#phaseportrait2d","text":"class phaseportrait. PhasePortrait2D ( dF, Range, *, MeshDim=10, dF_args={}, Density=1, Polar=False, **kargs ) Gives the option to represent a 2D phase portrait given a dF function with 2 args.","title":"PhasePortrait2D"},{"location":"getting_started/#trajectory2d","text":"class phaseportrait. Trajectory2D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Gives the option to represent 2D trajectories given a dF function with 3 args.","title":"Trajectory2D"},{"location":"getting_started/#trajectory3d","text":"class phaseportrait. Trajectory3D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Gives the option to represent 3D trajectories given a dF function with 3 args.","title":"Trajectory3D"},{"location":"license/","text":"MIT License Copyright (c) 2021 V\u00edctor Loras & Unai Ler\u00eda Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#mit-license","text":"Copyright (c) 2021 V\u00edctor Loras & Unai Ler\u00eda Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"map/","text":"Map class phaseportrait.maps. Map (portrait, dF, dimension, max_values, *, dt=0.1, dF_args=None, initial_values=None, thermalization=0) This class is used internally in Map1D. This class is an implementation of _Generator_ for maps generators. Parameters portrait : Class that uses the Map objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved. Key Arguments dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. Overwritten methods map . _next map . _next () Generates from self.position its following value. Explicitly: def _next(self): self.position[0] = self.dF(*(self.position), **self.dF_args) Returns None map . save map . save (i) Saves self.position in the attribute self.positions . Parameters i : int Index in which the data is saved. Explicitly: def save(self, i): try: self.positions[:, i] = self.position except IndexError: np.concatenate(self.positions, self._create_values_array(), axis=1) self.max_values *= 2 self.save(i) Returns None map . clear_values map . clear_values () Clears the data arrays self.positions . Returns None map ._check_limit_cycle map . _check_limit_cycle () Parameters delta : float Difference between data values to be considerated equal. Returns * bool Whenever data reached a limit cylce. Methods map .instance_and_compute_all map . instance_and_compute_all (portrait, dF, dimension, dF_args, initial_values, max_values, save_freq=1, dt=0.1, thermalization=0) Creates an instance of phase-portrait.trajectories.Map. Computes all the data requested and returns the instance. Parameters portrait : Class that uses the Map objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved. dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat save_freq : int, optional, by default 1 Number of values computed before saving them. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. limit_cycle_check : int, bool, optional, by default False Whenever to check it there os a limit cycle in the data. delta : float, optional, by default 0.01 If limit_cycle_check==True is the distance between data elements to be considerated equal. Returns phase-portrait.trajectories.Map Examples There are examples of how to implement this class in the folowing files: phase-portrait/Map1D.py","title":"Map"},{"location":"map/#map","text":"class phaseportrait.maps. Map (portrait, dF, dimension, max_values, *, dt=0.1, dF_args=None, initial_values=None, thermalization=0) This class is used internally in Map1D. This class is an implementation of _Generator_ for maps generators.","title":"Map"},{"location":"map/#parameters","text":"portrait : Class that uses the Map objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved.","title":"Parameters"},{"location":"map/#key-arguments","text":"dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0.","title":"Key Arguments"},{"location":"map/#overwritten-methods","text":"","title":"Overwritten methods"},{"location":"map/#map_next","text":"map . _next () Generates from self.position its following value. Explicitly: def _next(self): self.position[0] = self.dF(*(self.position), **self.dF_args) Returns None","title":"map._next"},{"location":"map/#mapsave","text":"map . save (i) Saves self.position in the attribute self.positions . Parameters i : int Index in which the data is saved. Explicitly: def save(self, i): try: self.positions[:, i] = self.position except IndexError: np.concatenate(self.positions, self._create_values_array(), axis=1) self.max_values *= 2 self.save(i) Returns None","title":"map.save"},{"location":"map/#mapclear_values","text":"map . clear_values () Clears the data arrays self.positions . Returns None","title":"map.clear_values"},{"location":"map/#map_check_limit_cycle","text":"map . _check_limit_cycle () Parameters delta : float Difference between data values to be considerated equal. Returns * bool Whenever data reached a limit cylce.","title":"map._check_limit_cycle"},{"location":"map/#methods","text":"","title":"Methods"},{"location":"map/#mapinstance_and_compute_all","text":"map . instance_and_compute_all (portrait, dF, dimension, dF_args, initial_values, max_values, save_freq=1, dt=0.1, thermalization=0) Creates an instance of phase-portrait.trajectories.Map. Computes all the data requested and returns the instance. Parameters portrait : Class that uses the Map objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved. dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat save_freq : int, optional, by default 1 Number of values computed before saving them. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. limit_cycle_check : int, bool, optional, by default False Whenever to check it there os a limit cycle in the data. delta : float, optional, by default 0.01 If limit_cycle_check==True is the distance between data elements to be considerated equal. Returns phase-portrait.trajectories.Map","title":"map.instance_and_compute_all"},{"location":"map/#examples","text":"There are examples of how to implement this class in the folowing files: phase-portrait/Map1D.py","title":"Examples"},{"location":"map1d/","text":"Work in progres...","title":"1D Maps"},{"location":"map1d/#work-in-progres","text":"","title":"Work in progres..."},{"location":"mapsandcobweb_examples/","text":"","title":"1D maps and cobweb plots"},{"location":"nullclines/","text":"Nullcline2D class phaseportrait. Nullcline2D ( portrait, function, *, precision=0.01, xprecision=None, yprecision=None, offset=0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='b', bgcolor='w', alpha=0 ) Class dedicated to 2 dimensions phase portraits. Useful where it is necessary to plot nullclines in a plot. Integrated via method add_nullclines in PhasePortrait2D . Parameters portrait : The class that uses Nullcline2D function : callable A dF type funcion. precision : float, optional The minimum diference from offset to be considerated a nullcline, by default 0.01 xprecision : float, optional For a different precision value only in the x axis, by default precision yprecision : float, optional For a different precision value only in the y axis, by default precision offset : float, optional If you want, for instance, a twoclide, by default 0 density : int, optional Number of inner divisions on the x axis and y axis, by default 50 xRange : Union[float,list], optional The range in which the nullclines are calculated, by default portrait.Range[0] yRange : Union[float,list], optional The range in which the nullclines are calculated, by default portrait.Range[1] dF_args : dict, optional If necesary, must contain the kargs for the dF funcion, by default None xcolor : str, optional X nullcline color, by default 'r' ycolor : str, optional Y nullcline color, by default 'b' bgcolor : str, optional Background color, by default 'w' alpha : int, optional Opacity of the background, by default 0 Methods Nullcline2D .plot Nullcline2D . plot (*, axis=None) Plots the nullclines in the given axis Parameters axis : matplotlib.Axis, optional The axis in which the nullclines will be represented, by default portrait.ax Returns [matplotlib.contour.QuadContourSet,matplotlib.contour.QuadContourSet] X and Y contours. Examples from phaseportrait import PhasePortrait2D def dF(x,y): return x + np.exp(-y), -y example = PhasePortrait2D(dF, [[-10,10], [-5, 5]]) example.add_nullclines(precision=0.05) example.plot()","title":"Nullclines"},{"location":"nullclines/#nullcline2d","text":"class phaseportrait. Nullcline2D ( portrait, function, *, precision=0.01, xprecision=None, yprecision=None, offset=0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='b', bgcolor='w', alpha=0 ) Class dedicated to 2 dimensions phase portraits. Useful where it is necessary to plot nullclines in a plot. Integrated via method add_nullclines in PhasePortrait2D .","title":"Nullcline2D"},{"location":"nullclines/#parameters","text":"portrait : The class that uses Nullcline2D function : callable A dF type funcion. precision : float, optional The minimum diference from offset to be considerated a nullcline, by default 0.01 xprecision : float, optional For a different precision value only in the x axis, by default precision yprecision : float, optional For a different precision value only in the y axis, by default precision offset : float, optional If you want, for instance, a twoclide, by default 0 density : int, optional Number of inner divisions on the x axis and y axis, by default 50 xRange : Union[float,list], optional The range in which the nullclines are calculated, by default portrait.Range[0] yRange : Union[float,list], optional The range in which the nullclines are calculated, by default portrait.Range[1] dF_args : dict, optional If necesary, must contain the kargs for the dF funcion, by default None xcolor : str, optional X nullcline color, by default 'r' ycolor : str, optional Y nullcline color, by default 'b' bgcolor : str, optional Background color, by default 'w' alpha : int, optional Opacity of the background, by default 0","title":"Parameters"},{"location":"nullclines/#methods","text":"","title":"Methods"},{"location":"nullclines/#nullcline2dplot","text":"Nullcline2D . plot (*, axis=None) Plots the nullclines in the given axis Parameters axis : matplotlib.Axis, optional The axis in which the nullclines will be represented, by default portrait.ax Returns [matplotlib.contour.QuadContourSet,matplotlib.contour.QuadContourSet] X and Y contours.","title":"Nullcline2D.plot"},{"location":"nullclines/#examples","text":"from phaseportrait import PhasePortrait2D def dF(x,y): return x + np.exp(-y), -y example = PhasePortrait2D(dF, [[-10,10], [-5, 5]]) example.add_nullclines(precision=0.05) example.plot()","title":"Examples"},{"location":"phaseportrait2d/","text":"PhasePortrait2D class phaseportrait. PhasePortrait2D ( dF, Range, *, MeshDim=10, dF_args={}, Density=1, Polar=False, **kargs ) Gives the option to represent a 2D phase portrait given a dF function with 2 args. Parameters dF : callable A dF type funcion. Computes the derivatives of given coordinates. Range : [x_range, y_range] Ranges of the axis in the main plot. See Defining Range . Key Arguments MeshDim : int, default=500 Number of elements in the arrows grid. dF_args : dict If necesary, must contain the kargs for the dF function. Density : float, default=1 Number of elements in the arrows grid plot. Polar : bool, default=False Whether to use polar coordinates or not. Title : str, default='Phase Portrait' Title of the plot. xlabel : str, default='X' x label of the plot. ylabel : str, default='$\\dot{X}$' y label of the plot. color : str, default='rainbow' Matplotlib Cmap . Methods PhasePortrait2D .plot PhasePortrait2D . plot ( *, color=None ) Prepares the plots and computes the values.. Color scheme can be changed introducing key argument color . A list with accepted values can be found here . Returns tuple(matplotlib Figure, matplotlib Axis) PhasePortrait2D .add_slider PhasePortrait2D . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time. Parameters param_name : str The string key of the variable. Must be the same as the key in the dF function. Key Arguments valinit : float, default=None Initial value of the parameter. valinterval : Union[float, list], default=0.1 The range of values the slider of the parameter will cover. valstep : float, default=10 Precision in the slider. Returns None PhasePortrait2D .add_nullclines PhasePortrait2D . add_nullclines ( *, precision=0.01, offset=0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='g', bgcolor='w', alpha=0 ) Plots nullclines of the system given by dF function. For more info, see Nullclines class. Returns None Defining Range A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]] Examples from phaseportrait import PhasePortrait2D def dF(r, \u03b8, *, \u03bc=0.5,\u03b7=0): return \u03bc*r*(1 - r*r), 1+\u03b7*\u03b8 example = PhasePortrait2D(dF, [-3, 3], Density=2, Polar=True, Title='Limit cycle') example.add_slider('\u03bc', valinit=0.5) example.add_slider('\u03b7', valinit=0.0) example.add_nullclines() example.plot()","title":"PhasePortrait2d"},{"location":"phaseportrait2d/#phaseportrait2d","text":"class phaseportrait. PhasePortrait2D ( dF, Range, *, MeshDim=10, dF_args={}, Density=1, Polar=False, **kargs ) Gives the option to represent a 2D phase portrait given a dF function with 2 args.","title":"PhasePortrait2D"},{"location":"phaseportrait2d/#parameters","text":"dF : callable A dF type funcion. Computes the derivatives of given coordinates. Range : [x_range, y_range] Ranges of the axis in the main plot. See Defining Range .","title":"Parameters"},{"location":"phaseportrait2d/#key-arguments","text":"MeshDim : int, default=500 Number of elements in the arrows grid. dF_args : dict If necesary, must contain the kargs for the dF function. Density : float, default=1 Number of elements in the arrows grid plot. Polar : bool, default=False Whether to use polar coordinates or not. Title : str, default='Phase Portrait' Title of the plot. xlabel : str, default='X' x label of the plot. ylabel : str, default='$\\dot{X}$' y label of the plot. color : str, default='rainbow' Matplotlib Cmap .","title":"Key Arguments"},{"location":"phaseportrait2d/#methods","text":"","title":"Methods"},{"location":"phaseportrait2d/#phaseportrait2dplot","text":"PhasePortrait2D . plot ( *, color=None ) Prepares the plots and computes the values.. Color scheme can be changed introducing key argument color . A list with accepted values can be found here . Returns tuple(matplotlib Figure, matplotlib Axis)","title":"PhasePortrait2D.plot"},{"location":"phaseportrait2d/#phaseportrait2dadd_slider","text":"PhasePortrait2D . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time. Parameters param_name : str The string key of the variable. Must be the same as the key in the dF function. Key Arguments valinit : float, default=None Initial value of the parameter. valinterval : Union[float, list], default=0.1 The range of values the slider of the parameter will cover. valstep : float, default=10 Precision in the slider. Returns None","title":"PhasePortrait2D.add_slider"},{"location":"phaseportrait2d/#phaseportrait2dadd_nullclines","text":"PhasePortrait2D . add_nullclines ( *, precision=0.01, offset=0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='g', bgcolor='w', alpha=0 ) Plots nullclines of the system given by dF function. For more info, see Nullclines class. Returns None","title":"PhasePortrait2D.add_nullclines"},{"location":"phaseportrait2d/#defining-range","text":"A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]]","title":"Defining Range"},{"location":"phaseportrait2d/#examples","text":"from phaseportrait import PhasePortrait2D def dF(r, \u03b8, *, \u03bc=0.5,\u03b7=0): return \u03bc*r*(1 - r*r), 1+\u03b7*\u03b8 example = PhasePortrait2D(dF, [-3, 3], Density=2, Polar=True, Title='Limit cycle') example.add_slider('\u03bc', valinit=0.5) example.add_slider('\u03b7', valinit=0.0) example.add_nullclines() example.plot()","title":"Examples"},{"location":"phaseportrait2d_examples/","text":"","title":"2D phase portraits"},{"location":"rungekutta/","text":"RungeKutta class phaseportrait.trajectories. RungeKutta ( portrait, dF, dimension, max_values, , dt=0.1, dF_args=None, initial_values=None, thermalization=0*) This class is used internally in Trajectories. This class is an implementation of _Generator_ for a Runge-Kutta 4th order data generator. Parameters portrait : Class that uses the RungeKutta objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved. Key Arguments dt : double, optional, by default 0.1 Time interval used in the Runge-Kutta 4th order method. dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. Overwritten methods _Generator_ . _next _Generator_ . _next () Generates from self.position its following value via the Runge-Kutta 4th order method. Explicitly: def _next(self): k1 = np.array(self.dF(*(self.position), **self.dF_args)) k2 = np.array(self.dF(*(self.position+0.5*k1*self.dt), **self.dF_args)) k3 = np.array(self.dF(*(self.position+0.5*k2*self.dt), **self.dF_args)) k4 = np.array(self.dF(*(self.position+k3*self.dt), **self.dF_args)) self.velocity = 1/6*(k1+2*k2+2*k3+k4) self.position += self.velocity*self.dt Returns None _Generator_ . save _Generator_ . save (i) Saves self.position in the attribute self.positions , and self.velocity in self.velocities . Parameters i : int Index in which the data is saved. Explicitly: def save(self, i): try: self.positions[:, i] = self.position self.velocities[:, i] = self.velocity except IndexError: np.concatenate(self.positions, self._create_values_array(), axis=1) np.concatenate(self.velocities, self._create_values_array(), axis=1) self.max_values += 2000 self.save(i) Returns None _Generator_ . clear_values _Generator_ . clear_values () Clears the data arrays self.positions and self.velocities . Returns None Methods _Generator_ .instance_and_compute_all _Generator_ . instance_and_compute_all (portrait, dF, dimension, dF_args, initial_values, max_values, save_freq=1, dt=0.1, thermalization=0) Creates an instance of phase-portrait.trajectories.RungeKutta. Computes all the data requested and returns the instance. Parameters portrait : Class that uses the RungeKutta objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat max_values : int Max number of values saved. save_freq : int, optional, by default 1 Number of values computed before saving them. dt : double, by default 0.1 Time interval used in the Runge-Kutta 4th order method. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. Returns phase-portrait.trajectories.RungeKutta Examples There are examples of how to implement this class in the folowing files: phase-portrait/trajectories/trajectory.py","title":"Runge Kutta"},{"location":"rungekutta/#rungekutta","text":"class phaseportrait.trajectories. RungeKutta ( portrait, dF, dimension, max_values, , dt=0.1, dF_args=None, initial_values=None, thermalization=0*) This class is used internally in Trajectories. This class is an implementation of _Generator_ for a Runge-Kutta 4th order data generator.","title":"RungeKutta"},{"location":"rungekutta/#parameters","text":"portrait : Class that uses the RungeKutta objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved.","title":"Parameters"},{"location":"rungekutta/#key-arguments","text":"dt : double, optional, by default 0.1 Time interval used in the Runge-Kutta 4th order method. dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0.","title":"Key Arguments"},{"location":"rungekutta/#overwritten-methods","text":"","title":"Overwritten methods"},{"location":"rungekutta/#_generator__next","text":"_Generator_ . _next () Generates from self.position its following value via the Runge-Kutta 4th order method. Explicitly: def _next(self): k1 = np.array(self.dF(*(self.position), **self.dF_args)) k2 = np.array(self.dF(*(self.position+0.5*k1*self.dt), **self.dF_args)) k3 = np.array(self.dF(*(self.position+0.5*k2*self.dt), **self.dF_args)) k4 = np.array(self.dF(*(self.position+k3*self.dt), **self.dF_args)) self.velocity = 1/6*(k1+2*k2+2*k3+k4) self.position += self.velocity*self.dt Returns None","title":"_Generator_._next"},{"location":"rungekutta/#_generator_save","text":"_Generator_ . save (i) Saves self.position in the attribute self.positions , and self.velocity in self.velocities . Parameters i : int Index in which the data is saved. Explicitly: def save(self, i): try: self.positions[:, i] = self.position self.velocities[:, i] = self.velocity except IndexError: np.concatenate(self.positions, self._create_values_array(), axis=1) np.concatenate(self.velocities, self._create_values_array(), axis=1) self.max_values += 2000 self.save(i) Returns None","title":"_Generator_.save"},{"location":"rungekutta/#_generator_clear_values","text":"_Generator_ . clear_values () Clears the data arrays self.positions and self.velocities . Returns None","title":"_Generator_.clear_values"},{"location":"rungekutta/#methods","text":"","title":"Methods"},{"location":"rungekutta/#_generator_instance_and_compute_all","text":"_Generator_ . instance_and_compute_all (portrait, dF, dimension, dF_args, initial_values, max_values, save_freq=1, dt=0.1, thermalization=0) Creates an instance of phase-portrait.trajectories.RungeKutta. Computes all the data requested and returns the instance. Parameters portrait : Class that uses the RungeKutta objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat max_values : int Max number of values saved. save_freq : int, optional, by default 1 Number of values computed before saving them. dt : double, by default 0.1 Time interval used in the Runge-Kutta 4th order method. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. Returns phase-portrait.trajectories.RungeKutta","title":"_Generator_.instance_and_compute_all"},{"location":"rungekutta/#examples","text":"There are examples of how to implement this class in the folowing files: phase-portrait/trajectories/trajectory.py","title":"Examples"},{"location":"slider/","text":"Sliders class phaseportrait.sliders. Slider ( portrait, param_name, valinit=None, valstep=0.1, valinterval=[] ) This class is not pretended to be used by the user. It is handled by the other objects automatically. Adds a slider which can change the value of a parameter in dF during execution time. Integrated via method add_slider in: * Map1D Cobweb PhasePortrait2D Trajectory2D Trajectory3D Parameters portrait : Class that uses the Slider. param_name : str Name of the parameter to slide over. valinit : float Initial value of the parameter in the slider. valsetp : float, default=0.1 Precision of the slider. valinterval : Union[float, list] Parameter range in the slider. Default value is [-10, 10] Methods Slider .__call__ method __call__ ( value ) Updates internal dF_args and replots the graphs. Arguments value : float New value for the parameter of the slider Returns None","title":"Slider"},{"location":"slider/#sliders","text":"class phaseportrait.sliders. Slider ( portrait, param_name, valinit=None, valstep=0.1, valinterval=[] ) This class is not pretended to be used by the user. It is handled by the other objects automatically. Adds a slider which can change the value of a parameter in dF during execution time. Integrated via method add_slider in: * Map1D Cobweb PhasePortrait2D Trajectory2D Trajectory3D","title":"Sliders"},{"location":"slider/#parameters","text":"portrait : Class that uses the Slider. param_name : str Name of the parameter to slide over. valinit : float Initial value of the parameter in the slider. valsetp : float, default=0.1 Precision of the slider. valinterval : Union[float, list] Parameter range in the slider. Default value is [-10, 10]","title":"Parameters"},{"location":"slider/#methods","text":"","title":"Methods"},{"location":"slider/#slider__call__","text":"method __call__ ( value ) Updates internal dF_args and replots the graphs. Arguments value : float New value for the parameter of the slider Returns None","title":"Slider.__call__"},{"location":"trajectories_examples/","text":"","title":"2D & 3D trajectories"},{"location":"trajectory/","text":"Trajectory class phaseportrait.trajectories. trajectory ( dF, dimension, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **karg ) This class is not meant to be used by the user. Parent class for trajectory2d and trajectory3d . Represents trajectories given a dF function with N args. Class inheriting must have the following methods: def _prepare_plot(self): ... Prepares the plots: axis titles, graph title, grid, etc. def _plot_lines(self, val, val_init): ... Plots a line of points given in a tuple of positions val and an initial position val_init , both N-dimensional. def _scatter_start_point(self, val_init): ... Marks starting position val_init (N-dimensional) in the several plots created. def _scatter_trajectory(self, val, color, cmap): ... Plots with points val (N-dimensional list) according to color (N-dimensional) with cmap color map. Methods Aqu\u00ed me he quedao","title":"Trajectory"},{"location":"trajectory/#trajectory","text":"class phaseportrait.trajectories. trajectory ( dF, dimension, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **karg ) This class is not meant to be used by the user. Parent class for trajectory2d and trajectory3d . Represents trajectories given a dF function with N args. Class inheriting must have the following methods: def _prepare_plot(self): ... Prepares the plots: axis titles, graph title, grid, etc. def _plot_lines(self, val, val_init): ... Plots a line of points given in a tuple of positions val and an initial position val_init , both N-dimensional. def _scatter_start_point(self, val_init): ... Marks starting position val_init (N-dimensional) in the several plots created. def _scatter_trajectory(self, val, color, cmap): ... Plots with points val (N-dimensional list) according to color (N-dimensional) with cmap color map.","title":"Trajectory"},{"location":"trajectory/#methods","text":"Aqu\u00ed me he quedao","title":"Methods"},{"location":"trajectory2d/","text":"Trajectory2D class phaseportrait. Trajectory2D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Inherits from parent class trajectory . Computes a trajectory on a 2D system given a dF consisting of 2 args. Parameters dF : callable A dF type function. Key Arguments Range : list Ranges if the axis in the main plot, by default None. See Defining Range . dF_args : dict If necesary, must contain the kargs for the dF function, by default {} n_points : int Maximum number of points to be calculated and represented, by default 10000 runge_kutta_step : float Step of 'time' in the Runge-Kutta method, by default 0.01 runge_kutta_freq : int Number of times dF is aplied between positions saved, by default 1 xlabel : str x label of the plot, by default 'X' ylabel : str y label of the plot, by default 'Y' Methods Inherits methods from parent class trajectory , a brief resume is offered, click on the method to see more information: thermalize : Adds thermalization steps and random initial position. initial_position : Adds a trajectory with the given initial position. plot : Prepares the plots and computes the values. Returns the axis and the figure. add_slider : Adds a slider for the dF function. Defining Range A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]] Examples from phaseportrait import Trajectories2D import numpy as np def dF(x,y,*, w=1, z=1): return w*np.sin(y*y*y), -z*np.exp(x*x) example = Trajectory2D(dF, n_points=1300, size=2, mark_start_position=True, Title='Just an example') example.initial_position(1,1) example.add_slider('w', valinterval=[-1,5]) example.add_slider('z', valinterval=[-1,5]) example.plot() plt.show()","title":"Trajectory2d"},{"location":"trajectory2d/#trajectory2d","text":"class phaseportrait. Trajectory2D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Inherits from parent class trajectory . Computes a trajectory on a 2D system given a dF consisting of 2 args.","title":"Trajectory2D"},{"location":"trajectory2d/#parameters","text":"dF : callable A dF type function.","title":"Parameters"},{"location":"trajectory2d/#key-arguments","text":"Range : list Ranges if the axis in the main plot, by default None. See Defining Range . dF_args : dict If necesary, must contain the kargs for the dF function, by default {} n_points : int Maximum number of points to be calculated and represented, by default 10000 runge_kutta_step : float Step of 'time' in the Runge-Kutta method, by default 0.01 runge_kutta_freq : int Number of times dF is aplied between positions saved, by default 1 xlabel : str x label of the plot, by default 'X' ylabel : str y label of the plot, by default 'Y'","title":"Key Arguments"},{"location":"trajectory2d/#methods","text":"Inherits methods from parent class trajectory , a brief resume is offered, click on the method to see more information: thermalize : Adds thermalization steps and random initial position. initial_position : Adds a trajectory with the given initial position. plot : Prepares the plots and computes the values. Returns the axis and the figure. add_slider : Adds a slider for the dF function.","title":"Methods"},{"location":"trajectory2d/#defining-range","text":"A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]]","title":"Defining Range"},{"location":"trajectory2d/#examples","text":"from phaseportrait import Trajectories2D import numpy as np def dF(x,y,*, w=1, z=1): return w*np.sin(y*y*y), -z*np.exp(x*x) example = Trajectory2D(dF, n_points=1300, size=2, mark_start_position=True, Title='Just an example') example.initial_position(1,1) example.add_slider('w', valinterval=[-1,5]) example.add_slider('z', valinterval=[-1,5]) example.plot() plt.show()","title":"Examples"},{"location":"trajectory3d/","text":"Trajectory3D class phaseportrait. Trajectory3D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Inherits from parent class trajectory . Gives the option to represent 3D trajectories given a dF function with 3 args. Parameters dF : callable A dF type function. Key Arguments Range : list Ranges of the axis in the main plot, by default None. See Defining Range . dF_args : dict If necesary, must contain the kargs for the dF function, by default {} n_points : int Maximum number of points to be calculated and represented, by default 10000 runge_kutta_step : float Step of 'time' in the Runge-Kutta method, by default 0.01 runge_kutta_freq : int Number of times dF is aplied between positions saved, by default 1 xlabel : str x label of the plot, by default 'X' ylabel : str y label of the plot, by default 'Y' zlabel : str z label of the plot, by default 'Z' Methods Inherits methods from parent class trajectory , a brief resume is offered, click on the method to see more information: thermalize : Adds thermalization steps and random initial position. initial_position : Adds a trajectory with the given initial position. plot : Prepares the plots and computes the values. Returns the axis and the figure. add_slider : Adds a slider for the dF function. Defining Range A single number. In this case the range is defined from zero to the given number in all axes. A range, such [lowerLimit , upperLimit] . All axes will take the same limits. Three ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit], [zAxisLowerLimit , zAxisUpperLimit]] Examples from phaseportrait import Trajectories3D def Lorenz(x,y,z,*, s=10, r=28, b=8/3): return -s*x+s*y, -x*z+r*x-y, x*y-b*z a = Trajectory3D(Lorenz, lines=True, n_points=1300, size=3, mark_start_position=True, Title='Nearby IC on Lorenz attractor') a.initial_position(10,10,10) a.initial_position(10,10,10.0001) a.plot() from phaseportrait import Trajectories3D def Halvorsen(x,y,z, *, s=1.4): delta = (3*s+15) return -s*x+2*y-4*z-y**2+delta , -s*y+2*z-4*x-z**2+delta, -s*z+2*x-4*y-x**2+delta d = Trajectory3D(Halvorsen, dF_args={'s':1.4}, n_points=10000, thermalization=0, numba=True, size=2, mark_start_point=True, Title='Halvorsen attractor') d.initial_position(0,5,10) d.plot()","title":"Trajectory3d"},{"location":"trajectory3d/#trajectory3d","text":"class phaseportrait. Trajectory3D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Inherits from parent class trajectory . Gives the option to represent 3D trajectories given a dF function with 3 args.","title":"Trajectory3D"},{"location":"trajectory3d/#parameters","text":"dF : callable A dF type function.","title":"Parameters"},{"location":"trajectory3d/#key-arguments","text":"Range : list Ranges of the axis in the main plot, by default None. See Defining Range . dF_args : dict If necesary, must contain the kargs for the dF function, by default {} n_points : int Maximum number of points to be calculated and represented, by default 10000 runge_kutta_step : float Step of 'time' in the Runge-Kutta method, by default 0.01 runge_kutta_freq : int Number of times dF is aplied between positions saved, by default 1 xlabel : str x label of the plot, by default 'X' ylabel : str y label of the plot, by default 'Y' zlabel : str z label of the plot, by default 'Z'","title":"Key Arguments"},{"location":"trajectory3d/#methods","text":"Inherits methods from parent class trajectory , a brief resume is offered, click on the method to see more information: thermalize : Adds thermalization steps and random initial position. initial_position : Adds a trajectory with the given initial position. plot : Prepares the plots and computes the values. Returns the axis and the figure. add_slider : Adds a slider for the dF function.","title":"Methods"},{"location":"trajectory3d/#defining-range","text":"A single number. In this case the range is defined from zero to the given number in all axes. A range, such [lowerLimit , upperLimit] . All axes will take the same limits. Three ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit], [zAxisLowerLimit , zAxisUpperLimit]]","title":"Defining Range"},{"location":"trajectory3d/#examples","text":"from phaseportrait import Trajectories3D def Lorenz(x,y,z,*, s=10, r=28, b=8/3): return -s*x+s*y, -x*z+r*x-y, x*y-b*z a = Trajectory3D(Lorenz, lines=True, n_points=1300, size=3, mark_start_position=True, Title='Nearby IC on Lorenz attractor') a.initial_position(10,10,10) a.initial_position(10,10,10.0001) a.plot() from phaseportrait import Trajectories3D def Halvorsen(x,y,z, *, s=1.4): delta = (3*s+15) return -s*x+2*y-4*z-y**2+delta , -s*y+2*z-4*x-z**2+delta, -s*z+2*x-4*y-x**2+delta d = Trajectory3D(Halvorsen, dF_args={'s':1.4}, n_points=10000, thermalization=0, numba=True, size=2, mark_start_point=True, Title='Halvorsen attractor') d.initial_position(0,5,10) d.plot()","title":"Examples"}]}