{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What's this? The idea behind this project was to create a simple way to make phase portraits in 2D and 3D, as we couldn't find something similar on the internet, so we got down to work. Eventually, we did some work on bifurcations, 1D maps and chaos. This idea came while taking a course in non linear dynamics and chaos, during the 3rd year of physics degree, brought by our desire of visualizing things and programming. We want to state that we are self-taught into making this kind of stuff, and we've tried to make things as professionally as possible, any comments about improving our work are welcome! At first, this project was made up in spanish. The spanish version can be found here . Disclaimer: As of today (July 2021), we've decided to cease our work on this project (for the moment, as we have to move on other things). Therefore, this is the 'final' version of the project, there are no more features incoming. We've tried to leave the code documentated and with good organisation in case someone wants to carry on with some new ideas! Cheers Authors V\u00edctor Loras Herrero ( vhloras@gmail.com ) ( GitHub ) Unai Ler\u00eda Fortea ( unaileria@gmail.com ) ( GitHub ) Examples of use In Tutorials tab, we've prepared some introduction to the classes contained in phaseportrait's module. Some more examples can be found on the GitHub repository. examples.ipynb : examples showing how to use PhasePortrait2D class. sliderExamples.py : examples using the slider feature from PhasePortrait2D class. TrajectoryExamples.py : contains examples of 2D and 3D trajectories with and without sliders. mapExamples.py : contains examples of the most famous cobweb plots and 1D maps.","title":"What's this?"},{"location":"#whats-this","text":"The idea behind this project was to create a simple way to make phase portraits in 2D and 3D, as we couldn't find something similar on the internet, so we got down to work. Eventually, we did some work on bifurcations, 1D maps and chaos. This idea came while taking a course in non linear dynamics and chaos, during the 3rd year of physics degree, brought by our desire of visualizing things and programming. We want to state that we are self-taught into making this kind of stuff, and we've tried to make things as professionally as possible, any comments about improving our work are welcome! At first, this project was made up in spanish. The spanish version can be found here .","title":"What's this?"},{"location":"#disclaimer","text":"As of today (July 2021), we've decided to cease our work on this project (for the moment, as we have to move on other things). Therefore, this is the 'final' version of the project, there are no more features incoming. We've tried to leave the code documentated and with good organisation in case someone wants to carry on with some new ideas! Cheers","title":"Disclaimer:"},{"location":"#authors","text":"V\u00edctor Loras Herrero ( vhloras@gmail.com ) ( GitHub ) Unai Ler\u00eda Fortea ( unaileria@gmail.com ) ( GitHub )","title":"Authors"},{"location":"#examples-of-use","text":"In Tutorials tab, we've prepared some introduction to the classes contained in phaseportrait's module. Some more examples can be found on the GitHub repository. examples.ipynb : examples showing how to use PhasePortrait2D class. sliderExamples.py : examples using the slider feature from PhasePortrait2D class. TrajectoryExamples.py : contains examples of 2D and 3D trajectories with and without sliders. mapExamples.py : contains examples of the most famous cobweb plots and 1D maps.","title":"Examples of use"},{"location":"cobweb/","text":"Cobweb class phaseportrait. Cobweb ( dF, initial_position, xrange, *, dF_args={None}, yrange=[], max_steps=100, n_points=100, **kargs ) A class used to represent a Cobweb plot and a time series to study the convergence of a 1D map x(t+1) = f(x) . Parameters dF : callable A dF type funcion. initial_position : float Initial x of the iteration. xrange : list Range of the x axis in the main plot. Key Arguments dF_args : dict If necesary, must contain the kargs for the dF funcion. yrange : list Range of the y axis in the main plot max_steps : int, default=100 Maximum number of points to be represented. n_points : int, default=10000 Number of points in the bisector. Title : str, default='Cobweb plot' Title of the plot. xlabel : str, default=r'$X_{n}$' x label of the plot. ylabel : str, default=r'$X_{n+1}$' y label of the plot. Methods Cobweb .plot Cobweb . plot (*args, **kargs) Creates two figures, one containing the Cobweb plot and other with the time series. Returns tuple(matplotlib Figure (Cobweb plot), matplotlib Axis (Cobweb plot), matplotlib Figure (Time series), matplotlib Axis (Time series)) Cobweb .add_slider Cobweb . add_slider (param_name, *, valinit=None, valstep=0.1, valinterval=10) Adds a slider which can change the value of a parameter in execution time. Parameters param_name : str The string key of the variable. Must be the same as the key in the dF function. Key Arguments valinit : float, default=None Initial value of the parameter. valinterval : Union[float, list], default=0.1 The range of values the slider of the parameter will cover. valstep : float, default=10 Precision in the slider. Returns None Cobweb .initial_position_slider Cobweb . initial_position_slider (*, valinit=None, valstep=0.05, valinterval=None) Adds a slider for changing initial value on a cobweb plot. Key Arguments valinit : numeric Initial position. Default value is the same as initial position given when initializing Cobweb object. valinterval : Union[float, list] The range of values the slider of the parameter will cover. valstep : float Precision in the slider. Returns None Examples Logistic map cobweb plot and time series, defining the logistic map as a 1D dF function . from phaseportrait import Cobweb def Logistic(x, *, r=1.5): return r*x*(1-x) # Cobweb plot and time series. LogisticCobweb = Cobweb(Logistic, 0.2, [0,1], dF_args={'r':1.5}, yrange=[0,1]) LogisticCobweb.add_slider('r', valinit=1.5, valinterval=[0,4]) LogisticCobweb.initial_position_slider(valstep=0.01) LogisticCobweb.plot() This will output the following plots: See more Cobweb examples.","title":"Cobweb plots"},{"location":"cobweb/#cobweb","text":"class phaseportrait. Cobweb ( dF, initial_position, xrange, *, dF_args={None}, yrange=[], max_steps=100, n_points=100, **kargs ) A class used to represent a Cobweb plot and a time series to study the convergence of a 1D map x(t+1) = f(x) .","title":"Cobweb"},{"location":"cobweb/#parameters","text":"dF : callable A dF type funcion. initial_position : float Initial x of the iteration. xrange : list Range of the x axis in the main plot.","title":"Parameters"},{"location":"cobweb/#key-arguments","text":"dF_args : dict If necesary, must contain the kargs for the dF funcion. yrange : list Range of the y axis in the main plot max_steps : int, default=100 Maximum number of points to be represented. n_points : int, default=10000 Number of points in the bisector. Title : str, default='Cobweb plot' Title of the plot. xlabel : str, default=r'$X_{n}$' x label of the plot. ylabel : str, default=r'$X_{n+1}$' y label of the plot.","title":"Key Arguments"},{"location":"cobweb/#methods","text":"","title":"Methods"},{"location":"cobweb/#cobwebplot","text":"Cobweb . plot (*args, **kargs) Creates two figures, one containing the Cobweb plot and other with the time series. Returns tuple(matplotlib Figure (Cobweb plot), matplotlib Axis (Cobweb plot), matplotlib Figure (Time series), matplotlib Axis (Time series))","title":"Cobweb.plot"},{"location":"cobweb/#cobwebadd_slider","text":"Cobweb . add_slider (param_name, *, valinit=None, valstep=0.1, valinterval=10) Adds a slider which can change the value of a parameter in execution time. Parameters param_name : str The string key of the variable. Must be the same as the key in the dF function. Key Arguments valinit : float, default=None Initial value of the parameter. valinterval : Union[float, list], default=0.1 The range of values the slider of the parameter will cover. valstep : float, default=10 Precision in the slider. Returns None","title":"Cobweb.add_slider"},{"location":"cobweb/#cobwebinitial_position_slider","text":"Cobweb . initial_position_slider (*, valinit=None, valstep=0.05, valinterval=None) Adds a slider for changing initial value on a cobweb plot. Key Arguments valinit : numeric Initial position. Default value is the same as initial position given when initializing Cobweb object. valinterval : Union[float, list] The range of values the slider of the parameter will cover. valstep : float Precision in the slider. Returns None","title":"Cobweb.initial_position_slider"},{"location":"cobweb/#examples","text":"Logistic map cobweb plot and time series, defining the logistic map as a 1D dF function . from phaseportrait import Cobweb def Logistic(x, *, r=1.5): return r*x*(1-x) # Cobweb plot and time series. LogisticCobweb = Cobweb(Logistic, 0.2, [0,1], dF_args={'r':1.5}, yrange=[0,1]) LogisticCobweb.add_slider('r', valinit=1.5, valinterval=[0,4]) LogisticCobweb.initial_position_slider(valstep=0.01) LogisticCobweb.plot() This will output the following plots: See more Cobweb examples.","title":"Examples"},{"location":"contributing/","text":"Contributing The code is open, everyone can download it and use it. You can also contribute if you wish. To do that, several options are offered: Fork the project, add a new feature / improve the existing ones and pull a request via GitHub. Contact us on our emails: vhloras@gmail.com unaileria@gmail.com","title":"Contributing"},{"location":"contributing/#contributing","text":"The code is open, everyone can download it and use it. You can also contribute if you wish. To do that, several options are offered: Fork the project, add a new feature / improve the existing ones and pull a request via GitHub. Contact us on our emails: vhloras@gmail.com unaileria@gmail.com","title":"Contributing"},{"location":"dFfunction/","text":"dF function The 'dF' function is refered several times in different implementations of it. It is a function created by the user that describes the system's evolution, either in a 2D phase portrait, a 3d trajectory or the study of a 1D map. Kargs Kargs can be given. They can be changed using sliders method. For example, for an harmonic oscillator, the dF function will be defined as: def dFOscillator(x, y, *, \u03c9=1): return y, -\u03c9*\u03c9*x Where \u03c9 is the angular frequency of the oscillator. General definiton In general, dF function will be defined the following way: def dF(*args, *, **kargs) -> tuple: Where: len(dF(*args, **kargs)) == len(args) Examples 2D Phase portrait When plotting a 2D phase portrait, we have a function f(x,y) that describes the system. The dF function will be constructed by the expressions of the derivatives respect the x and y coordinates, such that: def dF(x,y): return expressionX , expressionY It must contain as much args as returned elements. 3D Trajectory Let's say we want to see some trajectories on Lorenz's attractor. The dF function will be constructed as a function that returns each of the expressions of the system: def Lorenz(x,y,z,*, s=10, r=28, b=8/3): return -s*x+s*y, -x*z+r*x-y, x*y-b*z 1D Maps Let's say we want to study the Logistic Map. The dF function will be constructed by creating a function that returns the evolution of one step in the map: def Logistic(x, *, r=1.5): return r*x*(1-x)","title":"dF function"},{"location":"dFfunction/#df-function","text":"The 'dF' function is refered several times in different implementations of it. It is a function created by the user that describes the system's evolution, either in a 2D phase portrait, a 3d trajectory or the study of a 1D map.","title":"dF function"},{"location":"dFfunction/#kargs","text":"Kargs can be given. They can be changed using sliders method. For example, for an harmonic oscillator, the dF function will be defined as: def dFOscillator(x, y, *, \u03c9=1): return y, -\u03c9*\u03c9*x Where \u03c9 is the angular frequency of the oscillator.","title":"Kargs"},{"location":"dFfunction/#general-definiton","text":"In general, dF function will be defined the following way: def dF(*args, *, **kargs) -> tuple: Where: len(dF(*args, **kargs)) == len(args)","title":"General definiton"},{"location":"dFfunction/#examples","text":"","title":"Examples"},{"location":"dFfunction/#2d-phase-portrait","text":"When plotting a 2D phase portrait, we have a function f(x,y) that describes the system. The dF function will be constructed by the expressions of the derivatives respect the x and y coordinates, such that: def dF(x,y): return expressionX , expressionY It must contain as much args as returned elements.","title":"2D Phase portrait"},{"location":"dFfunction/#3d-trajectory","text":"Let's say we want to see some trajectories on Lorenz's attractor. The dF function will be constructed as a function that returns each of the expressions of the system: def Lorenz(x,y,z,*, s=10, r=28, b=8/3): return -s*x+s*y, -x*z+r*x-y, x*y-b*z","title":"3D Trajectory"},{"location":"dFfunction/#1d-maps","text":"Let's say we want to study the Logistic Map. The dF function will be constructed by creating a function that returns the evolution of one step in the map: def Logistic(x, *, r=1.5): return r*x*(1-x)","title":"1D Maps"},{"location":"generator/","text":"_Generator_ class phaseportrait.generator_base. _Generator_ ( dF, initial_position, xrange, *, dF_args={None}, yrange=[], max_steps=100, n_points=100, **kargs ) This class is used internally in Maps and Trajectories. It is not intended to be used by the user. A class used to generate and save data. Parameters portrait : Class that uses the _Generator_ objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved. Key Arguments dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. Methods to be overwritten _Generator_ . _next _Generator_ . _next () Generates from self.position its following value Returns None _Generator_ . save _Generator_ . save () Saves self.position in a convenient way for the type of representation. Returns None _Generator_ . clear_values _Generator_ . clear_values () Clears the data arrays. Returns None _Generator_ . _check_limit_cycle _Generator_ . _check_limit_cycle (_delta) (Optional) Checks if the trajectory is on a limit cycle. Returns False int, number of saved points Methods _Generator_ .compute_all _Generator_ . compute_all (*, save_freq=1, limit_cycle_check=False, delta=0.01) Computes _Generator_.max_values and saves them. Key Arguments save_freq : int, optional, by default 1 Number of values computed before saving them. limit_cycle_check : int, optional, by default False Number of points before checking for limit cycles. delta : float, optional, by default 0.01 Diference between two values to be considerated equal. Returns Numpy.ndarray Saved data with size: [ _Generator_.dimension , _Generator_.max_values ] _Generator_ ._create_values_array _Generator_ . _create_values_array (*, max_values: int = None) Creates an array for storaging the values. Key Arguments max_values : int, optional, by default None Max size of the arrays. Returns Numpy.ndarray Empty array with size dimension*max_values _Generator_ .Nnext _Generator_ . Nnext (number, *, save_freq=1, limit_cycle_check=False, delta=0.001) Computes next number pairs of position and velocity values and saves them. Parameters number : int Number of pairs of values saved. Key Arguments delta : float, optional Difference between numbers to be considerated equal. Only if limit_cycle_check=True . save_freq : int, optional, by default 1 Number of values computed before saving them. limit_cycle_check : bool, optional, by default False Whenever to look for limit cycles. Returns int, optional Only if limit_cycle_check is True . It returns the number of points calculated. _Generator_ .next _Generator_ . next (*, index=1) Computes the next usable pair of values and saves them. Parameters index : int, optional, by default 1 Where to save the pair of values. Returns None Examples This class is implemented in other classes, such as: Map RungeKutta","title":"Generator base"},{"location":"generator/#_generator_","text":"class phaseportrait.generator_base. _Generator_ ( dF, initial_position, xrange, *, dF_args={None}, yrange=[], max_steps=100, n_points=100, **kargs ) This class is used internally in Maps and Trajectories. It is not intended to be used by the user. A class used to generate and save data.","title":"\u000295\u0003Generator\u000295\u0003"},{"location":"generator/#parameters","text":"portrait : Class that uses the _Generator_ objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved.","title":"Parameters"},{"location":"generator/#key-arguments","text":"dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0.","title":"Key Arguments"},{"location":"generator/#methods-to-be-overwritten","text":"","title":"Methods to be overwritten"},{"location":"generator/#_generator__next","text":"_Generator_ . _next () Generates from self.position its following value Returns None","title":"\u000295\u0003Generator\u000295\u0003.\u000295\u0003next"},{"location":"generator/#_generator_save","text":"_Generator_ . save () Saves self.position in a convenient way for the type of representation. Returns None","title":"\u000295\u0003Generator\u000295\u0003.save"},{"location":"generator/#_generator_clear_values","text":"_Generator_ . clear_values () Clears the data arrays. Returns None","title":"\u000295\u0003Generator\u000295\u0003.clear_values"},{"location":"generator/#_generator__check_limit_cycle","text":"_Generator_ . _check_limit_cycle (_delta) (Optional) Checks if the trajectory is on a limit cycle. Returns False int, number of saved points","title":"\u000295\u0003Generator\u000295\u0003.\u000295\u0003check_limit_cycle"},{"location":"generator/#methods","text":"","title":"Methods"},{"location":"generator/#_generator_compute_all","text":"_Generator_ . compute_all (*, save_freq=1, limit_cycle_check=False, delta=0.01) Computes _Generator_.max_values and saves them. Key Arguments save_freq : int, optional, by default 1 Number of values computed before saving them. limit_cycle_check : int, optional, by default False Number of points before checking for limit cycles. delta : float, optional, by default 0.01 Diference between two values to be considerated equal. Returns Numpy.ndarray Saved data with size: [ _Generator_.dimension , _Generator_.max_values ]","title":"\u000295\u0003Generator\u000295\u0003.compute_all"},{"location":"generator/#_generator__create_values_array","text":"_Generator_ . _create_values_array (*, max_values: int = None) Creates an array for storaging the values. Key Arguments max_values : int, optional, by default None Max size of the arrays. Returns Numpy.ndarray Empty array with size dimension*max_values","title":"\u000295\u0003Generator\u000295\u0003.\u000295\u0003create_values_array"},{"location":"generator/#_generator_nnext","text":"_Generator_ . Nnext (number, *, save_freq=1, limit_cycle_check=False, delta=0.001) Computes next number pairs of position and velocity values and saves them. Parameters number : int Number of pairs of values saved. Key Arguments delta : float, optional Difference between numbers to be considerated equal. Only if limit_cycle_check=True . save_freq : int, optional, by default 1 Number of values computed before saving them. limit_cycle_check : bool, optional, by default False Whenever to look for limit cycles. Returns int, optional Only if limit_cycle_check is True . It returns the number of points calculated.","title":"\u000295\u0003Generator\u000295\u0003.Nnext"},{"location":"generator/#_generator_next","text":"_Generator_ . next (*, index=1) Computes the next usable pair of values and saves them. Parameters index : int, optional, by default 1 Where to save the pair of values. Returns None","title":"\u000295\u0003Generator\u000295\u0003.next"},{"location":"generator/#examples","text":"This class is implemented in other classes, such as: Map RungeKutta","title":"Examples"},{"location":"installation/","text":"Installation Installing via pip: Phaseportrait releases are available as wheel packages for macOS, Windows and Linux on PyPI. Install it using pip: pip install phaseportrait Installing from source: Open a terminal on desired route and type the following: git clone https://github.com/phaseportrait/phaseportrait Manual installation Visit phase-portrait webpage on GitHub. Click on green button saying Code , and download it in zip format. Save and unzip on desired directory.","title":"Installation"},{"location":"installation/#installation","text":"Installing via pip: Phaseportrait releases are available as wheel packages for macOS, Windows and Linux on PyPI. Install it using pip: pip install phaseportrait Installing from source: Open a terminal on desired route and type the following: git clone https://github.com/phaseportrait/phaseportrait Manual installation Visit phase-portrait webpage on GitHub. Click on green button saying Code , and download it in zip format. Save and unzip on desired directory.","title":"Installation"},{"location":"license/","text":"MIT License Copyright (c) 2021 V\u00edctor Loras & Unai Ler\u00eda Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#mit-license","text":"Copyright (c) 2021 V\u00edctor Loras & Unai Ler\u00eda Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"map/","text":"Map class phaseportrait.maps. Map ( portrait, dF, dimension, max_values, *, dt=0.1, dF_args=None, initial_values=None, thermalization=0 ) This class is used internally in Map1D. It is not intended to be used by the user. This class is an implementation of _Generator_ for maps generators. Parameters portrait : Class that uses the Map objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved. Key Arguments dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. Overwritten methods map . _next map . _next () Generates from self.position its following value. Explicitly: def _next(self): self.position[0] = self.dF(*(self.position), **self.dF_args) Returns None map . save map . save (i) Saves self.position in the attribute self.positions . Parameters i : int Index in which the data is saved. Explicitly: def save(self, i): try: self.positions[:, i] = self.position except IndexError: np.concatenate(self.positions, self._create_values_array(), axis=1) self.max_values *= 2 self.save(i) Returns None map . clear_values map . clear_values () Clears the data arrays self.positions . Returns None map ._check_limit_cycle map . _check_limit_cycle () Parameters delta : float Difference between data values to be considerated equal. Returns bool Whenever data reached a limit cylce. Methods map .instance_and_compute_all map . instance_and_compute_all (portrait, dF, dimension, dF_args, initial_values, max_values, save_freq=1, dt=0.1, thermalization=0) Creates an instance of phase-portrait.trajectories.Map. Computes all the data requested and returns the instance. Parameters portrait : Class that uses the Map objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved. dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat save_freq : int, optional, by default 1 Number of values computed before saving them. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. limit_cycle_check : int, bool, optional, by default False Whenever to check it there os a limit cycle in the data. delta : float, optional, by default 0.01 If limit_cycle_check==True is the distance between data elements to be considerated equal. Returns phase-portrait.trajectories.Map Examples This class is implemented in other classes, check out: Map1D","title":"Map"},{"location":"map/#map","text":"class phaseportrait.maps. Map ( portrait, dF, dimension, max_values, *, dt=0.1, dF_args=None, initial_values=None, thermalization=0 ) This class is used internally in Map1D. It is not intended to be used by the user. This class is an implementation of _Generator_ for maps generators.","title":"Map"},{"location":"map/#parameters","text":"portrait : Class that uses the Map objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved.","title":"Parameters"},{"location":"map/#key-arguments","text":"dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0.","title":"Key Arguments"},{"location":"map/#overwritten-methods","text":"","title":"Overwritten methods"},{"location":"map/#map_next","text":"map . _next () Generates from self.position its following value. Explicitly: def _next(self): self.position[0] = self.dF(*(self.position), **self.dF_args) Returns None","title":"map.\u000295\u0003next"},{"location":"map/#mapsave","text":"map . save (i) Saves self.position in the attribute self.positions . Parameters i : int Index in which the data is saved. Explicitly: def save(self, i): try: self.positions[:, i] = self.position except IndexError: np.concatenate(self.positions, self._create_values_array(), axis=1) self.max_values *= 2 self.save(i) Returns None","title":"map.save"},{"location":"map/#mapclear_values","text":"map . clear_values () Clears the data arrays self.positions . Returns None","title":"map.clear_values"},{"location":"map/#map_check_limit_cycle","text":"map . _check_limit_cycle () Parameters delta : float Difference between data values to be considerated equal. Returns bool Whenever data reached a limit cylce.","title":"map._check_limit_cycle"},{"location":"map/#methods","text":"","title":"Methods"},{"location":"map/#mapinstance_and_compute_all","text":"map . instance_and_compute_all (portrait, dF, dimension, dF_args, initial_values, max_values, save_freq=1, dt=0.1, thermalization=0) Creates an instance of phase-portrait.trajectories.Map. Computes all the data requested and returns the instance. Parameters portrait : Class that uses the Map objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved. dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat save_freq : int, optional, by default 1 Number of values computed before saving them. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. limit_cycle_check : int, bool, optional, by default False Whenever to check it there os a limit cycle in the data. delta : float, optional, by default 0.01 If limit_cycle_check==True is the distance between data elements to be considerated equal. Returns phase-portrait.trajectories.Map","title":"map.instance_and_compute_all"},{"location":"map/#examples","text":"This class is implemented in other classes, check out: Map1D","title":"Examples"},{"location":"map1d/","text":"Map1D class phaseportrait. Map1D ( dF, x_range, y_range, n_points, *, composition_grade=1, dF_args={}, Title='1D Map', xlabel=r'Control parameter', ylabel=r'$X_{n+1}$', **kargs ) Class dedicated to 1 dimensional maps x(t+1) = f(x) . Parameters dF : callable A dF type function. Range : [x_range, y_range] Ranges of the axis in the main plot. n_points : int Maximum number of points. Not recomended more than 5000. Key Arguments dF_args : dict If necesary, must contain the kargs for the dF function. composition_grade : int Number of times dF is applied between positions saved. Title : str Title of the plot. xlabel : str x label of the plot. ylabel : str y label of the plot. color : str Matplotlib Cmap . size : float Size of the scattered points. thermalization : int Thermalization steps before points saved. Methods Map1D .plot_over_variable Map1D . plot_over_variable (param_name, valinterval, valstep, *, initial_x=None, limit_cycle_check_first=50, delta_cycle_check=0.0001) Creates every map instance. Parameters param_name : str Name of the variable. Must be in the dF kargs. valinterval : list Min and max value for the param range. valstep : float Separation between consecutive values in the param range. Key Arguments initial_x : float Initial x position of every data series. limit_cycle_check_first : int Number of points saved before checking for repeated elemets. delta_cycle_check : float Diference between two positions to be considerated identical. Returns None Map1D .update_dF_args Map1D . update_dF_args () Updates the internal dF_args attributes to match the sliders. Map1D .plot Map1D . plot (*, color=None) Prepares the plots and computes the values. Key Arguments color : str Matplotlib Cmap . Returns tuple(matplotlib Figure, matplotlib Axis) Map1D .add_slider Map1D . add_slider (param_name, *, valinit=None, valstep=0.1, valinterval=10) Adds a Slider for the dF function. Parameters param_name : str Name of the variable. Must be in the dF kargs of the Map1D.dF function. Key Arguments valinit : float, defautl=None Initial position of the Slider valinterval : Union[float,list], default=10 Min and max value for the param range. valstep : float, default=0.1 Separation between consecutive values in the param range. Map1D .plot_trajectory Map1D . plot_trajectory (n_points, *, dF_args=None, initial_x=None, color='b', save_freq=1, thermalization=0) Creates a map instance and computes it's positions. Parameters n_points : int Number of points to be calculated. Key Arguments dF_args : dict If necesary, must contain the kargs for the dF function. By default takes the dF_args of the Map1D instance. initial_x : float Initial position of the trajectory. color : str String matplotlib color identifier. save_freq : int Number of times dF is aplied before a position is saved. thermalization : int Thermalization steps before points saved. Returns tuple: (matplotlib.pyplot.figure, matplotlib.pyplot.Axis) Examples Logistic map Let's represent the Logistic map over the control parameter r , in the range [2, 3.9] , with an interval of 0.005 . def Logistic(x, *, r=1.5): return r*x*(1-x) Logistic_Map = Map1D(Logistic, [2,3.9], [0,1], 2000, thermalization=200, size=0.1) # We add a limit cycle check because until r=3.5 there is not need of storing 2000 equal points for every r. Logistic_Map.plot_over_variable('r', [2,3.9], 0.005, limit_cycle_check_first=300, delta_cycle_check=0.01 ) fig, ax = Logistic_Map.plot() See more Map1D examples.","title":"1D Maps"},{"location":"map1d/#map1d","text":"class phaseportrait. Map1D ( dF, x_range, y_range, n_points, *, composition_grade=1, dF_args={}, Title='1D Map', xlabel=r'Control parameter', ylabel=r'$X_{n+1}$', **kargs ) Class dedicated to 1 dimensional maps x(t+1) = f(x) .","title":"Map1D"},{"location":"map1d/#parameters","text":"dF : callable A dF type function. Range : [x_range, y_range] Ranges of the axis in the main plot. n_points : int Maximum number of points. Not recomended more than 5000.","title":"Parameters"},{"location":"map1d/#key-arguments","text":"dF_args : dict If necesary, must contain the kargs for the dF function. composition_grade : int Number of times dF is applied between positions saved. Title : str Title of the plot. xlabel : str x label of the plot. ylabel : str y label of the plot. color : str Matplotlib Cmap . size : float Size of the scattered points. thermalization : int Thermalization steps before points saved.","title":"Key Arguments"},{"location":"map1d/#methods","text":"","title":"Methods"},{"location":"map1d/#map1dplot_over_variable","text":"Map1D . plot_over_variable (param_name, valinterval, valstep, *, initial_x=None, limit_cycle_check_first=50, delta_cycle_check=0.0001) Creates every map instance. Parameters param_name : str Name of the variable. Must be in the dF kargs. valinterval : list Min and max value for the param range. valstep : float Separation between consecutive values in the param range. Key Arguments initial_x : float Initial x position of every data series. limit_cycle_check_first : int Number of points saved before checking for repeated elemets. delta_cycle_check : float Diference between two positions to be considerated identical. Returns None","title":"Map1D.plot_over_variable"},{"location":"map1d/#map1dupdate_df_args","text":"Map1D . update_dF_args () Updates the internal dF_args attributes to match the sliders.","title":"Map1D.update_dF_args"},{"location":"map1d/#map1dplot","text":"Map1D . plot (*, color=None) Prepares the plots and computes the values. Key Arguments color : str Matplotlib Cmap . Returns tuple(matplotlib Figure, matplotlib Axis)","title":"Map1D.plot"},{"location":"map1d/#map1dadd_slider","text":"Map1D . add_slider (param_name, *, valinit=None, valstep=0.1, valinterval=10) Adds a Slider for the dF function. Parameters param_name : str Name of the variable. Must be in the dF kargs of the Map1D.dF function. Key Arguments valinit : float, defautl=None Initial position of the Slider valinterval : Union[float,list], default=10 Min and max value for the param range. valstep : float, default=0.1 Separation between consecutive values in the param range.","title":"Map1D.add_slider"},{"location":"map1d/#map1dplot_trajectory","text":"Map1D . plot_trajectory (n_points, *, dF_args=None, initial_x=None, color='b', save_freq=1, thermalization=0) Creates a map instance and computes it's positions. Parameters n_points : int Number of points to be calculated. Key Arguments dF_args : dict If necesary, must contain the kargs for the dF function. By default takes the dF_args of the Map1D instance. initial_x : float Initial position of the trajectory. color : str String matplotlib color identifier. save_freq : int Number of times dF is aplied before a position is saved. thermalization : int Thermalization steps before points saved. Returns tuple: (matplotlib.pyplot.figure, matplotlib.pyplot.Axis)","title":"Map1D.plot_trajectory"},{"location":"map1d/#examples","text":"","title":"Examples"},{"location":"map1d/#logistic-map","text":"Let's represent the Logistic map over the control parameter r , in the range [2, 3.9] , with an interval of 0.005 . def Logistic(x, *, r=1.5): return r*x*(1-x) Logistic_Map = Map1D(Logistic, [2,3.9], [0,1], 2000, thermalization=200, size=0.1) # We add a limit cycle check because until r=3.5 there is not need of storing 2000 equal points for every r. Logistic_Map.plot_over_variable('r', [2,3.9], 0.005, limit_cycle_check_first=300, delta_cycle_check=0.01 ) fig, ax = Logistic_Map.plot() See more Map1D examples.","title":"Logistic map"},{"location":"mapsandcobweb_examples/","text":"Cobweb plots Logistic map Let's say we want to investigate the qualitative behavior of the logistic map using a cobweb plot to infer the long term status of an initial condition under repeated application of the map. Cobweb class takes 3 arguments: dF : In our case, the logistic map. initial_position : initial condition to study. xrange : range of representation in the x axis. An interesting optional argument is max_steps , which indicates the number of iterations of the map. Its default value is 100 , which is more than enough, but you can change it if you want. We can also restrict the yrange by using yrange kwarg, as we know the output will be in the range [0,1]. If not included, the yrange is 1.10 times the maximum and minimum, ergo, [1.10 \u00d7 min, 1.10 \u00d7 max]. Plot method also yields a time series plot, which shows explicitly the values taken, and it returns the two figures and axes (first cobweb plot, then time series). We get two birds with one stone. Let's see what output we get: from phaseportrait import Cobweb def Logistic(x, *, r=3.2): return r*x*(1-x) LogisticCobweb = Cobweb(Logistic, 0.1, [0,1], yrange=[0,1]) fig1, ax1, fig2, ax2 = LogisticCobweb.plot() We can use returned objects to change plot's properties, such as title, xlabel, ylabel... We can also pass Title , xlabel and ylabel as key arguments when creating the Cobweb object instance for changing the cobweb plot's labels, but not the time series plot. Adding sliders The point of cobweb plots and time series is to study the behaviour of the map for several values of a parameter and initial conditions. Let's see two methods that will let us change this values in a simple way. Parameter slider : Let's say we want to study the logistic map as r control parameter value changes with a cobweb plot. We can use the add_slider method for this purpose. It only takes 1 argument: the parameter's name, in this case r . We can also pass valinit and valinterval kargs for changing the initial value and the interval of variation. Initial position slider : Following the same philosophy as the parameter slider, initial_position_slider takes no necessary arguments. Nevertheless, it has 3 optional arguments: valinit : initial position in the slider. Default value is the same as initial position given when initializing Cobweb object. valinterval : the range of values the slider of the parameter will cover. valstep : precision or step in the slider. Let's put all in practice with the following example: from phaseportrait import Cobweb def Logistic(x, *, r=1.5): return r*x*(1-x) LogisticCobweb = Cobweb(Logistic, 0.2, [0,1], yrange=[0,1], Title='Logistic map cobweb plot') LogisticCobweb.add_slider('r', valinit=1.5, valinterval=[0,4]) LogisticCobweb.initial_position_slider(valstep=0.01) fig1, ax1, fig2, ax2 = LogisticCobweb.plot() ax2.set_title('Logistic map time series') Map1D plots Complete documentation of Map1D class: here . First steps We are going to plot the Logistic map: Just like Cobweb plots, the first argument is a dF function ( dF function documentation ). The next required parameters are: * x_range : in this example [2,3.9] . * y_range : in this example [0,1] . * n_points : in this example 2000 . We want the plot over the control parameter in the range x_range=[2,3.9] with data every 0.005 : def Logistic(x, *, r=1.5): return r*x*(1-x) Log1 = Map1D(Logistic, [2,3.9], [0,1], 2000, Title='Logistic Map', xlabel='Control parameter: \"r\"', ylabel=r'$x_{n+1}$', size=1.0) Log1.plot_over_variable('r', [2,3.9], 0.005) fig, ax = Log1.plot() As you can see, this is a mess. That happended because the first steps are not in a stable cycle, and must be deleted. Thermalization Same example, but with 50 steps of thermalization: Log2 = Map1D(Logistic, [2,3.9], [0,1], 2000, thermalization=50, Title='Logistic Map', xlabel='Control parameter: \"r\"', ylabel=r'$x_{n+1}$', color='viridis') Log2.plot_over_variable('r', [2,3.9], 0.005) fig, ax = Log2.plot() Note: in some cases the graph is very dependant of the initial position. In the method plot_over_variable there is a karg for specifying the initial position: plot_over_variable(initial_x=... ) . Sliders Just like the Cobweb plots you can add sliders so modify in run time some parameters. For instance: def Logistic_power(x, *, r=1.5, p=1): return r*x*(1-x)*(x-p)*(x-p) Log3 = Map1D(Logistic_power, [2,3.9], [0,1], 2000, thermalization=50) Log3.add_slider('p', valinit=1.35, valinterval=[1.3,1.4], valstep=0.005) Log3.plot_over_variable('r', [2,3.9], 0.005) fig, ax = Log3.plot() Time series Additionally, you can also plot a specific trajectory. Although we recommend using Cobweb plots for that: Log4 = Map1D(Logistic_power, [2,3.9], [0,1], 2000, thermalization=50) Log4.plot_trajectory(100, dF_args={'r':3.40, 'p':1.35}, initial_x=0.5) fig, ax = Log4.plot() Some more examples If you want to take a look to some more plots, we recommend you taking a look to the following file .","title":"1D maps and cobweb plots"},{"location":"mapsandcobweb_examples/#cobweb-plots","text":"","title":"Cobweb plots"},{"location":"mapsandcobweb_examples/#logistic-map","text":"Let's say we want to investigate the qualitative behavior of the logistic map using a cobweb plot to infer the long term status of an initial condition under repeated application of the map. Cobweb class takes 3 arguments: dF : In our case, the logistic map. initial_position : initial condition to study. xrange : range of representation in the x axis. An interesting optional argument is max_steps , which indicates the number of iterations of the map. Its default value is 100 , which is more than enough, but you can change it if you want. We can also restrict the yrange by using yrange kwarg, as we know the output will be in the range [0,1]. If not included, the yrange is 1.10 times the maximum and minimum, ergo, [1.10 \u00d7 min, 1.10 \u00d7 max]. Plot method also yields a time series plot, which shows explicitly the values taken, and it returns the two figures and axes (first cobweb plot, then time series). We get two birds with one stone. Let's see what output we get: from phaseportrait import Cobweb def Logistic(x, *, r=3.2): return r*x*(1-x) LogisticCobweb = Cobweb(Logistic, 0.1, [0,1], yrange=[0,1]) fig1, ax1, fig2, ax2 = LogisticCobweb.plot() We can use returned objects to change plot's properties, such as title, xlabel, ylabel... We can also pass Title , xlabel and ylabel as key arguments when creating the Cobweb object instance for changing the cobweb plot's labels, but not the time series plot.","title":"Logistic map"},{"location":"mapsandcobweb_examples/#adding-sliders","text":"The point of cobweb plots and time series is to study the behaviour of the map for several values of a parameter and initial conditions. Let's see two methods that will let us change this values in a simple way. Parameter slider : Let's say we want to study the logistic map as r control parameter value changes with a cobweb plot. We can use the add_slider method for this purpose. It only takes 1 argument: the parameter's name, in this case r . We can also pass valinit and valinterval kargs for changing the initial value and the interval of variation. Initial position slider : Following the same philosophy as the parameter slider, initial_position_slider takes no necessary arguments. Nevertheless, it has 3 optional arguments: valinit : initial position in the slider. Default value is the same as initial position given when initializing Cobweb object. valinterval : the range of values the slider of the parameter will cover. valstep : precision or step in the slider. Let's put all in practice with the following example: from phaseportrait import Cobweb def Logistic(x, *, r=1.5): return r*x*(1-x) LogisticCobweb = Cobweb(Logistic, 0.2, [0,1], yrange=[0,1], Title='Logistic map cobweb plot') LogisticCobweb.add_slider('r', valinit=1.5, valinterval=[0,4]) LogisticCobweb.initial_position_slider(valstep=0.01) fig1, ax1, fig2, ax2 = LogisticCobweb.plot() ax2.set_title('Logistic map time series')","title":"Adding sliders"},{"location":"mapsandcobweb_examples/#map1d-plots","text":"Complete documentation of Map1D class: here .","title":"Map1D plots"},{"location":"mapsandcobweb_examples/#first-steps","text":"We are going to plot the Logistic map: Just like Cobweb plots, the first argument is a dF function ( dF function documentation ). The next required parameters are: * x_range : in this example [2,3.9] . * y_range : in this example [0,1] . * n_points : in this example 2000 . We want the plot over the control parameter in the range x_range=[2,3.9] with data every 0.005 : def Logistic(x, *, r=1.5): return r*x*(1-x) Log1 = Map1D(Logistic, [2,3.9], [0,1], 2000, Title='Logistic Map', xlabel='Control parameter: \"r\"', ylabel=r'$x_{n+1}$', size=1.0) Log1.plot_over_variable('r', [2,3.9], 0.005) fig, ax = Log1.plot() As you can see, this is a mess. That happended because the first steps are not in a stable cycle, and must be deleted.","title":"First steps"},{"location":"mapsandcobweb_examples/#thermalization","text":"Same example, but with 50 steps of thermalization: Log2 = Map1D(Logistic, [2,3.9], [0,1], 2000, thermalization=50, Title='Logistic Map', xlabel='Control parameter: \"r\"', ylabel=r'$x_{n+1}$', color='viridis') Log2.plot_over_variable('r', [2,3.9], 0.005) fig, ax = Log2.plot() Note: in some cases the graph is very dependant of the initial position. In the method plot_over_variable there is a karg for specifying the initial position: plot_over_variable(initial_x=... ) .","title":"Thermalization"},{"location":"mapsandcobweb_examples/#sliders","text":"Just like the Cobweb plots you can add sliders so modify in run time some parameters. For instance: def Logistic_power(x, *, r=1.5, p=1): return r*x*(1-x)*(x-p)*(x-p) Log3 = Map1D(Logistic_power, [2,3.9], [0,1], 2000, thermalization=50) Log3.add_slider('p', valinit=1.35, valinterval=[1.3,1.4], valstep=0.005) Log3.plot_over_variable('r', [2,3.9], 0.005) fig, ax = Log3.plot()","title":"Sliders"},{"location":"mapsandcobweb_examples/#time-series","text":"Additionally, you can also plot a specific trajectory. Although we recommend using Cobweb plots for that: Log4 = Map1D(Logistic_power, [2,3.9], [0,1], 2000, thermalization=50) Log4.plot_trajectory(100, dF_args={'r':3.40, 'p':1.35}, initial_x=0.5) fig, ax = Log4.plot()","title":"Time series"},{"location":"mapsandcobweb_examples/#some-more-examples","text":"If you want to take a look to some more plots, we recommend you taking a look to the following file .","title":"Some more examples"},{"location":"nullclines/","text":"Nullcline2D class phaseportrait. Nullcline2D ( portrait, function, *, precision=0.01, xprecision=None, yprecision=None, offset=0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='b', bgcolor='w', alpha=0 ) Class dedicated to 2 dimensions phase portraits. Useful where it is necessary to plot nullclines in a plot. Integrated via method add_nullclines in PhasePortrait2D . Parameters portrait : The class that uses Nullcline2D function : callable A dF type funcion. precision : float, optional The minimum diference from offset to be considerated a nullcline, by default 0.01 xprecision : float, optional For a different precision value only in the x axis, by default precision yprecision : float, optional For a different precision value only in the y axis, by default precision offset : float, optional If you want, for instance, a twoclide, by default 0 density : int, optional Number of inner divisions on the x axis and y axis, by default 50 xRange : Union[float,list], optional The range in which the nullclines are calculated, by default portrait.Range[0] yRange : Union[float,list], optional The range in which the nullclines are calculated, by default portrait.Range[1] dF_args : dict, optional If necesary, must contain the kargs for the dF funcion, by default None xcolor : str, optional X nullcline color, by default 'r' ycolor : str, optional Y nullcline color, by default 'b' bgcolor : str, optional Background color, by default 'w' alpha : int, optional Opacity of the background, by default 0 Methods Nullcline2D .plot Nullcline2D . plot (*, axis=None) Plots the nullclines in the given axis Parameters axis : matplotlib.Axis, optional The axis in which the nullclines will be represented, by default portrait.ax Returns [matplotlib.contour.QuadContourSet,matplotlib.contour.QuadContourSet] X and Y contours. Examples from phaseportrait import PhasePortrait2D def dF(x,y): return x + np.exp(-y), -y example = PhasePortrait2D(dF, [[-10,10], [-5, 5]]) example.add_nullclines(precision=0.05) example.plot()","title":"Nullclines"},{"location":"nullclines/#nullcline2d","text":"class phaseportrait. Nullcline2D ( portrait, function, *, precision=0.01, xprecision=None, yprecision=None, offset=0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='b', bgcolor='w', alpha=0 ) Class dedicated to 2 dimensions phase portraits. Useful where it is necessary to plot nullclines in a plot. Integrated via method add_nullclines in PhasePortrait2D .","title":"Nullcline2D"},{"location":"nullclines/#parameters","text":"portrait : The class that uses Nullcline2D function : callable A dF type funcion. precision : float, optional The minimum diference from offset to be considerated a nullcline, by default 0.01 xprecision : float, optional For a different precision value only in the x axis, by default precision yprecision : float, optional For a different precision value only in the y axis, by default precision offset : float, optional If you want, for instance, a twoclide, by default 0 density : int, optional Number of inner divisions on the x axis and y axis, by default 50 xRange : Union[float,list], optional The range in which the nullclines are calculated, by default portrait.Range[0] yRange : Union[float,list], optional The range in which the nullclines are calculated, by default portrait.Range[1] dF_args : dict, optional If necesary, must contain the kargs for the dF funcion, by default None xcolor : str, optional X nullcline color, by default 'r' ycolor : str, optional Y nullcline color, by default 'b' bgcolor : str, optional Background color, by default 'w' alpha : int, optional Opacity of the background, by default 0","title":"Parameters"},{"location":"nullclines/#methods","text":"","title":"Methods"},{"location":"nullclines/#nullcline2dplot","text":"Nullcline2D . plot (*, axis=None) Plots the nullclines in the given axis Parameters axis : matplotlib.Axis, optional The axis in which the nullclines will be represented, by default portrait.ax Returns [matplotlib.contour.QuadContourSet,matplotlib.contour.QuadContourSet] X and Y contours.","title":"Nullcline2D.plot"},{"location":"nullclines/#examples","text":"from phaseportrait import PhasePortrait2D def dF(x,y): return x + np.exp(-y), -y example = PhasePortrait2D(dF, [[-10,10], [-5, 5]]) example.add_nullclines(precision=0.05) example.plot()","title":"Examples"},{"location":"phaseportrait2d/","text":"PhasePortrait2D class phaseportrait. PhasePortrait2D ( dF, Range, *, MeshDim=10, dF_args={}, Density=1, Polar=False, **kargs ) Gives the option to represent a 2D phase portrait given a dF function with 2 args. Parameters dF : callable A dF type funcion. Computes the derivatives of given coordinates. Range : [x_range, y_range] Ranges of the axis in the main plot. See Defining Range . Key Arguments MeshDim : int, default=500 Number of elements in the arrows grid. dF_args : dict If necesary, must contain the kargs for the dF function. Density : float, default=1 Number of elements in the arrows grid plot. Polar : bool, default=False Whether to use polar coordinates or not. Title : str, default='Phase Portrait' Title of the plot. xlabel : str, default='X' x label of the plot. ylabel : str, default='$\\dot{X}$' y label of the plot. color : str, default='rainbow' Matplotlib Cmap . Methods PhasePortrait2D .plot PhasePortrait2D . plot ( *, color=None ) Prepares the plots and computes the values.. Color scheme can be changed introducing key argument color . A list with accepted values can be found here . Returns tuple(matplotlib Figure, matplotlib Axis) PhasePortrait2D .add_slider PhasePortrait2D . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time. Parameters param_name : str The string key of the variable. Must be the same as the key in the dF function. Key Arguments valinit : float, default=None Initial value of the parameter. valinterval : Union[float, list], default=0.1 The range of values the slider of the parameter will cover. valstep : float, default=10 Precision in the slider. Returns None PhasePortrait2D .add_nullclines PhasePortrait2D . add_nullclines ( *, precision=0.01, offset=0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='g', bgcolor='w', alpha=0 ) Plots nullclines of the system given by dF function. For more info, see Nullclines class. Returns None Defining Range A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]] Examples from phaseportrait import PhasePortrait2D def dF(r, \u03b8, *, \u03bc=0.5,\u03b7=0): return \u03bc*r*(1 - r*r), 1+\u03b7*\u03b8 example = PhasePortrait2D(dF, [-3, 3], Density=2, Polar=True, Title='Limit cycle') example.add_slider('\u03bc', valinit=0.5) example.add_slider('\u03b7', valinit=0.0) example.add_nullclines() example.plot() Click here to see more examples.","title":"PhasePortrait2d"},{"location":"phaseportrait2d/#phaseportrait2d","text":"class phaseportrait. PhasePortrait2D ( dF, Range, *, MeshDim=10, dF_args={}, Density=1, Polar=False, **kargs ) Gives the option to represent a 2D phase portrait given a dF function with 2 args.","title":"PhasePortrait2D"},{"location":"phaseportrait2d/#parameters","text":"dF : callable A dF type funcion. Computes the derivatives of given coordinates. Range : [x_range, y_range] Ranges of the axis in the main plot. See Defining Range .","title":"Parameters"},{"location":"phaseportrait2d/#key-arguments","text":"MeshDim : int, default=500 Number of elements in the arrows grid. dF_args : dict If necesary, must contain the kargs for the dF function. Density : float, default=1 Number of elements in the arrows grid plot. Polar : bool, default=False Whether to use polar coordinates or not. Title : str, default='Phase Portrait' Title of the plot. xlabel : str, default='X' x label of the plot. ylabel : str, default='$\\dot{X}$' y label of the plot. color : str, default='rainbow' Matplotlib Cmap .","title":"Key Arguments"},{"location":"phaseportrait2d/#methods","text":"","title":"Methods"},{"location":"phaseportrait2d/#phaseportrait2dplot","text":"PhasePortrait2D . plot ( *, color=None ) Prepares the plots and computes the values.. Color scheme can be changed introducing key argument color . A list with accepted values can be found here . Returns tuple(matplotlib Figure, matplotlib Axis)","title":"PhasePortrait2D.plot"},{"location":"phaseportrait2d/#phaseportrait2dadd_slider","text":"PhasePortrait2D . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time. Parameters param_name : str The string key of the variable. Must be the same as the key in the dF function. Key Arguments valinit : float, default=None Initial value of the parameter. valinterval : Union[float, list], default=0.1 The range of values the slider of the parameter will cover. valstep : float, default=10 Precision in the slider. Returns None","title":"PhasePortrait2D.add_slider"},{"location":"phaseportrait2d/#phaseportrait2dadd_nullclines","text":"PhasePortrait2D . add_nullclines ( *, precision=0.01, offset=0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='g', bgcolor='w', alpha=0 ) Plots nullclines of the system given by dF function. For more info, see Nullclines class. Returns None","title":"PhasePortrait2D.add_nullclines"},{"location":"phaseportrait2d/#defining-range","text":"A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]]","title":"Defining Range"},{"location":"phaseportrait2d/#examples","text":"from phaseportrait import PhasePortrait2D def dF(r, \u03b8, *, \u03bc=0.5,\u03b7=0): return \u03bc*r*(1 - r*r), 1+\u03b7*\u03b8 example = PhasePortrait2D(dF, [-3, 3], Density=2, Polar=True, Title='Limit cycle') example.add_slider('\u03bc', valinit=0.5) example.add_slider('\u03b7', valinit=0.0) example.add_nullclines() example.plot() Click here to see more examples.","title":"Examples"},{"location":"phaseportrait2d_examples/","text":"First steps In this examples, we will be using PhasePortrait2D class. So, we'll have to import it from phaseportrait module: from phaseportrait import PhasePortrait2D Let's take a look to the class. PhasePortrait2D takes 2 args: dF function : a function that, in this case, returns a tuple, corresponding of the evolution of the 2 coordinates. Range, which can be given as: A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]] So, to create an instance of a PhasePortrait2D object, we will have to create a dF function and select a range. For having a simple starting point, let's crate a simple dF function and see the result: def dF_1(x, y): return x, 0 example1 = PhasePortrait2D(dF_1, [-3, 3]) fig, ax = example1.plot() Color shows the speed of the trajectory, as we can see, far away points from (0,0) have a greater velocity. Purple shifted colors show less velocity than red shifted colors in the default color scheme. Color scheme can be changed introducing kwarg color when creating the class instance. A list with accepted values can be found here . Later, we'll do a pair of examples changing the color scheme. Let's explore all options given by PhasePortrait2D class by doing some more examples. Title and labels Title and labels of the plot can be changed by calling the corresponding key arguments. For instance, using the dF function created in the first example: example2 = PhasePortrait2D(dF_1, [-3, 3], Title='This is a title', xlabel='This is not a title', ylabel='Neither is this') fig, ax = example2.plot() There is also, another way of doing it, using the ax class methods: example2 = PhasePortrait2D(dF_1, [-3, 3]) fig, ax = example2.plot() ax.set_title('This is a title') ax.set_xlabel('This is not a title') ax.set_ylabel('Neither is this') That will yield to the same result. If not specified, default values are: Title : 'Phase Portrait' xlabel : 'X' ylabel : r'$\\dot{X}$' LaTeX in Title and labels Using r strings , LaTeX-like syntax can be used for writing titles and axis labels. example2 = PhasePortrait2D(dF_1, [-3, 3], Title=r'You can use some $\\left[ LaTeX \\right]$ language', xlabel=r'$\\Delta t$', ylabel=r'$\\~{duck}$') fig, ax = example2.plot() Polar and color Let's say we want to study the phase portrait of a system which is given in polar coordinates. Polar argument is used in this cases. def dF_polar(x, y): return 0, 1 example2 = PhasePortrait2D(dF_polar, [-3, 3], Title='Polar plot', xlabel='This is meaningless', ylabel='Why are we here?', Polar=True, color='inferno') fig, ax = example2.plot() Density In order to increase the number of the arrows we modify the Density (by default 1). Be careful, increasing this value speeds down the execution a lot . For this example we will set the density a bit lower and a bit higher than the default value. def circle(x, y): return -y, x low_D = PhasePortrait2D(circle, [-3,3], Density=0.5, Title='Density=0.5', xlabel='give you up', ylabel='Never gonna', color='cool') fig, ax = low_D.plot() big_D = PhasePortrait2D(circle, [-3,3], Density=2, Title='Density=2', xlabel='let you down', ylabel='Never gonna', color='viridis') fig, ax = big_D.plot() MeshDim In order to create the phase portrait, we create an LxL mesh in which the arrows trajectories are computed. MeshDim inidicates the size of the mesh. Be careful, increasing this value speeds down the execution . It's very important to have a reasonable value for it, as having it too low will give an incorrect representation and giving a high value will be inefficient and expensive computationally. In the following GIF, we've set an example of the evolution of a portrait changing MeshDim's value. It can be seen that passed MeshDim = 15, the changes are insignificant to have a global understanding of the behaviour of the system. dF_args As said in dF function documentation kargs can be give. Those kargs can be specify via the dF_args , such as follows: In this example the dF function sets \u03bc=0 and \u03b7=0.1 , although we want \u03bc=1 and \u03b7=0.1 : def dF_limit_cycle(r, \u03b8, *, \u03bc=0, \u03b7=0): return \u03bc*r*(1 - r*r), 1+\u03b7*\u03b8 not_a_circle = PhasePortrait2D(dF_limit_cycle, [-3, 3], dF_args={'\u03bc':1.0, '\u03b7':0.1}, Polar=True, Title='Never gonna run around', xlabel='X', ylabel='Y') fig, ax = not_a_circle.plot() dF_args must be a dictionary. This is useful if specific values of the kargs are known, in general, they are not. In those cases we recomend using Sliders. Sliders This method allows the user to modify the dF_args in the plot, so it is easier to visualize interesting behaviours. To use them the user must declare the specific name of the karg. Initial value, range of values and step between selectionable consecutive values are optional. For instance, we will slide over the variable \u03bc , with initial value \u03bc=0, in the range \u03bc\u2208[0,1] and distance between consecutive values 0.2 . slippery_cycle = PhasePortrait2D(dF_limit_cycle, [-3, 3], Polar=True, Title='And slide you', xlabel='X', ylabel='Y') slippery_cycle.add_slider('\u03bc', valinit=0, valinterval=[0,1], valstep=0.2) fig, ax = slippery_cycle.plot() Nullclines This method allows the user to plot in the same figure the \"lines\" where the velocity is some specific value (by default 0), in either X or Y axis. For example, we will mark with black where Vx=0 and green Vy=0. def dF_limit_cycle(r, \u03b8, *, \u03bc=0.5,\u03b7=0): return \u03bc*r*(1 - r*r), 1+\u03b7*\u03b8 slippery_cycle = PhasePortrait2D(dF_limit_cycle, [-3, 3], Polar=True, Title='You know the nulls and so do I') slippery_cycle.add_slider('\u03bc', valinit=0, valinterval=[-1,1], valstep=0.05) slippery_cycle.add_nullclines(xcolor='black', ycolor='green') slippery_cycle.plot(color='cool') For more information about nullclines see documentation . More examples A Jupyter Notebook with more examples, with physical or mathematical background can be found here .","title":"2D phase portraits"},{"location":"phaseportrait2d_examples/#first-steps","text":"In this examples, we will be using PhasePortrait2D class. So, we'll have to import it from phaseportrait module: from phaseportrait import PhasePortrait2D Let's take a look to the class. PhasePortrait2D takes 2 args: dF function : a function that, in this case, returns a tuple, corresponding of the evolution of the 2 coordinates. Range, which can be given as: A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]] So, to create an instance of a PhasePortrait2D object, we will have to create a dF function and select a range. For having a simple starting point, let's crate a simple dF function and see the result: def dF_1(x, y): return x, 0 example1 = PhasePortrait2D(dF_1, [-3, 3]) fig, ax = example1.plot() Color shows the speed of the trajectory, as we can see, far away points from (0,0) have a greater velocity. Purple shifted colors show less velocity than red shifted colors in the default color scheme. Color scheme can be changed introducing kwarg color when creating the class instance. A list with accepted values can be found here . Later, we'll do a pair of examples changing the color scheme. Let's explore all options given by PhasePortrait2D class by doing some more examples.","title":"First steps"},{"location":"phaseportrait2d_examples/#title-and-labels","text":"Title and labels of the plot can be changed by calling the corresponding key arguments. For instance, using the dF function created in the first example: example2 = PhasePortrait2D(dF_1, [-3, 3], Title='This is a title', xlabel='This is not a title', ylabel='Neither is this') fig, ax = example2.plot() There is also, another way of doing it, using the ax class methods: example2 = PhasePortrait2D(dF_1, [-3, 3]) fig, ax = example2.plot() ax.set_title('This is a title') ax.set_xlabel('This is not a title') ax.set_ylabel('Neither is this') That will yield to the same result. If not specified, default values are: Title : 'Phase Portrait' xlabel : 'X' ylabel : r'$\\dot{X}$'","title":"Title and labels"},{"location":"phaseportrait2d_examples/#latex-in-title-and-labels","text":"Using r strings , LaTeX-like syntax can be used for writing titles and axis labels. example2 = PhasePortrait2D(dF_1, [-3, 3], Title=r'You can use some $\\left[ LaTeX \\right]$ language', xlabel=r'$\\Delta t$', ylabel=r'$\\~{duck}$') fig, ax = example2.plot()","title":"LaTeX in Title and labels"},{"location":"phaseportrait2d_examples/#polar-and-color","text":"Let's say we want to study the phase portrait of a system which is given in polar coordinates. Polar argument is used in this cases. def dF_polar(x, y): return 0, 1 example2 = PhasePortrait2D(dF_polar, [-3, 3], Title='Polar plot', xlabel='This is meaningless', ylabel='Why are we here?', Polar=True, color='inferno') fig, ax = example2.plot()","title":"Polar and color"},{"location":"phaseportrait2d_examples/#density","text":"In order to increase the number of the arrows we modify the Density (by default 1). Be careful, increasing this value speeds down the execution a lot . For this example we will set the density a bit lower and a bit higher than the default value. def circle(x, y): return -y, x low_D = PhasePortrait2D(circle, [-3,3], Density=0.5, Title='Density=0.5', xlabel='give you up', ylabel='Never gonna', color='cool') fig, ax = low_D.plot() big_D = PhasePortrait2D(circle, [-3,3], Density=2, Title='Density=2', xlabel='let you down', ylabel='Never gonna', color='viridis') fig, ax = big_D.plot()","title":"Density"},{"location":"phaseportrait2d_examples/#meshdim","text":"In order to create the phase portrait, we create an LxL mesh in which the arrows trajectories are computed. MeshDim inidicates the size of the mesh. Be careful, increasing this value speeds down the execution . It's very important to have a reasonable value for it, as having it too low will give an incorrect representation and giving a high value will be inefficient and expensive computationally. In the following GIF, we've set an example of the evolution of a portrait changing MeshDim's value. It can be seen that passed MeshDim = 15, the changes are insignificant to have a global understanding of the behaviour of the system.","title":"MeshDim"},{"location":"phaseportrait2d_examples/#df_args","text":"As said in dF function documentation kargs can be give. Those kargs can be specify via the dF_args , such as follows: In this example the dF function sets \u03bc=0 and \u03b7=0.1 , although we want \u03bc=1 and \u03b7=0.1 : def dF_limit_cycle(r, \u03b8, *, \u03bc=0, \u03b7=0): return \u03bc*r*(1 - r*r), 1+\u03b7*\u03b8 not_a_circle = PhasePortrait2D(dF_limit_cycle, [-3, 3], dF_args={'\u03bc':1.0, '\u03b7':0.1}, Polar=True, Title='Never gonna run around', xlabel='X', ylabel='Y') fig, ax = not_a_circle.plot() dF_args must be a dictionary. This is useful if specific values of the kargs are known, in general, they are not. In those cases we recomend using Sliders.","title":"dF_args"},{"location":"phaseportrait2d_examples/#sliders","text":"This method allows the user to modify the dF_args in the plot, so it is easier to visualize interesting behaviours. To use them the user must declare the specific name of the karg. Initial value, range of values and step between selectionable consecutive values are optional. For instance, we will slide over the variable \u03bc , with initial value \u03bc=0, in the range \u03bc\u2208[0,1] and distance between consecutive values 0.2 . slippery_cycle = PhasePortrait2D(dF_limit_cycle, [-3, 3], Polar=True, Title='And slide you', xlabel='X', ylabel='Y') slippery_cycle.add_slider('\u03bc', valinit=0, valinterval=[0,1], valstep=0.2) fig, ax = slippery_cycle.plot()","title":"Sliders"},{"location":"phaseportrait2d_examples/#nullclines","text":"This method allows the user to plot in the same figure the \"lines\" where the velocity is some specific value (by default 0), in either X or Y axis. For example, we will mark with black where Vx=0 and green Vy=0. def dF_limit_cycle(r, \u03b8, *, \u03bc=0.5,\u03b7=0): return \u03bc*r*(1 - r*r), 1+\u03b7*\u03b8 slippery_cycle = PhasePortrait2D(dF_limit_cycle, [-3, 3], Polar=True, Title='You know the nulls and so do I') slippery_cycle.add_slider('\u03bc', valinit=0, valinterval=[-1,1], valstep=0.05) slippery_cycle.add_nullclines(xcolor='black', ycolor='green') slippery_cycle.plot(color='cool') For more information about nullclines see documentation .","title":"Nullclines"},{"location":"phaseportrait2d_examples/#more-examples","text":"A Jupyter Notebook with more examples, with physical or mathematical background can be found here .","title":"More examples"},{"location":"phaseportrait3d/","text":"PhasePortrait3D class phaseportrait. PhasePortrait3D ( dF, Range, *, MeshDim=6, dF_args={}, Density=1, Polar=False, **kargs ) Gives the option to represent a 3D phase portrait given a dF function with 3 args. Parameters dF : callable A dF type funcion. Computes the derivatives of given coordinates. Range : [x_range, y_range, z_range] Ranges of the axis in the main plot. See Defining Range . Key Arguments MeshDim : int, default=6 Lattice side used to make lines not intersect. It has a great impact on performance. We recommend 6~8. dF_args : dict If necesary, must contain the kargs for the dF function. maxLen : int Max number of points in every trajectory. Density : float, default=1 Number of elements in the arrows grid plot. Polar : bool, default=False Whether to use polar (spherical) coordinates or not. Title : str, default='Phase Portrait' Title of the plot. xlabel : str, default='X' x label of the plot. ylabel : str, default='Y' y label of the plot. zlabel : str, default='Z' z label of the plot. color : str, default='rainbow' Matplotlib Cmap . xScale : str, default='linear' X axis scale. yScale : str, default='linear' Y axis scale. zScale : str, default='linear' Z axis scale. Methods PhasePortrait3D .plot PhasePortrait3D . plot ( *, color=None, grid=None ) Prepares the plots and computes the values.. Color scheme can be changed introducing key argument color . A list with accepted values can be found here . Returns tuple(matplotlib Figure, matplotlib Axis) PhasePortrait3D .add_slider PhasePortrait3D . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time. Parameters param_name : str The string key of the variable. Must be the same as the key in the dF function. Key Arguments valinit : float, default=None Initial value of the parameter. valinterval : Union[float, list], default=0.1 The range of values the slider of the parameter will cover. valstep : float, default=10 Precision in the slider. Returns None Defining Range A range, such [lowerLimit , upperLimit] . All three axes will take the same limits. Three ranges, such that [[xLowerLimit , xUpperLimit], [yLowerLimit , yUpperLimit], [zLowerLimit , zUpperLimit]] Examples import matplotlib.pyplot as plt import phaseportrait # Include streamlines clases to change line styles from phaseportrait.streamlines import * def dF(x,y,z, *, w=1): return -y, x, -z example = phaseportrait.PhasePortrait3D(dF, [-3, 3], MeshDim=6, maxLen=2500, deltat=0.1) example.add_slider('w') example.Title = \"PhaserPortrait3D\" # Change from color proportional to speed to wind like plot # Default callback is Streamlines_Velocity_Color_Gradient. # example.streamplot_callback = Streamlines_Size_Gradient example.plot(color='viridis', grid=True) plt.show()","title":"PhasePortrait3d"},{"location":"phaseportrait3d/#phaseportrait3d","text":"class phaseportrait. PhasePortrait3D ( dF, Range, *, MeshDim=6, dF_args={}, Density=1, Polar=False, **kargs ) Gives the option to represent a 3D phase portrait given a dF function with 3 args.","title":"PhasePortrait3D"},{"location":"phaseportrait3d/#parameters","text":"dF : callable A dF type funcion. Computes the derivatives of given coordinates. Range : [x_range, y_range, z_range] Ranges of the axis in the main plot. See Defining Range .","title":"Parameters"},{"location":"phaseportrait3d/#key-arguments","text":"MeshDim : int, default=6 Lattice side used to make lines not intersect. It has a great impact on performance. We recommend 6~8. dF_args : dict If necesary, must contain the kargs for the dF function. maxLen : int Max number of points in every trajectory. Density : float, default=1 Number of elements in the arrows grid plot. Polar : bool, default=False Whether to use polar (spherical) coordinates or not. Title : str, default='Phase Portrait' Title of the plot. xlabel : str, default='X' x label of the plot. ylabel : str, default='Y' y label of the plot. zlabel : str, default='Z' z label of the plot. color : str, default='rainbow' Matplotlib Cmap . xScale : str, default='linear' X axis scale. yScale : str, default='linear' Y axis scale. zScale : str, default='linear' Z axis scale.","title":"Key Arguments"},{"location":"phaseportrait3d/#methods","text":"","title":"Methods"},{"location":"phaseportrait3d/#phaseportrait3dplot","text":"PhasePortrait3D . plot ( *, color=None, grid=None ) Prepares the plots and computes the values.. Color scheme can be changed introducing key argument color . A list with accepted values can be found here . Returns tuple(matplotlib Figure, matplotlib Axis)","title":"PhasePortrait3D.plot"},{"location":"phaseportrait3d/#phaseportrait3dadd_slider","text":"PhasePortrait3D . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time. Parameters param_name : str The string key of the variable. Must be the same as the key in the dF function. Key Arguments valinit : float, default=None Initial value of the parameter. valinterval : Union[float, list], default=0.1 The range of values the slider of the parameter will cover. valstep : float, default=10 Precision in the slider. Returns None","title":"PhasePortrait3D.add_slider"},{"location":"phaseportrait3d/#defining-range","text":"A range, such [lowerLimit , upperLimit] . All three axes will take the same limits. Three ranges, such that [[xLowerLimit , xUpperLimit], [yLowerLimit , yUpperLimit], [zLowerLimit , zUpperLimit]]","title":"Defining Range"},{"location":"phaseportrait3d/#examples","text":"import matplotlib.pyplot as plt import phaseportrait # Include streamlines clases to change line styles from phaseportrait.streamlines import * def dF(x,y,z, *, w=1): return -y, x, -z example = phaseportrait.PhasePortrait3D(dF, [-3, 3], MeshDim=6, maxLen=2500, deltat=0.1) example.add_slider('w') example.Title = \"PhaserPortrait3D\" # Change from color proportional to speed to wind like plot # Default callback is Streamlines_Velocity_Color_Gradient. # example.streamplot_callback = Streamlines_Size_Gradient example.plot(color='viridis', grid=True) plt.show()","title":"Examples"},{"location":"rungekutta/","text":"RungeKutta class phaseportrait.trajectories. RungeKutta ( portrait, dF, dimension, max_values, *, dt=0.1, dF_args=None, initial_values=None, thermalization=0 ) This class is used internally in Trajectories. It is not intended to be used by the user. This class is an implementation of _Generator_ for a Runge-Kutta 4th order data generator. Parameters portrait : Class that uses the RungeKutta objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved. Key Arguments dt : double, optional, by default 0.1 Time interval used in the Runge-Kutta 4th order method. dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. Overwritten methods _Generator_ . _next _Generator_ . _next () Generates from self.position its following value via the Runge-Kutta 4th order method. Explicitly: def _next(self): k1 = np.array(self.dF(*(self.position), **self.dF_args)) k2 = np.array(self.dF(*(self.position+0.5*k1*self.dt), **self.dF_args)) k3 = np.array(self.dF(*(self.position+0.5*k2*self.dt), **self.dF_args)) k4 = np.array(self.dF(*(self.position+k3*self.dt), **self.dF_args)) self.velocity = 1/6*(k1+2*k2+2*k3+k4) self.position += self.velocity*self.dt Returns None _Generator_ . save _Generator_ . save (i) Saves self.position in the attribute self.positions , and self.velocity in self.velocities . Parameters i : int Index in which the data is saved. Explicitly: def save(self, i): try: self.positions[:, i] = self.position self.velocities[:, i] = self.velocity except IndexError: np.concatenate(self.positions, self._create_values_array(), axis=1) np.concatenate(self.velocities, self._create_values_array(), axis=1) self.max_values += 2000 self.save(i) Returns None _Generator_ . clear_values _Generator_ . clear_values () Clears the data arrays self.positions and self.velocities . Returns None Methods _Generator_ .instance_and_compute_all _Generator_ . instance_and_compute_all (portrait, dF, dimension, dF_args, initial_values, max_values, save_freq=1, dt=0.1, thermalization=0) Creates an instance of phase-portrait.trajectories.RungeKutta. Computes all the data requested and returns the instance. Parameters portrait : Class that uses the RungeKutta objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat max_values : int Max number of values saved. save_freq : int, optional, by default 1 Number of values computed before saving them. dt : double, by default 0.1 Time interval used in the Runge-Kutta 4th order method. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. Returns phase-portrait.trajectories.RungeKutta Examples This class is implemented in other classes, check out: Trajectory","title":"Runge Kutta"},{"location":"rungekutta/#rungekutta","text":"class phaseportrait.trajectories. RungeKutta ( portrait, dF, dimension, max_values, *, dt=0.1, dF_args=None, initial_values=None, thermalization=0 ) This class is used internally in Trajectories. It is not intended to be used by the user. This class is an implementation of _Generator_ for a Runge-Kutta 4th order data generator.","title":"RungeKutta"},{"location":"rungekutta/#parameters","text":"portrait : Class that uses the RungeKutta objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. max_values : int Max number of values saved.","title":"Parameters"},{"location":"rungekutta/#key-arguments","text":"dt : double, optional, by default 0.1 Time interval used in the Runge-Kutta 4th order method. dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0.","title":"Key Arguments"},{"location":"rungekutta/#overwritten-methods","text":"","title":"Overwritten methods"},{"location":"rungekutta/#_generator__next","text":"_Generator_ . _next () Generates from self.position its following value via the Runge-Kutta 4th order method. Explicitly: def _next(self): k1 = np.array(self.dF(*(self.position), **self.dF_args)) k2 = np.array(self.dF(*(self.position+0.5*k1*self.dt), **self.dF_args)) k3 = np.array(self.dF(*(self.position+0.5*k2*self.dt), **self.dF_args)) k4 = np.array(self.dF(*(self.position+k3*self.dt), **self.dF_args)) self.velocity = 1/6*(k1+2*k2+2*k3+k4) self.position += self.velocity*self.dt Returns None","title":"\u000295\u0003Generator\u000295\u0003.\u000295\u0003next"},{"location":"rungekutta/#_generator_save","text":"_Generator_ . save (i) Saves self.position in the attribute self.positions , and self.velocity in self.velocities . Parameters i : int Index in which the data is saved. Explicitly: def save(self, i): try: self.positions[:, i] = self.position self.velocities[:, i] = self.velocity except IndexError: np.concatenate(self.positions, self._create_values_array(), axis=1) np.concatenate(self.velocities, self._create_values_array(), axis=1) self.max_values += 2000 self.save(i) Returns None","title":"\u000295\u0003Generator\u000295\u0003.save"},{"location":"rungekutta/#_generator_clear_values","text":"_Generator_ . clear_values () Clears the data arrays self.positions and self.velocities . Returns None","title":"\u000295\u0003Generator\u000295\u0003.clear_values"},{"location":"rungekutta/#methods","text":"","title":"Methods"},{"location":"rungekutta/#_generator_instance_and_compute_all","text":"_Generator_ . instance_and_compute_all (portrait, dF, dimension, dF_args, initial_values, max_values, save_freq=1, dt=0.1, thermalization=0) Creates an instance of phase-portrait.trajectories.RungeKutta. Computes all the data requested and returns the instance. Parameters portrait : Class that uses the RungeKutta objects. dF : callable A dF type funcion. dimension : int Number of dimensions in which it calculates the next values. Must equal the amount of outputs the dF funcion gives. dF_args : dict If necesary, must contain the kargs for the dF funcion. By default, None. initial_values : float, list, optional Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat max_values : int Max number of values saved. save_freq : int, optional, by default 1 Number of values computed before saving them. dt : double, by default 0.1 Time interval used in the Runge-Kutta 4th order method. thermalization : int, optional Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0. Returns phase-portrait.trajectories.RungeKutta","title":"\u000295\u0003Generator\u000295\u0003.instance_and_compute_all"},{"location":"rungekutta/#examples","text":"This class is implemented in other classes, check out: Trajectory","title":"Examples"},{"location":"slider/","text":"Sliders class phaseportrait.sliders. Slider ( portrait, param_name, valinit=None, valstep=0.1, valinterval=[] ) This class is not pretended to be used by the user. It is handled by the other objects automatically. Adds a slider which can change the value of a parameter in dF during execution time. Integrated via method add_slider in: * Map1D Cobweb PhasePortrait2D Trajectory2D Trajectory3D Parameters portrait : Class that uses the Slider. param_name : str Name of the parameter to slide over. valinit : float Initial value of the parameter in the slider. valsetp : float, default=0.1 Precision of the slider. valinterval : Union[float, list] Parameter range in the slider. Default value is [-10, 10] Methods Slider .__call__ method __call__ ( value ) Updates internal dF_args and replots the graphs. Arguments value : float New value for the parameter of the slider Returns None Examples Slider is implemented in several classes via add_slider method (tipically), check out: Cobweb Map1D PhasePortrait2D Trajectory2D Trajectory3D","title":"Slider"},{"location":"slider/#sliders","text":"class phaseportrait.sliders. Slider ( portrait, param_name, valinit=None, valstep=0.1, valinterval=[] ) This class is not pretended to be used by the user. It is handled by the other objects automatically. Adds a slider which can change the value of a parameter in dF during execution time. Integrated via method add_slider in: * Map1D Cobweb PhasePortrait2D Trajectory2D Trajectory3D","title":"Sliders"},{"location":"slider/#parameters","text":"portrait : Class that uses the Slider. param_name : str Name of the parameter to slide over. valinit : float Initial value of the parameter in the slider. valsetp : float, default=0.1 Precision of the slider. valinterval : Union[float, list] Parameter range in the slider. Default value is [-10, 10]","title":"Parameters"},{"location":"slider/#methods","text":"","title":"Methods"},{"location":"slider/#slider__call__","text":"method __call__ ( value ) Updates internal dF_args and replots the graphs. Arguments value : float New value for the parameter of the slider Returns None","title":"Slider.\u000295\u0003\u000295\u0003call\u000295\u0003\u000295\u0003"},{"location":"slider/#examples","text":"Slider is implemented in several classes via add_slider method (tipically), check out: Cobweb Map1D PhasePortrait2D Trajectory2D Trajectory3D","title":"Examples"},{"location":"streamlines_base/","text":"Streamlines_base2D class phaseportrait.streamlines. Streamlines_base2D ( dF, X, Y, maxLen=500, deltat=0.01, , dF_args=None, polar=False, density=1, scypi_odeint=False, **kargs*) Compute a set of streamlines given velocity function dF . Parameters dF : callable A dF type funcion. Computes the derivatives of given coordinates. X and Y : 1D or 2D arrays Arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension. maxLen : int, default=500 The maximum length of an individual streamline segment. polar : bool, default=false Whether to use polar coordinates or not. density : int, default=1 Density of mask grid. Used for making the stream lines not collide. scypi_odeint : bool, default=False Use scipy.odeint for integration. If False Runge-Kutta 3rd order is used. Key Arguments -------- dF_args: dict|None, default=None dF_args of `dF` function. Streamlines_baseD3 class phaseportrait.streamlines. Streamlines_baseD3 ( dF, X, Y, Z, maxLen=500, deltat=0.01, , dF_args=None, polar=False, density=1, scypi_odeint=False, **kargs*) Compute a set of streamlines given velocity function dF . Parameters dF : callable A dF type funcion. Computes the derivatives of given coordinates. X, Y and Z : 1D or 2D arrays Arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension. maxLen : int, default=500 The maximum length of an individual streamline segment. polar : bool, default=false Whether to use polar coordinates or not. density : int, default=1 Density of mask grid. Used for making the stream lines not collide. scypi_odeint : bool, default=False Use scipy.odeint for integration. If False Runge-Kutta 3rd order is used. Key Arguments -------- dF_args: dict|None, default=None dF_args of `dF` function.","title":"Streamlines"},{"location":"streamlines_base/#streamlines_base2d","text":"class phaseportrait.streamlines. Streamlines_base2D ( dF, X, Y, maxLen=500, deltat=0.01, , dF_args=None, polar=False, density=1, scypi_odeint=False, **kargs*) Compute a set of streamlines given velocity function dF .","title":"Streamlines_base2D"},{"location":"streamlines_base/#parameters","text":"dF : callable A dF type funcion. Computes the derivatives of given coordinates. X and Y : 1D or 2D arrays Arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension. maxLen : int, default=500 The maximum length of an individual streamline segment. polar : bool, default=false Whether to use polar coordinates or not. density : int, default=1 Density of mask grid. Used for making the stream lines not collide. scypi_odeint : bool, default=False Use scipy.odeint for integration. If False Runge-Kutta 3rd order is used.","title":"Parameters"},{"location":"streamlines_base/#key-arguments","text":"-------- dF_args: dict|None, default=None dF_args of `dF` function.","title":"Key Arguments"},{"location":"streamlines_base/#streamlines_based3","text":"class phaseportrait.streamlines. Streamlines_baseD3 ( dF, X, Y, Z, maxLen=500, deltat=0.01, , dF_args=None, polar=False, density=1, scypi_odeint=False, **kargs*) Compute a set of streamlines given velocity function dF .","title":"Streamlines_baseD3"},{"location":"streamlines_base/#parameters_1","text":"dF : callable A dF type funcion. Computes the derivatives of given coordinates. X, Y and Z : 1D or 2D arrays Arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension. maxLen : int, default=500 The maximum length of an individual streamline segment. polar : bool, default=false Whether to use polar coordinates or not. density : int, default=1 Density of mask grid. Used for making the stream lines not collide. scypi_odeint : bool, default=False Use scipy.odeint for integration. If False Runge-Kutta 3rd order is used.","title":"Parameters"},{"location":"streamlines_base/#key-arguments_1","text":"-------- dF_args: dict|None, default=None dF_args of `dF` function.","title":"Key Arguments"},{"location":"trajectories_examples/","text":"First steps In this examples, we will be using Trajectory2D and Trajectory3D classes. So, we'll have to import them from phaseportrait module: from phaseportrait import Trajectory2D, Trajectory3D Both classes take 1 necessary argument: dF function : a function that, in this case, returns a tuple, corresponding of the evolution of the 2/3 coordinates. Trajectory2D Let's start with an easy example: just a circle. In order to compute the trajectory you need the amount of points n_points , the function dF , and initial position initial_position(x,y) . In a circle it should look something like this: def dF(x,y): return -y, x circle = Trajectory2D(dF, n_points=628, size=2) circle.initial_position(1,0) circle.plot() Multiple trajectories Just add more initial positions: circles = Trajectory2D(dF, n_points=628, size=2) circles.initial_position(1,0) circles.initial_position(0,2) circles.initial_position(-3,0) circles.plot() If you want to diferenciate between multiple trajectories use karg lines=True , as in the following: def Lorenz(x,y,z,*, s=10, r=28, b=8/3): return -s*x+s*y, -x*z+r*x-y, x*y-b*z chaos = Trajectory3D(Lorenz, lines=True, n_points=1300, mark_start_position=True, size=3, Title='Nearby IC on Lorenz attractor') chaos.initial_position(10,10,10) chaos.initial_position(10,10,10.0001) chaos.plot() Ranges, title, labels and colormaps Ranges can be defined in several ways. A single number. In this case the range is defined from zero to the given number in all axes. A range, such [lowerLimit , upperLimit] . All axes will take the same limits. Three ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit], [zAxisLowerLimit , zAxisUpperLimit]] Title and labels with the kargs: Title , xlabel , ylabel and zlabel . For example: def dF(x,y, *, w=2): return -y, w*x example = Trajectory2D(dF, n_points=628, Range=[[-1,1],[-3,3]], size=2, Title='This is an ellipse', xlabel='This the X label', ylabel='This is the Y label') example.initial_position(1,0) example.plot() Colormap expresses the velocity of the trajectory, it can be changed with color kwarg. Default colormap is 'viridis' , in which purple-shifted colors indicate less velocity than yellow-shifted colors. A list with accepted values can be found here . An also valid value is t , which will represent the colors as the evolution in time of the trajectory, according to viridis cmap. Using karg color when calling plot method permits changing the colormap to another. Numba Numba can be used to compute trajectories. To use it, give numba=True as kwarg. When using Numba, dF_args karg is compulsory. For instance: def Lorenz(x,y,z,*, s=10, r=28, b=8/3): return -s*x+s*y, -x*z+r*x-y, x*y-b*z Lorentz_plot = Trajectory3D(Lorenz, dF_args={'s':10, 'r':28, 'b':8/3}, color='t', n_points=4000, numba=True, size=2, Title='Lorenz attractor') Lorentz_plot.initial_position(10,10,10) Lorentz_plot.plot() Thermalization If you want to see an attractor you should discard the initial points. In order to do that use karg thermalization=N where N is the number of points calculated and rejected. Just like this: def Halvorsen(x,y,z, *, s=1.4): delta = (3*s+15) return -s*x + 2*y - 4*z - y**2 + delta , -s*y + 2*z - 4*x - z**2 + delta, -s*z + 2*x - 4*y - x**2 + delta attractor1 = Trajectory3D(Halvorsen, dF_args={'s':1.4}, n_points=10000, thermalization=500, numba=True, size=2, Title='Halvorsen attractor') attractor1.initial_position(0,5,10) attractor1.plot(color='inferno') Or you can use the method thermalize , then the initial position taken will be random. def Halvorsen(x,y,z, *, s=1.4): delta = (3*s+15) return -s*x + 2*y - 4*z - y**2 + delta , -s*y + 2*z - 4*x - z**2 + delta, -s*z + 2*x - 4*y - x**2 + delta attractor1 = Trajectory3D(Halvorsen, dF_args={'s':1.4}, n_points=10000, numba=True, size=2, Title='Halvorsen attractor') attractor1.thermalize(thermalization_steps=1000) attractor1.plot(color='inferno') Sliders This method allows the user to modify the dF_args in the plot, so it is easier to visualize interesting behaviours. To use them the user must declare the specific name of the karg. Initial value, range of values and step between selectionable consecutive values are optional. def Aizawa(x,y,z,*, a=0.95, b=0.7, c=0.6, d=3.5, e=0.25, f=0.1): return (z-b)*x - d*y, d*x + (z-b)*y, c + a*z - z*z*z/3 - (x*x + y*y) * (1 + e*z) + f*z*x*x*x attractor2 = Trajectory3D(Aizawa, n_points=10000, size=1, thermalization=2000, Title='Aizawa attractor') attractor2.thermalize() attractor2.add_slider('a', valinit=0.95, valinterval=[0,1], valstep=0.005) attractor2.add_slider('b', valinit=0.7, valinterval=[0,1], valstep=0.005) attractor2.add_slider('c', valinit=0.6, valinterval=[0,1], valstep=0.005) attractor2.add_slider('d', valinit=3.5, valinterval=[0,4], valstep=0.05) attractor2.add_slider('e', valinit=0.24, valinterval=[0,1], valstep=0.005) attractor2.add_slider('f', valinit=0.1, valinterval=[0,1], valstep=0.005) attractor2.plot() We've taken a look to the most important arguments in order to visualize trajectories. Nevertheless, trajectory classes have more features that can be seen by taking a look into the docs: Trajectory2D Trajectory3D trajectory Some more examples If you want to take a look to some more 'elaborated' plots, we recommend you taking a look to the following file , in which you cand find several famous chaotic attractors.","title":"2D & 3D trajectories"},{"location":"trajectories_examples/#first-steps","text":"In this examples, we will be using Trajectory2D and Trajectory3D classes. So, we'll have to import them from phaseportrait module: from phaseportrait import Trajectory2D, Trajectory3D Both classes take 1 necessary argument: dF function : a function that, in this case, returns a tuple, corresponding of the evolution of the 2/3 coordinates.","title":"First steps"},{"location":"trajectories_examples/#trajectory2d","text":"Let's start with an easy example: just a circle. In order to compute the trajectory you need the amount of points n_points , the function dF , and initial position initial_position(x,y) . In a circle it should look something like this: def dF(x,y): return -y, x circle = Trajectory2D(dF, n_points=628, size=2) circle.initial_position(1,0) circle.plot()","title":"Trajectory2D"},{"location":"trajectories_examples/#multiple-trajectories","text":"Just add more initial positions: circles = Trajectory2D(dF, n_points=628, size=2) circles.initial_position(1,0) circles.initial_position(0,2) circles.initial_position(-3,0) circles.plot() If you want to diferenciate between multiple trajectories use karg lines=True , as in the following: def Lorenz(x,y,z,*, s=10, r=28, b=8/3): return -s*x+s*y, -x*z+r*x-y, x*y-b*z chaos = Trajectory3D(Lorenz, lines=True, n_points=1300, mark_start_position=True, size=3, Title='Nearby IC on Lorenz attractor') chaos.initial_position(10,10,10) chaos.initial_position(10,10,10.0001) chaos.plot()","title":"Multiple trajectories"},{"location":"trajectories_examples/#ranges-title-labels-and-colormaps","text":"Ranges can be defined in several ways. A single number. In this case the range is defined from zero to the given number in all axes. A range, such [lowerLimit , upperLimit] . All axes will take the same limits. Three ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit], [zAxisLowerLimit , zAxisUpperLimit]] Title and labels with the kargs: Title , xlabel , ylabel and zlabel . For example: def dF(x,y, *, w=2): return -y, w*x example = Trajectory2D(dF, n_points=628, Range=[[-1,1],[-3,3]], size=2, Title='This is an ellipse', xlabel='This the X label', ylabel='This is the Y label') example.initial_position(1,0) example.plot() Colormap expresses the velocity of the trajectory, it can be changed with color kwarg. Default colormap is 'viridis' , in which purple-shifted colors indicate less velocity than yellow-shifted colors. A list with accepted values can be found here . An also valid value is t , which will represent the colors as the evolution in time of the trajectory, according to viridis cmap. Using karg color when calling plot method permits changing the colormap to another.","title":"Ranges, title, labels and colormaps"},{"location":"trajectories_examples/#numba","text":"Numba can be used to compute trajectories. To use it, give numba=True as kwarg. When using Numba, dF_args karg is compulsory. For instance: def Lorenz(x,y,z,*, s=10, r=28, b=8/3): return -s*x+s*y, -x*z+r*x-y, x*y-b*z Lorentz_plot = Trajectory3D(Lorenz, dF_args={'s':10, 'r':28, 'b':8/3}, color='t', n_points=4000, numba=True, size=2, Title='Lorenz attractor') Lorentz_plot.initial_position(10,10,10) Lorentz_plot.plot()","title":"Numba"},{"location":"trajectories_examples/#thermalization","text":"If you want to see an attractor you should discard the initial points. In order to do that use karg thermalization=N where N is the number of points calculated and rejected. Just like this: def Halvorsen(x,y,z, *, s=1.4): delta = (3*s+15) return -s*x + 2*y - 4*z - y**2 + delta , -s*y + 2*z - 4*x - z**2 + delta, -s*z + 2*x - 4*y - x**2 + delta attractor1 = Trajectory3D(Halvorsen, dF_args={'s':1.4}, n_points=10000, thermalization=500, numba=True, size=2, Title='Halvorsen attractor') attractor1.initial_position(0,5,10) attractor1.plot(color='inferno') Or you can use the method thermalize , then the initial position taken will be random. def Halvorsen(x,y,z, *, s=1.4): delta = (3*s+15) return -s*x + 2*y - 4*z - y**2 + delta , -s*y + 2*z - 4*x - z**2 + delta, -s*z + 2*x - 4*y - x**2 + delta attractor1 = Trajectory3D(Halvorsen, dF_args={'s':1.4}, n_points=10000, numba=True, size=2, Title='Halvorsen attractor') attractor1.thermalize(thermalization_steps=1000) attractor1.plot(color='inferno')","title":"Thermalization"},{"location":"trajectories_examples/#sliders","text":"This method allows the user to modify the dF_args in the plot, so it is easier to visualize interesting behaviours. To use them the user must declare the specific name of the karg. Initial value, range of values and step between selectionable consecutive values are optional. def Aizawa(x,y,z,*, a=0.95, b=0.7, c=0.6, d=3.5, e=0.25, f=0.1): return (z-b)*x - d*y, d*x + (z-b)*y, c + a*z - z*z*z/3 - (x*x + y*y) * (1 + e*z) + f*z*x*x*x attractor2 = Trajectory3D(Aizawa, n_points=10000, size=1, thermalization=2000, Title='Aizawa attractor') attractor2.thermalize() attractor2.add_slider('a', valinit=0.95, valinterval=[0,1], valstep=0.005) attractor2.add_slider('b', valinit=0.7, valinterval=[0,1], valstep=0.005) attractor2.add_slider('c', valinit=0.6, valinterval=[0,1], valstep=0.005) attractor2.add_slider('d', valinit=3.5, valinterval=[0,4], valstep=0.05) attractor2.add_slider('e', valinit=0.24, valinterval=[0,1], valstep=0.005) attractor2.add_slider('f', valinit=0.1, valinterval=[0,1], valstep=0.005) attractor2.plot() We've taken a look to the most important arguments in order to visualize trajectories. Nevertheless, trajectory classes have more features that can be seen by taking a look into the docs: Trajectory2D Trajectory3D trajectory","title":"Sliders"},{"location":"trajectories_examples/#some-more-examples","text":"If you want to take a look to some more 'elaborated' plots, we recommend you taking a look to the following file , in which you cand find several famous chaotic attractors.","title":"Some more examples"},{"location":"trajectory/","text":"Trajectory class phaseportrait.trajectories. trajectory ( dF, dimension, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **karg ) This class is not meant to be used by the user. Parent class for trajectory2d and trajectory3d . Represents trajectories given a dF function with N args. Class inheriting must have the following methods: def _prepare_plot(self): ... Prepares the plots: axis titles, graph title, grid, etc. def _plot_lines(self, val, val_init): ... Plots a line of points given in a tuple of positions val and an initial position val_init , both N-dimensional. def _scatter_start_point(self, val_init): ... Marks starting position val_init (N-dimensional) in the several plots created. def _scatter_trajectory(self, val, color, cmap): ... Plots with points val (N-dimensional list) according to color (N-dimensional) with cmap color map. Methods trajectory .thermalize trajectory . thermalize ( *, thermalization_steps=200 ) Sets the thermalization steps if given and executes self.initial_position method. Returns None trajectory .initial_position trajectory . initial_position ( *position ) Adds a initial position for the computation. More than one can be added. Parameters position : Union[float, list[2], list[3]], optional Initial position for the computation. If None, a random position is chosen. Returns None trajectory .initial_positions trajectory . initial_positions ( *positions ) Adds initial positions for the computation. Parameters positions : list, optional Initial positiond for the computation. Must be iterable. Returns None trajectory .plot trajectory . plot () Prepares the plots and computes the values. Key Arguments color : str Matplotlib Cmap . If given 't' value, color follows the temporal evolution of the trajectory. Returns tuple(matplotlib Figure, matplotlib Axis) None (if attribute fig or ax is not found) trajectory .add_slider trajectory . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time. Parameters param_name : str The string key of the variable. Must be the same as the key in the dF function. Key Arguments valinit : float, default=None Initial value of the parameter. valinterval : Union[float, list], default=0.1 The range of values the slider of the parameter will cover. valstep : float, default=10 Precision in the slider. Returns None Examples This class is implemented in other classes, check out: Trajectory2D Trajectory3D","title":"Trajectory"},{"location":"trajectory/#trajectory","text":"class phaseportrait.trajectories. trajectory ( dF, dimension, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **karg ) This class is not meant to be used by the user. Parent class for trajectory2d and trajectory3d . Represents trajectories given a dF function with N args. Class inheriting must have the following methods: def _prepare_plot(self): ... Prepares the plots: axis titles, graph title, grid, etc. def _plot_lines(self, val, val_init): ... Plots a line of points given in a tuple of positions val and an initial position val_init , both N-dimensional. def _scatter_start_point(self, val_init): ... Marks starting position val_init (N-dimensional) in the several plots created. def _scatter_trajectory(self, val, color, cmap): ... Plots with points val (N-dimensional list) according to color (N-dimensional) with cmap color map.","title":"Trajectory"},{"location":"trajectory/#methods","text":"","title":"Methods"},{"location":"trajectory/#trajectorythermalize","text":"trajectory . thermalize ( *, thermalization_steps=200 ) Sets the thermalization steps if given and executes self.initial_position method. Returns None","title":"trajectory.thermalize"},{"location":"trajectory/#trajectoryinitial_position","text":"trajectory . initial_position ( *position ) Adds a initial position for the computation. More than one can be added. Parameters position : Union[float, list[2], list[3]], optional Initial position for the computation. If None, a random position is chosen. Returns None","title":"trajectory.initial_position"},{"location":"trajectory/#trajectoryinitial_positions","text":"trajectory . initial_positions ( *positions ) Adds initial positions for the computation. Parameters positions : list, optional Initial positiond for the computation. Must be iterable. Returns None","title":"trajectory.initial_positions"},{"location":"trajectory/#trajectoryplot","text":"trajectory . plot () Prepares the plots and computes the values. Key Arguments color : str Matplotlib Cmap . If given 't' value, color follows the temporal evolution of the trajectory. Returns tuple(matplotlib Figure, matplotlib Axis) None (if attribute fig or ax is not found)","title":"trajectory.plot"},{"location":"trajectory/#trajectoryadd_slider","text":"trajectory . add_slider ( param_name, *, valinit=None, valstep=0.1, valinterval=10 ) Adds a slider which can change the value of a parameter in execution time. Parameters param_name : str The string key of the variable. Must be the same as the key in the dF function. Key Arguments valinit : float, default=None Initial value of the parameter. valinterval : Union[float, list], default=0.1 The range of values the slider of the parameter will cover. valstep : float, default=10 Precision in the slider. Returns None","title":"trajectory.add_slider"},{"location":"trajectory/#examples","text":"This class is implemented in other classes, check out: Trajectory2D Trajectory3D","title":"Examples"},{"location":"trajectory2d/","text":"Trajectory2D class phaseportrait. Trajectory2D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Inherits from parent class trajectory . Computes a trajectory on a 2D system given a dF function consisting of 2 args. Parameters dF : callable A dF type function. Key Arguments Range : list Ranges if the axis in the main plot, by default None. See Defining Range . dF_args : dict If necesary, must contain the kargs for the dF function, by default {} n_points : int Maximum number of points to be calculated and represented, by default 10000 runge_kutta_step : float Step of 'time' in the Runge-Kutta method, by default 0.01 runge_kutta_freq : int Number of times dF is aplied between positions saved, by default 1 xlabel : str x label of the plot, by default 'X' ylabel : str y label of the plot, by default 'Y' Methods Inherits methods from parent class trajectory , a brief resume is offered, click on the method to see more information: thermalize : Adds thermalization steps and random initial position. initial_position : Adds a trajectory with the given initial position. initial_positions : Adds multiple trajectories with the given initial positions. plot : Prepares the plots and computes the values. Returns the axis and the figure. add_slider : Adds a slider for the dF function. Defining Range A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]] Examples from phaseportrait import Trajectories2D import numpy as np def dF(x,y,*, w=1, z=1): return w*np.sin(y*y*y), -z*np.exp(x*x) example = Trajectory2D(dF, n_points=1300, size=2, mark_start_position=True, Title='Just an example') example.initial_position(1,1) example.add_slider('w', valinterval=[-1,5]) example.add_slider('z', valinterval=[-1,5]) example.plot() plt.show()","title":"Trajectory2d"},{"location":"trajectory2d/#trajectory2d","text":"class phaseportrait. Trajectory2D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Inherits from parent class trajectory . Computes a trajectory on a 2D system given a dF function consisting of 2 args.","title":"Trajectory2D"},{"location":"trajectory2d/#parameters","text":"dF : callable A dF type function.","title":"Parameters"},{"location":"trajectory2d/#key-arguments","text":"Range : list Ranges if the axis in the main plot, by default None. See Defining Range . dF_args : dict If necesary, must contain the kargs for the dF function, by default {} n_points : int Maximum number of points to be calculated and represented, by default 10000 runge_kutta_step : float Step of 'time' in the Runge-Kutta method, by default 0.01 runge_kutta_freq : int Number of times dF is aplied between positions saved, by default 1 xlabel : str x label of the plot, by default 'X' ylabel : str y label of the plot, by default 'Y'","title":"Key Arguments"},{"location":"trajectory2d/#methods","text":"Inherits methods from parent class trajectory , a brief resume is offered, click on the method to see more information: thermalize : Adds thermalization steps and random initial position. initial_position : Adds a trajectory with the given initial position. initial_positions : Adds multiple trajectories with the given initial positions. plot : Prepares the plots and computes the values. Returns the axis and the figure. add_slider : Adds a slider for the dF function.","title":"Methods"},{"location":"trajectory2d/#defining-range","text":"A single number. In this case the range is defined from zero to the given number in both axes. A range, such [lowerLimit , upperLimit] . Both axes will take the same limits. Two ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]]","title":"Defining Range"},{"location":"trajectory2d/#examples","text":"from phaseportrait import Trajectories2D import numpy as np def dF(x,y,*, w=1, z=1): return w*np.sin(y*y*y), -z*np.exp(x*x) example = Trajectory2D(dF, n_points=1300, size=2, mark_start_position=True, Title='Just an example') example.initial_position(1,1) example.add_slider('w', valinterval=[-1,5]) example.add_slider('z', valinterval=[-1,5]) example.plot() plt.show()","title":"Examples"},{"location":"trajectory3d/","text":"Trajectory3D class phaseportrait. Trajectory3D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Inherits from parent class trajectory . Gives the option to represent 3D trajectories given a dF function with 3 args. Parameters dF : callable A dF type function. Key Arguments Range : list Ranges of the axis in the main plot, by default None. See Defining Range . dF_args : dict If necesary, must contain the kargs for the dF function, by default {} n_points : int Maximum number of points to be calculated and represented, by default 10000 runge_kutta_step : float Step of 'time' in the Runge-Kutta method, by default 0.01 runge_kutta_freq : int Number of times dF is aplied between positions saved, by default 1 xlabel : str x label of the plot, by default 'X' ylabel : str y label of the plot, by default 'Y' zlabel : str z label of the plot, by default 'Z' Methods Inherits methods from parent class trajectory , a brief resume is offered, click on the method to see more information: thermalize : Adds thermalization steps and random initial position. initial_position : Adds a trajectory with the given initial position. initial_positions : Adds multiple trajectories with the given initial positions. plot : Prepares the plots and computes the values. Returns the axis and the figure. add_slider : Adds a slider for the dF function. Defining Range A single number. In this case the range is defined from zero to the given number in all axes. A range, such [lowerLimit , upperLimit] . All axes will take the same limits. Three ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit], [zAxisLowerLimit , zAxisUpperLimit]] Examples Lorentz attractor: chaos Two trajectories with similar initial positions under the influence of Lorentz equations. from phaseportrait import Trajectories3D def Lorenz(x,y,z,*, s=10, r=28, b=8/3): return -s*x+s*y, -x*z+r*x-y, x*y-b*z a = Trajectory3D( Lorenz, lines=True, n_points=1300, size=3, mark_start_position=True, Title='Nearby IC on Lorenz attractor' ) a.initial_position(10,10,10) a.initial_position(10,10,10.0001) a.plot() Halvorsen attractor In this example we are interested in seeing the attractor, not trajectories, under the Halvorsen equations. from phaseportrait import Trajectories3D def Halvorsen(x,y,z, *, s=1.4): delta = (3*s+15) return -s*x+2*y-4*z-y**2+delta, -s*y+2*z-4*x-z**2+delta, -s*z+2*x-4*y-x**2+delta d = Trajectory3D( Halvorsen, dF_args={'s':1.4}, n_points=10000, thermalization=0, numba=True, size=2, mark_start_point=True, Title='Halvorsen attractor' ) d.initial_position(0,5,10) d.plot()","title":"Trajectory3d"},{"location":"trajectory3d/#trajectory3d","text":"class phaseportrait. Trajectory3D ( dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs ) Inherits from parent class trajectory . Gives the option to represent 3D trajectories given a dF function with 3 args.","title":"Trajectory3D"},{"location":"trajectory3d/#parameters","text":"dF : callable A dF type function.","title":"Parameters"},{"location":"trajectory3d/#key-arguments","text":"Range : list Ranges of the axis in the main plot, by default None. See Defining Range . dF_args : dict If necesary, must contain the kargs for the dF function, by default {} n_points : int Maximum number of points to be calculated and represented, by default 10000 runge_kutta_step : float Step of 'time' in the Runge-Kutta method, by default 0.01 runge_kutta_freq : int Number of times dF is aplied between positions saved, by default 1 xlabel : str x label of the plot, by default 'X' ylabel : str y label of the plot, by default 'Y' zlabel : str z label of the plot, by default 'Z'","title":"Key Arguments"},{"location":"trajectory3d/#methods","text":"Inherits methods from parent class trajectory , a brief resume is offered, click on the method to see more information: thermalize : Adds thermalization steps and random initial position. initial_position : Adds a trajectory with the given initial position. initial_positions : Adds multiple trajectories with the given initial positions. plot : Prepares the plots and computes the values. Returns the axis and the figure. add_slider : Adds a slider for the dF function.","title":"Methods"},{"location":"trajectory3d/#defining-range","text":"A single number. In this case the range is defined from zero to the given number in all axes. A range, such [lowerLimit , upperLimit] . All axes will take the same limits. Three ranges, such that [[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit], [zAxisLowerLimit , zAxisUpperLimit]]","title":"Defining Range"},{"location":"trajectory3d/#examples","text":"","title":"Examples"},{"location":"trajectory3d/#lorentz-attractor-chaos","text":"Two trajectories with similar initial positions under the influence of Lorentz equations. from phaseportrait import Trajectories3D def Lorenz(x,y,z,*, s=10, r=28, b=8/3): return -s*x+s*y, -x*z+r*x-y, x*y-b*z a = Trajectory3D( Lorenz, lines=True, n_points=1300, size=3, mark_start_position=True, Title='Nearby IC on Lorenz attractor' ) a.initial_position(10,10,10) a.initial_position(10,10,10.0001) a.plot()","title":"Lorentz attractor: chaos"},{"location":"trajectory3d/#halvorsen-attractor","text":"In this example we are interested in seeing the attractor, not trajectories, under the Halvorsen equations. from phaseportrait import Trajectories3D def Halvorsen(x,y,z, *, s=1.4): delta = (3*s+15) return -s*x+2*y-4*z-y**2+delta, -s*y+2*z-4*x-z**2+delta, -s*z+2*x-4*y-x**2+delta d = Trajectory3D( Halvorsen, dF_args={'s':1.4}, n_points=10000, thermalization=0, numba=True, size=2, mark_start_point=True, Title='Halvorsen attractor' ) d.initial_position(0,5,10) d.plot()","title":"Halvorsen attractor"}]}