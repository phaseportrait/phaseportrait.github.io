{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<pre><code>from matplotlib import pyplot\nimport numpy\n\nimport phaseportrait\n\ndef pendulum(\u03b8, d\u03b8):\n    return d\u03b8, - numpy.sin(\u03b8)\n\nSimplePendulum = phaseportrait.PhasePortrait2D(pendulum, [-9, 9], Title='Simple pendulum', xlabel=r\"$\\Theta$\", ylabel=r\"$\\dot{\\Theta}$\")\nSimplePendulum.plot()\n</code></pre> ."},{"location":"#documentation","title":"Documentation","text":"<p>To check out phaseportrait's documentation, view some examples and read more about it, check our website or try our Graphical User Interface!</p>"},{"location":"#whats-this","title":"What's this?","text":"<p>The idea behind this project was to create a simple way to make phase portraits in 2D and 3D in Python, as we couldn't find something similar on the internet, so we got down to work. (Update: found jmoy/plotdf, offers similar 2D phase plots but it is very limited).</p> <p>Eventually, we did some work on bifurcations, 1D maps and chaos in 3D trayectories.</p> <p>This idea came while taking a course in non linear dynamics and chaos, during the 3rd year of physics degree, brought by our desire of visualizing things and programming.</p> <p>We want to state that we are self-taught into making this kind of stuff, and we've tried to make things as professionally as possible, any comments about improving our work are welcome!</p>"},{"location":"#authors","title":"Authors","text":"<ul> <li>V\u00edctor Loras Herrero (vhloras@gmail.com)</li> <li>Unai Ler\u00eda Fortea (unaileria@gmail.com)</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>This proyect is open-source, everyone can download, use and contribute. To do that, several options are offered:</p> <ul> <li>Fork the project, add a new feature / improve the existing ones and pull a request via GitHub.</li> <li>Contact us on our emails:<ul> <li>vhloras@gmail.com</li> <li>unaileria@gmail.com</li> </ul> </li> </ul>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>reference<ul> <li>phaseportrait<ul> <li>Cobweb</li> <li>Map1D</li> <li>PhasePortrait2D</li> <li>PhasePortrait3D</li> <li>PhasePortraitManager</li> <li>Trajectories2D</li> <li>Trajectories3D</li> <li>exceptions<ul> <li>exceptions</li> </ul> </li> <li>generators_base<ul> <li>generator_base</li> </ul> </li> <li>maps<ul> <li>map</li> </ul> </li> <li>nullclines<ul> <li>nullclines</li> </ul> </li> <li>sliders<ul> <li>sliders</li> </ul> </li> <li>streamlines<ul> <li>size_gradient</li> <li>streamlines_base</li> <li>velocity_color_gradient</li> </ul> </li> <li>trajectories<ul> <li>rungekutta</li> <li>trajectory</li> </ul> </li> <li>utils<ul> <li>manager</li> <li>utils</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>The code is open, everyone can download it and use it. You can also contribute if you wish. To do that, several options are offered:</p> <ul> <li>Fork the project, add a new feature / improve the existing ones and pull a request via GitHub.</li> <li>Contact us on our emails:<ul> <li>vhloras@gmail.com</li> <li>unaileria@gmail.com</li> </ul> </li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Installing via pip:</p> <p>Phaseportrait releases are available as wheel packages for macOS, Windows and Linux on PyPI. Install it using pip:</p> <pre><code>pip install phaseportrait\n</code></pre> <p>Installing from source:</p> <p>Open a terminal on desired route and type the following:</p> <pre><code>git clone https://github.com/phaseportrait/phaseportrait\n</code></pre> <p>Manual installation</p> <p>Visit phase-portrait webpage on GitHub. Click on green button saying Code, and download it in zip format. Save and unzip on desired directory.</p>"},{"location":"license/","title":"MIT License","text":"<p>Copyright (c) 2021 V\u00edctor Loras &amp; Unai Ler\u00eda</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/legacy/cobweb/","title":"Cobweb","text":"<p>class phaseportrait.Cobweb(dF, initial_position, xrange, *, dF_args={None}, yrange=[], max_steps=100, n_points=100, **kargs)</p> <p>A class used to represent a Cobweb plot and a time series to study the convergence of a 1D map <code>x(t+1) = f(x)</code>.</p>"},{"location":"reference/legacy/cobweb/#parameters","title":"Parameters","text":"<ul> <li> <p>dF : callable</p> <p>A dF type funcion.</p> </li> <li> <p>initial_position : float</p> <p>Initial x of the iteration.</p> </li> <li> <p>xrange : list</p> <p>Range of the x axis in the main plot.</p> </li> </ul>"},{"location":"reference/legacy/cobweb/#key-arguments","title":"Key Arguments","text":"<ul> <li> <p>dF_args : dict</p> <p>If necesary, must contain the kargs for the <code>dF</code> funcion.</p> </li> <li> <p>yrange : list</p> <p>Range of the y axis in the main plot</p> </li> <li> <p>max_steps : int, default=100</p> <p>Maximum number of points to be represented.</p> </li> <li> <p>n_points : int, default=10000</p> <p>Number of points in the bisector. </p> </li> <li> <p>Title : str, default='Cobweb plot'</p> <p>Title of the plot.</p> </li> <li> <p>xlabel : str, default=r'$X_{n}$'</p> <p>x label of the plot.</p> </li> <li> <p>ylabel : str, default=r'$X_{n+1}$'</p> <p>y label of the plot.</p> </li> </ul>"},{"location":"reference/legacy/cobweb/#methods","title":"Methods","text":""},{"location":"reference/legacy/cobweb/#cobwebplot","title":"Cobweb.plot","text":"<p>Cobweb.plot(*args, **kargs)</p> <p>Creates two figures, one containing the Cobweb plot and other with the time series.</p> <p>Returns</p> <ul> <li>tuple(matplotlib Figure (Cobweb plot), matplotlib Axis (Cobweb plot), matplotlib Figure (Time series), matplotlib Axis (Time series))</li> </ul>"},{"location":"reference/legacy/cobweb/#cobwebadd_slider","title":"Cobweb.add_slider","text":"<p>Cobweb.add_slider(param_name, *, valinit=None, valstep=0.1, valinterval=10)</p> <p>Adds a slider which can change the value of a parameter in execution time.</p> <p>Parameters</p> <ul> <li>param_name : str     The string key of the variable. Must be the same as the key in the <code>dF</code> function.</li> </ul> <p>Key Arguments</p> <ul> <li> <p>valinit : float, default=None</p> <p>Initial value of the parameter.</p> </li> <li> <p>valinterval : Union[float, list], default=0.1</p> <p>The range of values the slider of the parameter will cover.</p> </li> <li> <p>valstep : float, default=10</p> <p>Precision in the slider.</p> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/cobweb/#cobwebinitial_position_slider","title":"Cobweb.initial_position_slider","text":"<p>Cobweb.initial_position_slider(*, valinit=None, valstep=0.05, valinterval=None)</p> <p>Adds a slider for changing initial value on a cobweb plot.</p> <p>Key Arguments</p> <ul> <li> <p>valinit : float</p> <p>Initial position. Default value is the same as initial position given when initializing Cobweb object.</p> </li> <li> <p>valinterval : Union[float, list]</p> <p>The range of values the slider of the parameter will cover.</p> </li> <li> <p>valstep : float</p> <p>Precision in the slider.</p> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/cobweb/#examples","title":"Examples","text":"<p>Logistic map cobweb plot and time series, defining the logistic map as a 1D dF function. </p> <pre><code>from phaseportrait import Cobweb\n\ndef Logistic(x, *, r=1.5):\n    return r*x*(1-x)\n\n# Cobweb plot and time series.\nLogisticCobweb = Cobweb(Logistic, 0.2, [0,1], dF_args={'r':1.5}, yrange=[0,1])\nLogisticCobweb.add_slider('r', valinit=1.5, valinterval=[0,4])\nLogisticCobweb.initial_position_slider(valstep=0.01)\nLogisticCobweb.plot()\n</code></pre> <p>This will output the following plots:</p> <p></p> <ul> <li>See more Cobweb examples.</li> </ul>"},{"location":"reference/legacy/dFfunction/","title":"dF function","text":"<p>The 'dF' function is refered several times in different implementations of it. It is a function created by the user that describes the system's evolution, either in a 2D phase portrait, a 3d trajectory or the study of a 1D map.</p>"},{"location":"reference/legacy/dFfunction/#kargs","title":"Kargs","text":"<p>Kargs can be given. They can be changed using sliders method.</p> <p>For example, for an harmonic oscillator, the dF function will be defined as:</p> <pre><code>def dFOscillator(x, y, *, \u03c9=1):\n    return y, -\u03c9*\u03c9*x\n</code></pre> <p>Where <code>\u03c9</code> is the angular frequency of the oscillator.</p>"},{"location":"reference/legacy/dFfunction/#general-definiton","title":"General definiton","text":"<p>In general, dF function will be defined the following way:</p> <pre><code>def dF(*args, *, **kargs) -&gt; tuple:\n</code></pre> <p>Where:</p> <pre><code>len(dF(*args, **kargs)) == len(args)\n</code></pre>"},{"location":"reference/legacy/dFfunction/#examples","title":"Examples","text":""},{"location":"reference/legacy/dFfunction/#2d-phase-portrait","title":"2D Phase portrait","text":"<p>When plotting a 2D phase portrait, we have a function f(x,y) that describes the system. The dF function will be constructed by the expressions of the derivatives respect the x and y coordinates, such that:</p> <pre><code>def dF(x,y):\n  return expressionX  ,  expressionY\n</code></pre> <p>It must contain as much args as returned elements.</p>"},{"location":"reference/legacy/dFfunction/#3d-trajectory","title":"3D Trajectory","text":"<p>Let's say we want to see some trajectories on Lorenz's attractor. The dF function will be constructed as a function that returns each of the expressions of the system:</p> <pre><code>def Lorenz(x,y,z,*, s=10, r=28, b=8/3):\n  return -s*x+s*y, -x*z+r*x-y, x*y-b*z\n</code></pre>"},{"location":"reference/legacy/dFfunction/#1d-maps","title":"1D Maps","text":"<p>Let's say we want to study the Logistic Map. The dF function will be constructed by creating a function that returns the evolution of one step in the map:</p> <pre><code>def Logistic(x, *, r=1.5):\n  return r*x*(1-x)\n</code></pre>"},{"location":"reference/legacy/generator/","title":"_Generator_","text":"<p>class phaseportrait.generator_base._Generator_(dF, initial_position, xrange, *, dF_args={None}, yrange=[], max_steps=100, n_points=100, **kargs)</p> <p>This class is used internally in Maps and Trajectories. It is not intended to be used by the user.</p> <p>A class used to generate and save data.</p>"},{"location":"reference/legacy/generator/#parameters","title":"Parameters","text":"<ul> <li> <p>portrait : </p> <p>Class that uses the _Generator_ objects.</p> </li> <li> <p>dF : callable</p> <p>A dF type funcion.</p> </li> <li> <p>dimension : int</p> <p>Number of dimensions in which it calculates the next values. Must equal the amount of outputs the <code>dF</code> funcion gives.</p> </li> <li> <p>max_values : int</p> <p>Max number of values saved.</p> </li> </ul>"},{"location":"reference/legacy/generator/#key-arguments","title":"Key Arguments","text":"<ul> <li> <p>dF_args : dict</p> <p>If necesary, must contain the kargs for the <code>dF</code> funcion. By default, None.</p> </li> <li> <p>initial_values : float, list, optional</p> <p>Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate.</p> </li> <li> <p>thermalization : int, optional</p> <p>Thermalization steps before data is saved, by default None.  If None, thermalization steps are set to 0.</p> </li> </ul>"},{"location":"reference/legacy/generator/#methods-to-be-overwritten","title":"Methods to be overwritten","text":""},{"location":"reference/legacy/generator/#_generator__next","title":"_Generator_._next","text":"<p>_Generator_._next()</p> <p>Generates from <code>self.position</code> its following value</p> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/generator/#_generator_save","title":"_Generator_.save","text":"<p>_Generator_.save()</p> <p>Saves <code>self.position</code> in a convenient way for the type of representation.</p> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/generator/#_generator_clear_values","title":"_Generator_.clear_values","text":"<p>_Generator_.clear_values()</p> <p>Clears the data arrays.</p> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/generator/#_generator__check_limit_cycle","title":"_Generator_._check_limit_cycle","text":"<p>_Generator_._check_limit_cycle(_delta)</p> <p>(Optional) Checks if the trajectory is on a limit cycle.</p> <p>Returns</p> <ul> <li>False</li> <li>int, number of saved points</li> </ul>"},{"location":"reference/legacy/generator/#methods","title":"Methods","text":""},{"location":"reference/legacy/generator/#_generator_compute_all","title":"_Generator_.compute_all","text":"<p>_Generator_.compute_all(*, save_freq=1, limit_cycle_check=False, delta=0.01)</p> <p>Computes <code>_Generator_.max_values</code> and saves them.</p> <p>Key Arguments</p> <ul> <li> <p>save_freq : int, optional, by default 1</p> <p>Number of values computed before saving them.</p> </li> <li> <p>limit_cycle_check : int, optional, by default False</p> <p>Number of points before checking for limit cycles.</p> </li> <li> <p>delta : float, optional, by default 0.01</p> <p>Diference between two values to be considerated equal. </p> </li> </ul> <p>Returns</p> <ul> <li> <p>Numpy.ndarray</p> <p>Saved data with size: [<code>_Generator_.dimension</code>, <code>_Generator_.max_values</code>]</p> </li> </ul>"},{"location":"reference/legacy/generator/#_generator__create_values_array","title":"_Generator_._create_values_array","text":"<p>_Generator_._create_values_array(*, max_values: int = None)</p> <p>Creates an array for storaging the values.</p> <p>Key Arguments</p> <ul> <li> <p>max_values : int, optional, by default None</p> <p>Max size of the arrays.</p> </li> </ul> <p>Returns</p> <ul> <li> <p>Numpy.ndarray</p> <p>Empty array with size <code>dimension*max_values</code></p> </li> </ul>"},{"location":"reference/legacy/generator/#_generator_nnext","title":"_Generator_.Nnext","text":"<p>_Generator_.Nnext(number, *, save_freq=1, limit_cycle_check=False, delta=0.001)</p> <p>Computes next <code>number</code> pairs of position and velocity values and saves them.</p> <p>Parameters</p> <ul> <li> <p>number : int</p> <p>Number of pairs of values saved.</p> </li> </ul> <p>Key Arguments</p> <ul> <li> <p>delta : float, optional</p> <p>Difference between numbers to be considerated equal. Only if <code>limit_cycle_check=True</code>.</p> </li> <li> <p>save_freq : int, optional, by default 1</p> <p>Number of values computed before saving them.</p> </li> <li> <p>limit_cycle_check : bool, optional, by default False</p> <p>Whenever to look for limit cycles.</p> </li> </ul> <p>Returns</p> <ul> <li> <p>int, optional</p> <p>Only if limit_cycle_check is <code>True</code>. It returns the number of points calculated.</p> </li> </ul>"},{"location":"reference/legacy/generator/#_generator_next","title":"_Generator_.next","text":"<p>_Generator_.next(*, index=1)</p> <p>Computes the next usable pair of values and saves them.</p> <p>Parameters</p> <ul> <li> <p>index : int, optional, by default 1</p> <p>Where to save the pair of values.</p> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/generator/#examples","title":"Examples","text":"<p>This class is implemented in other classes, such as:</p> <ul> <li>Map</li> <li>RungeKutta</li> </ul>"},{"location":"reference/legacy/map/","title":"Map","text":"<p>class phaseportrait.maps.Map(portrait, dF, dimension, max_values, *, dt=0.1, dF_args=None, initial_values=None, thermalization=0)</p> <p>This class is used internally in Map1D. It is not intended to be used by the user.</p> <p>This class is an implementation of _Generator_ for maps generators.</p>"},{"location":"reference/legacy/map/#parameters","title":"Parameters","text":"<ul> <li> <p>portrait : </p> <p>Class that uses the Map objects.</p> </li> <li> <p>dF : callable</p> <p>A dF type funcion.</p> </li> <li> <p>dimension : int</p> <p>Number of dimensions in which it calculates the next values. Must equal the amount of outputs the <code>dF</code> funcion gives.</p> </li> <li> <p>max_values : int</p> <p>Max number of values saved.</p> </li> </ul>"},{"location":"reference/legacy/map/#key-arguments","title":"Key Arguments","text":"<ul> <li> <p>dF_args : dict</p> <p>If necesary, must contain the kargs for the <code>dF</code> funcion. By default, None.</p> </li> <li> <p>initial_values : float, list, optional</p> <p>Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate.</p> </li> <li> <p>thermalization : int, optional</p> <p>Thermalization steps before data is saved, by default None.  If None, thermalization steps are set to 0.</p> </li> </ul>"},{"location":"reference/legacy/map/#overwritten-methods","title":"Overwritten methods","text":""},{"location":"reference/legacy/map/#map_next","title":"map._next","text":"<p>map._next()</p> <p>Generates from <code>self.position</code> its following value. Explicitly:</p> <pre><code>def _next(self):\n    self.position[0] = self.dF(*(self.position), **self.dF_args)\n</code></pre> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/map/#mapsave","title":"map.save","text":"<p>map.save(i)</p> <p>Saves <code>self.position</code> in the attribute <code>self.positions</code>.</p> <p>Parameters</p> <ul> <li> <p>i : int</p> <p>Index in which the data is saved.</p> </li> </ul> <p>Explicitly:</p> <pre><code>def save(self, i):\n    try:\n        self.positions[:, i] = self.position\n    except IndexError:\n        np.concatenate(self.positions, self._create_values_array(), axis=1)\n        self.max_values *= 2\n        self.save(i)\n</code></pre> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/map/#mapclear_values","title":"map.clear_values","text":"<p>map.clear_values()</p> <p>Clears the data arrays <code>self.positions</code>.</p> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/map/#map_check_limit_cycle","title":"map._check_limit_cycle","text":"<p>map._check_limit_cycle()</p> <p>Parameters</p> <ul> <li> <p>delta : float</p> <p>Difference between data values to be considerated equal.</p> </li> </ul> <p>Returns</p> <ul> <li> <p>bool</p> <p>Whenever data reached a limit cylce.</p> </li> </ul>"},{"location":"reference/legacy/map/#methods","title":"Methods","text":""},{"location":"reference/legacy/map/#mapinstance_and_compute_all","title":"map.instance_and_compute_all","text":"<p>map.instance_and_compute_all(portrait, dF, dimension, dF_args, initial_values, max_values, save_freq=1, dt=0.1, thermalization=0)</p> <p>Creates an instance of phase-portrait.trajectories.Map. Computes all the data requested and returns the instance.</p> <p>Parameters</p> <ul> <li> <p>portrait : </p> <p>Class that uses the Map objects.</p> </li> <li> <p>dF : callable</p> <p>A dF type funcion.</p> </li> <li> <p>dimension : int</p> <p>Number of dimensions in which it calculates the next values. Must equal the amount of outputs the <code>dF</code> funcion gives.</p> </li> <li> <p>max_values : int</p> <p>Max number of values saved.</p> </li> <li> <p>dF_args : dict</p> <p>If necesary, must contain the kargs for the <code>dF</code> funcion. By default, None.</p> </li> <li> <p>initial_values : float, list, optional</p> <p>Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat</p> </li> <li> <p>save_freq : int, optional, by default 1</p> <p>Number of values computed before saving them.</p> </li> <li> <p>thermalization : int, optional</p> <p>Thermalization steps before data is saved, by default None.  If None, thermalization steps are set to 0.</p> </li> <li> <p>limit_cycle_check : int, bool, optional, by default False</p> <p>Whenever to check it there os a limit cycle in the data.</p> </li> <li> <p>delta : float, optional, by default 0.01</p> <p>If <code>limit_cycle_check==True</code> is the distance between data elements to be considerated equal.</p> </li> </ul> <p>Returns</p> <ul> <li>phase-portrait.trajectories.Map</li> </ul>"},{"location":"reference/legacy/map/#examples","title":"Examples","text":"<p>This class is implemented in other classes, check out:</p> <ul> <li>Map1D</li> </ul>"},{"location":"reference/legacy/map1d/","title":"Map1D","text":"<p>class phaseportrait.Map1D(dF, x_range, y_range, n_points, *, composition_grade=1, dF_args={}, Title='1D Map', xlabel=r'Control parameter', ylabel=r'$X_{n+1}$', **kargs)</p> <p>Class dedicated to 1 dimensional maps <code>x(t+1) = f(x)</code>.</p>"},{"location":"reference/legacy/map1d/#parameters","title":"Parameters","text":"<ul> <li> <p>dF : callable</p> <p>A dF type function.</p> </li> <li> <p>Range : [x_range, y_range]</p> <p>Ranges of the axis in the main plot.</p> </li> <li> <p>n_points : int</p> <p>Maximum number of points. Not recomended more than 5000.</p> </li> </ul>"},{"location":"reference/legacy/map1d/#key-arguments","title":"Key Arguments","text":"<ul> <li> <p>dF_args : dict</p> <p>If necesary, must contain the kargs for the <code>dF</code> function.</p> </li> <li> <p>composition_grade : int</p> <p>Number of times <code>dF</code> is applied between positions saved.</p> </li> <li> <p>Title : str</p> <p>Title of the plot.</p> </li> <li> <p>xlabel : str</p> <p>x label of the plot.</p> </li> <li> <p>ylabel : str</p> <p>y label of the plot.</p> </li> <li> <p>color : str</p> <p>Matplotlib <code>Cmap</code>.</p> </li> <li> <p>size : float</p> <p>Size of the scattered points.</p> </li> <li> <p>thermalization : int</p> <p>Thermalization steps before points saved.</p> </li> </ul>"},{"location":"reference/legacy/map1d/#methods","title":"Methods","text":""},{"location":"reference/legacy/map1d/#map1dplot_over_variable","title":"Map1D.plot_over_variable","text":"<p>Map1D.plot_over_variable(param_name, valinterval, valstep, *, initial_x=None, limit_cycle_check_first=50, delta_cycle_check=0.0001)</p> <p>Creates every <code>map</code> instance.</p> <p>Parameters</p> <ul> <li> <p>param_name : str</p> <p>Name of the variable. Must be in the <code>dF</code> kargs.</p> </li> <li> <p>valinterval : list</p> <p>Min and max value for the param range.</p> </li> <li> <p>valstep : float</p> <p>Separation between consecutive values in the param range.</p> </li> </ul> <p>Key Arguments</p> <ul> <li> <p>initial_x : float</p> <p>Initial x position of every data series.</p> </li> <li> <p>limit_cycle_check_first : int</p> <p>Number of points saved before checking for repeated elemets.</p> </li> <li> <p>delta_cycle_check : float</p> <p>Diference between two positions to be considerated identical.</p> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/map1d/#map1dupdate_df_args","title":"Map1D.update_dF_args","text":"<p>Map1D.update_dF_args()</p> <p>Updates the internal dF_args attributes to match the sliders.</p>"},{"location":"reference/legacy/map1d/#map1dplot","title":"Map1D.plot","text":"<p>Map1D.plot(*, color=None)</p> <p>Prepares the plots and computes the values.</p> <p>Key Arguments</p> <ul> <li> <p>color : str</p> <p>Matplotlib <code>Cmap</code>.</p> </li> </ul> <p>Returns</p> <ul> <li>tuple(matplotlib Figure, matplotlib Axis)</li> </ul>"},{"location":"reference/legacy/map1d/#map1dadd_slider","title":"Map1D.add_slider","text":"<p>Map1D.add_slider(param_name, *, valinit=None, valstep=0.1, valinterval=10)</p> <p>Adds a <code>Slider</code> for the <code>dF</code> function.</p> <p>Parameters</p> <ul> <li> <p>param_name : str</p> <p>Name of the variable. Must be in the <code>dF</code> kargs of the <code>Map1D.dF</code>function.</p> </li> </ul> <p>Key Arguments</p> <ul> <li> <p>valinit : float, defautl=None</p> <p>Initial position of the Slider</p> </li> <li> <p>valinterval : Union[float,list], default=10</p> <p>Min and max value for the param range.</p> </li> <li> <p>valstep : float, default=0.1</p> <p>Separation between consecutive values in the param range.</p> </li> </ul>"},{"location":"reference/legacy/map1d/#map1dplot_trajectory","title":"Map1D.plot_trajectory","text":"<p>Map1D.plot_trajectory(n_points, *, dF_args=None, initial_x=None, color='b', save_freq=1, thermalization=0)</p> <p>Creates a <code>map</code> instance and computes it's positions.</p> <p>Parameters</p> <ul> <li> <p>n_points : int</p> <p>Number of points to be calculated.</p> </li> </ul> <p>Key Arguments</p> <ul> <li> <p>dF_args : dict</p> <p>If necesary, must contain the kargs for the <code>dF</code> function. By default takes the dF_args of the <code>Map1D</code> instance.</p> </li> <li> <p>initial_x : float</p> <p>Initial position of the trajectory.</p> </li> <li> <p>color : str</p> <p>String  matplotlib color identifier.</p> </li> <li> <p>save_freq : int</p> <p>Number of times <code>dF</code> is aplied before a position is saved.</p> </li> <li> <p>thermalization : int</p> <p>Thermalization steps before points saved.</p> </li> </ul> <p>Returns</p> <ul> <li>tuple: <code>(matplotlib.pyplot.figure, matplotlib.pyplot.Axis)</code></li> </ul>"},{"location":"reference/legacy/map1d/#examples","title":"Examples","text":""},{"location":"reference/legacy/map1d/#logistic-map","title":"Logistic map","text":"<p>Let's represent the Logistic map over the control parameter r, in the range <code>[2, 3.9]</code>, with an interval of <code>0.005</code>.</p> <pre><code>def Logistic(x, *, r=1.5):\n    return r*x*(1-x)\n\nLogistic_Map = Map1D(Logistic, [2,3.9], [0,1], 2000, thermalization=200, size=0.1)\n\n# We add a limit cycle check because until r=3.5 there is not need of storing 2000 equal points for every r.\n\nLogistic_Map.plot_over_variable('r', [2,3.9], 0.005, \n    limit_cycle_check_first=300, delta_cycle_check=0.01\n    )\n\nfig, ax = Logistic_Map.plot()\n</code></pre> <p></p> <ul> <li>See more Map1D examples.</li> </ul>"},{"location":"reference/legacy/mapsandcobweb_examples/","title":"Cobweb plots","text":""},{"location":"reference/legacy/mapsandcobweb_examples/#logistic-map","title":"Logistic map","text":"<p>Let's say we want to investigate the qualitative behavior of the logistic map using a cobweb plot to infer the long term status of an initial condition under repeated application of the map.</p> <p>Cobweb class takes 3 arguments:</p> <ul> <li> <p>dF : In our case, the logistic map.</p> </li> <li> <p>initial_position : initial condition to study.</p> </li> <li> <p>xrange : range of representation in the x axis.</p> </li> </ul> <p>An interesting optional argument is <code>max_steps</code>, which indicates the number of iterations of the map. Its default value is <code>100</code>, which is more than enough, but you can change it if you want. </p> <p>We can also restrict the yrange by using <code>yrange</code> kwarg, as we know the output will be in the range [0,1]. If not included, the yrange is <code>1.10</code> times the maximum and minimum, ergo, [1.10 \u00d7 min, 1.10 \u00d7 max].</p> <p>Plot method also yields a time series plot, which shows explicitly the values taken, and it returns the two figures and axes (first cobweb plot, then time series). We get two birds with one stone.</p> <p>Let's see what output we get:</p> <pre><code>from phaseportrait import Cobweb\n\ndef Logistic(x, *, r=3.2):\n    return r*x*(1-x)\n\nLogisticCobweb = Cobweb(Logistic, 0.1, [0,1], yrange=[0,1])\nfig1, ax1, fig2, ax2 = LogisticCobweb.plot()\n</code></pre> <p></p> <p>We can use returned objects to change plot's properties, such as title, xlabel, ylabel... We can also pass <code>Title</code>, <code>xlabel</code> and <code>ylabel</code> as key arguments when creating the Cobweb object instance for changing the cobweb plot's labels, but not the time series plot.</p>"},{"location":"reference/legacy/mapsandcobweb_examples/#adding-sliders","title":"Adding sliders","text":"<p>The point of cobweb plots and time series is to study the behaviour of the map for several values of a parameter and initial conditions. Let's see two methods that will let us change this values in a simple way.</p> <ul> <li>Parameter slider:</li> </ul> <p>Let's say we want to study the logistic map as <code>r</code> control parameter value changes with a cobweb plot. We can use the <code>add_slider</code> method for this purpose. It only takes 1 argument: the parameter's name, in this case <code>r</code>.</p> <p>We can also pass <code>valinit</code> and <code>valinterval</code> kargs for changing the initial value and the interval of variation.</p> <ul> <li>Initial position slider:</li> </ul> <p>Following the same philosophy as the parameter slider, <code>initial_position_slider</code> takes no necessary arguments.</p> <p>Nevertheless, it has 3 optional arguments:</p> <ul> <li>valinit : initial position in the slider. Default value is the same as initial position given when initializing Cobweb object.</li> <li>valinterval : the range of values the slider of the parameter will cover.</li> <li>valstep : precision or step in the slider.</li> </ul> <p>Let's put all in practice with the following example:</p> <pre><code>from phaseportrait import Cobweb\n\ndef Logistic(x, *, r=1.5):\n    return r*x*(1-x)\n\nLogisticCobweb = Cobweb(Logistic, 0.2, [0,1], yrange=[0,1], Title='Logistic map cobweb plot')\n\nLogisticCobweb.add_slider('r', valinit=1.5, valinterval=[0,4])\nLogisticCobweb.initial_position_slider(valstep=0.01)\n\nfig1, ax1, fig2, ax2 = LogisticCobweb.plot()\n\nax2.set_title('Logistic map time series')\n</code></pre> <p></p>"},{"location":"reference/legacy/mapsandcobweb_examples/#map1d-plots","title":"Map1D plots","text":"<p>Complete documentation of Map1D class: here.</p>"},{"location":"reference/legacy/mapsandcobweb_examples/#first-steps","title":"First steps","text":"<p>We are going to plot the Logistic map:</p> <p>Just like Cobweb plots, the first argument is a <code>dF</code> function (dF function documentation). The next required parameters are: * x_range : in this example <code>[2,3.9]</code>. * y_range : in this example <code>[0,1]</code>. * n_points : in this example <code>2000</code>.</p> <p>We want the plot over the control parameter in the range <code>x_range=[2,3.9]</code> with data every <code>0.005</code>:</p> <pre><code>def Logistic(x, *, r=1.5):\n    return r*x*(1-x)\n\nLog1 = Map1D(Logistic, [2,3.9], [0,1], 2000, Title='Logistic Map', xlabel='Control parameter: \"r\"', ylabel=r'$x_{n+1}$', size=1.0)\n\nLog1.plot_over_variable('r', [2,3.9], 0.005)\n\nfig, ax = Log1.plot()\n</code></pre> <p></p> <p>As you can see, this is a mess. That happended because the first steps are not in a stable cycle, and must be deleted.</p>"},{"location":"reference/legacy/mapsandcobweb_examples/#thermalization","title":"Thermalization","text":"<p>Same example, but with 50 steps of thermalization:</p> <pre><code>Log2 = Map1D(Logistic, [2,3.9], [0,1], 2000, thermalization=50, Title='Logistic Map', xlabel='Control parameter: \"r\"', ylabel=r'$x_{n+1}$', color='viridis')\n\nLog2.plot_over_variable('r', [2,3.9], 0.005)\n\nfig, ax = Log2.plot()\n</code></pre> <p></p> <p>Note: in some cases the graph is very dependant of the initial position. In the method <code>plot_over_variable</code> there is a karg for specifying the initial position: <code>plot_over_variable(initial_x=... )</code>.</p>"},{"location":"reference/legacy/mapsandcobweb_examples/#sliders","title":"Sliders","text":"<p>Just like the Cobweb plots you can add sliders so modify in run time some parameters. For instance:</p> <pre><code>def Logistic_power(x, *, r=1.5, p=1):\n    return r*x*(1-x)*(x-p)*(x-p)\n\nLog3 = Map1D(Logistic_power, [2,3.9], [0,1], 2000, thermalization=50)\nLog3.add_slider('p', valinit=1.35, valinterval=[1.3,1.4], valstep=0.005)\nLog3.plot_over_variable('r', [2,3.9], 0.005)\n\nfig, ax = Log3.plot()\n</code></pre> <p></p>"},{"location":"reference/legacy/mapsandcobweb_examples/#time-series","title":"Time series","text":"<p>Additionally, you can also plot a specific trajectory. Although we recommend using Cobweb plots for that:</p> <pre><code>Log4 = Map1D(Logistic_power, [2,3.9], [0,1], 2000, thermalization=50)\nLog4.plot_trajectory(100, dF_args={'r':3.40, 'p':1.35}, initial_x=0.5)\nfig, ax = Log4.plot()\n</code></pre> <p></p>"},{"location":"reference/legacy/mapsandcobweb_examples/#some-more-examples","title":"Some more examples","text":"<p>If you want to take a look to some more plots, we recommend you taking a look to the following file.</p>"},{"location":"reference/legacy/nullclines/","title":"Nullcline2D","text":"<p>class phaseportrait.Nullcline2D(portrait, function, *, precision=0.01, xprecision=None, yprecision=None, offset=0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='b', bgcolor='w', alpha=0)</p> <p>Class dedicated to 2 dimensions phase portraits.  Useful where it is necessary to plot nullclines in a plot.</p> <p>Integrated via method <code>add_nullclines</code> in PhasePortrait2D.</p>"},{"location":"reference/legacy/nullclines/#parameters","title":"Parameters","text":"<ul> <li> <p>portrait : </p> <p>The class that uses Nullcline2D</p> </li> <li> <p>function : callable</p> <p>A <code>dF</code> type funcion.</p> </li> <li> <p>precision : float, optional</p> <p>The minimum diference from <code>offset</code> to be considerated a nullcline, by default 0.01</p> </li> <li> <p>xprecision : float, optional</p> <p>For a different precision value only in the x axis, by default <code>precision</code></p> </li> <li> <p>yprecision : float, optional</p> <p>For a different precision value only in the y axis, by default <code>precision</code></p> </li> <li> <p>offset : float, optional</p> <p>If you want, for instance, a twoclide, by default 0</p> </li> <li> <p>density : int, optional</p> <p>Number of inner divisions on the x axis and y axis, by default 50</p> </li> <li> <p>xRange : Union[float,list], optional</p> <p>The range in which the nullclines are calculated, by default <code>portrait.Range[0]</code></p> </li> <li> <p>yRange : Union[float,list], optional</p> <p>The range in which the nullclines are calculated, by default <code>portrait.Range[1]</code></p> </li> <li> <p>dF_args : dict, optional</p> <p>If necesary, must contain the kargs for the <code>dF</code> funcion, by default None</p> </li> <li> <p>xcolor : str, optional</p> <p>X nullcline color, by default 'r'</p> </li> <li> <p>ycolor : str, optional</p> <p>Y nullcline color, by default 'b'</p> </li> <li> <p>bgcolor : str, optional</p> <p>Background color, by default 'w'</p> </li> <li> <p>alpha : int, optional</p> <p>Opacity of the background, by default 0</p> </li> </ul>"},{"location":"reference/legacy/nullclines/#methods","title":"Methods","text":""},{"location":"reference/legacy/nullclines/#nullcline2dplot","title":"Nullcline2D.plot","text":"<p>Nullcline2D.plot(*, axis=None)</p> <p>Plots the nullclines in the given axis</p> <p>Parameters</p> <ul> <li> <p>axis : matplotlib.Axis, optional</p> <p>The axis in which the nullclines will be represented, by default <code>portrait.ax</code></p> </li> </ul> <p>Returns</p> <ul> <li>[matplotlib.contour.QuadContourSet,matplotlib.contour.QuadContourSet]     X and Y contours.</li> </ul>"},{"location":"reference/legacy/nullclines/#examples","title":"Examples","text":"<pre><code>from phaseportrait import PhasePortrait2D\n\ndef dF(x,y):\n    return x + np.exp(-y), -y\n\nexample = PhasePortrait2D(dF, [[-10,10], [-5, 5]])\nexample.add_nullclines(precision=0.05)\nexample.plot()\n</code></pre>"},{"location":"reference/legacy/phaseportrait2d/","title":"PhasePortrait2D","text":"<p>class phaseportrait.PhasePortrait2D(dF, Range, *, MeshDim=10, dF_args={}, Density=1, Polar=False, **kargs)</p> <p>Gives the option to represent a 2D phase portrait given a dF function with 2 args.</p>"},{"location":"reference/legacy/phaseportrait2d/#parameters","title":"Parameters","text":"<ul> <li> <p>dF : callable</p> <p>A dF type funcion. Computes the derivatives of given coordinates.</p> </li> <li> <p>Range : [x_range, y_range]</p> <p>Ranges of the axis in the main plot. See Defining Range.</p> </li> </ul>"},{"location":"reference/legacy/phaseportrait2d/#key-arguments","title":"Key Arguments","text":"<ul> <li> <p>MeshDim : int, default=500</p> <p>Number of elements in the arrows grid.</p> </li> <li> <p>dF_args : dict</p> <p>If necesary, must contain the kargs for the <code>dF</code> function.</p> </li> <li> <p>Density : float, default=1</p> <p>[Deprecated] Number of elements in the arrows grid plot.</p> </li> <li> <p>Polar : bool, default=False</p> <p>Whether to use polar coordinates or not.</p> </li> <li> <p>Title : str, default='Phase Portrait'</p> <p>Title of the plot.</p> </li> <li> <p>xlabel : str, default='X'</p> <p>x label of the plot.</p> </li> <li> <p>ylabel : str, default='$\\dot{X}$' </p> <p>y label of the plot.</p> </li> <li> <p>color : str, default='rainbow'</p> <p>Matplotlib <code>Cmap</code>.</p> </li> </ul>"},{"location":"reference/legacy/phaseportrait2d/#methods","title":"Methods","text":""},{"location":"reference/legacy/phaseportrait2d/#phaseportrait2dplot","title":"PhasePortrait2D.plot","text":"<p>PhasePortrait2D.plot(*, color=None)</p> <p>Prepares the plots and computes the values.. Color scheme can be changed introducing key argument <code>color</code>. A list with accepted values can be found here. </p> <p>Returns</p> <ul> <li>tuple(matplotlib Figure, matplotlib Axis)</li> </ul>"},{"location":"reference/legacy/phaseportrait2d/#phaseportrait2dadd_slider","title":"PhasePortrait2D.add_slider","text":"<p>PhasePortrait2D.add_slider(param_name, *, valinit=None, valstep=0.1, valinterval=10)</p> <p>Adds a slider which can change the value of a parameter in execution time.</p> <p>Parameters</p> <ul> <li> <p>param_name : str</p> <p>The string key of the variable. Must be the same as the key in the <code>dF</code> function.</p> </li> </ul> <p>Key Arguments</p> <ul> <li> <p>valinit : float, default=None</p> <p>Initial value of the parameter.</p> </li> <li> <p>valinterval : Union[float, list], default=0.1</p> <p>The range of values the slider of the parameter will cover.</p> </li> <li> <p>valstep : float, default=10</p> <p>Precision in the slider.</p> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/phaseportrait2d/#phaseportrait2dadd_nullclines","title":"PhasePortrait2D.add_nullclines","text":"<p>PhasePortrait2D.add_nullclines(*, precision=0.01, offset=0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='g', bgcolor='w', alpha=0)</p> <p>Plots nullclines of the system given by dF function. For more info, see Nullclines class.</p> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/phaseportrait2d/#phaseportrait2dcolorbar","title":"PhasePortrait2D.colorbar","text":"<p>PhasePortrait2D.colorbar(toggle=True)</p> <p>Adds a colorbar for speed.</p> <p>Parameters</p> <ul> <li> <p>toggle : bool, default=True</p> <p>If <code>True</code> colorbar is visible.</p> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/phaseportrait2d/#defining-range","title":"Defining Range","text":"<ol> <li> <p>A single number. In this case the range is defined from zero to the given number in both axes.</p> </li> <li> <p>A range, such <code>[lowerLimit , upperLimit]</code>.  Both axes will take the same limits.</p> </li> <li> <p>Two ranges, such that <code>[[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]]</code></p> </li> </ol>"},{"location":"reference/legacy/phaseportrait2d/#examples","title":"Examples","text":"<pre><code>from phaseportrait import PhasePortrait2D\n\ndef dF(r, \u03b8, *, \u03bc=0.5,\u03b7=0):\n    return \u03bc*r*(1 - r*r), 1+\u03b7*\u03b8\n\n\nexample = PhasePortrait2D(dF, [-3, 3], Density=2, Polar=True, Title='Limit cycle')\nexample.add_slider('\u03bc', valinit=0.5)\nexample.add_slider('\u03b7', valinit=0.0)\nexample.add_nullclines()\nexample.plot()\n</code></pre> <ul> <li>Click here to see more examples.</li> </ul>"},{"location":"reference/legacy/phaseportrait2d_examples/","title":"2D phase portraits","text":""},{"location":"reference/legacy/phaseportrait2d_examples/#first-steps","title":"First steps","text":"<p>In this examples, we will be using PhasePortrait2D class. So, we'll have to import it from phaseportrait module:</p> <pre><code>from phaseportrait import PhasePortrait2D\n</code></pre> <p>Let's take a look to the class. PhasePortrait2D takes 2 args:</p> <ul> <li> <p>dF function : a function that, in this case, returns a tuple, corresponding of the evolution of the 2 coordinates.</p> </li> <li> <p>Range, which can be given as:</p> <ol> <li>A single number. In this case the range is defined from zero to the given number in both axes.</li> <li>A range, such <code>[lowerLimit , upperLimit]</code>. Both axes will take the same limits.</li> <li>Two ranges, such that <code>[[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]]</code></li> </ol> </li> </ul> <p>So, to create an instance of a PhasePortrait2D object, we will have to create a dF function and select a range.</p> <p>For having a simple starting point, let's crate a simple dF function and see the result:</p> <pre><code>def dF_1(x, y):\n    return x, 0\n\nexample1 = PhasePortrait2D(dF_1, [-3, 3])\nfig, ax = example1.plot()\n</code></pre> <p></p> <p>Color shows the speed of the trajectory, as we can see, far away points from (0,0) have a greater velocity. Purple shifted colors show less velocity than red shifted colors in the default color scheme. Color scheme can be changed introducing kwarg color when creating the class instance. A list with accepted values can be found here. Later, we'll do a pair of examples changing the color scheme.</p> <p>Let's explore all options given by PhasePortrait2D class by doing some more examples.</p>"},{"location":"reference/legacy/phaseportrait2d_examples/#title-and-labels","title":"Title and labels","text":"<p>Title and labels of the plot can be changed by calling the corresponding key arguments. For instance, using the dF function created in the first example:</p> <pre><code>example2 = PhasePortrait2D(dF_1, [-3, 3], Title='This is a title', xlabel='This is not a title', ylabel='Neither is this')\nfig, ax = example2.plot()\n</code></pre> <p></p> <p>There is also, another way of doing it, using the ax class methods:</p> <pre><code>example2 = PhasePortrait2D(dF_1, [-3, 3])\nfig, ax = example2.plot()\n\nax.set_title('This is a title')\nax.set_xlabel('This is not a title')\nax.set_ylabel('Neither is this')\n</code></pre> <p>That will yield to the same result.</p> <p>If not specified, default values are:</p> <ul> <li> <p>Title : 'Phase Portrait'</p> </li> <li> <p>xlabel : 'X'</p> </li> <li> <p>ylabel : r'$\\dot{X}$'</p> </li> </ul>"},{"location":"reference/legacy/phaseportrait2d_examples/#latex-in-title-and-labels","title":"LaTeX in Title and labels","text":"<p>Using r strings, LaTeX-like syntax can be used for writing titles and axis labels.</p> <pre><code>example2 = PhasePortrait2D(dF_1, [-3, 3], Title=r'You can use some $\\left[ LaTeX \\right]$ language', xlabel=r'$\\Delta t$', ylabel=r'$\\~{duck}$')\nfig, ax = example2.plot()\n</code></pre> <p></p>"},{"location":"reference/legacy/phaseportrait2d_examples/#polar-and-color","title":"Polar and color","text":"<p>Let's say we want to study the phase portrait of a system which is given in polar coordinates. <code>Polar</code> argument is used in this cases.</p> <pre><code>def dF_polar(x, y):\n    return 0, 1\n\nexample2 = PhasePortrait2D(dF_polar, [-3, 3], Title='Polar plot', xlabel='This is meaningless', ylabel='Why are we here?', Polar=True, color='inferno')\nfig, ax = example2.plot()\n</code></pre> <p></p>"},{"location":"reference/legacy/phaseportrait2d_examples/#density","title":"Density","text":"<p>In order to increase the number of the arrows we modify the <code>Density</code> (by default 1). </p> <p>Be careful, increasing this value speeds down the execution a lot. </p> <p>For this example we will set the density a bit lower and a bit higher than the default value.</p> <pre><code>def circle(x, y):\n    return -y, x\n\nlow_D = PhasePortrait2D(circle, [-3,3], Density=0.5, Title='Density=0.5', xlabel='give you up', ylabel='Never gonna', color='cool')\nfig, ax = low_D.plot()\n\nbig_D = PhasePortrait2D(circle, [-3,3], Density=2, Title='Density=2', xlabel='let you down', ylabel='Never gonna', color='viridis')\nfig, ax = big_D.plot()\n</code></pre> <p> </p>"},{"location":"reference/legacy/phaseportrait2d_examples/#meshdim","title":"MeshDim","text":"<p>In order to create the phase portrait, we create an LxL mesh in which the arrows trajectories are computed. MeshDim inidicates the size of the mesh. </p> <p>Be careful, increasing this value speeds down the execution. </p> <p>It's very important to have a reasonable value for it, as having it too low will give an incorrect representation and giving a high value will be inefficient and expensive computationally. </p> <p>In the following GIF, we've set an example of the evolution of a portrait changing MeshDim's value.</p> <p></p> <p>It can be seen that passed MeshDim = 15, the changes are insignificant to have a global understanding of the behaviour of the system.</p>"},{"location":"reference/legacy/phaseportrait2d_examples/#df_args","title":"dF_args","text":"<p>As said in dF function documentation kargs can be give. Those kargs can be specify via the <code>dF_args</code>, such as follows:</p> <p>In this example the dF function sets <code>\u03bc=0</code> and <code>\u03b7=0.1</code>, although we want <code>\u03bc=1</code> and <code>\u03b7=0.1</code>:</p> <pre><code>def dF_limit_cycle(r, \u03b8, *, \u03bc=0, \u03b7=0):\n    return \u03bc*r*(1 - r*r), 1+\u03b7*\u03b8\n\n\nnot_a_circle = PhasePortrait2D(dF_limit_cycle, [-3, 3], dF_args={'\u03bc':1.0, '\u03b7':0.1}, Polar=True, Title='Never gonna run around', xlabel='X', ylabel='Y')\nfig, ax = not_a_circle.plot()\n</code></pre> <p></p> <ul> <li><code>dF_args</code> must be a dictionary.</li> </ul> <p>This is useful if specific values of the kargs are known, in general, they are not. In those cases we recomend using Sliders.</p>"},{"location":"reference/legacy/phaseportrait2d_examples/#sliders","title":"Sliders","text":"<p>This method allows the user to modify the <code>dF_args</code> in the plot, so it is easier to visualize interesting behaviours.</p> <p>To use them the user must declare the specific name of the karg. Initial value, range of values and step between selectionable consecutive values are optional.</p> <p>For instance, we will slide over the variable <code>\u03bc</code>, with initial value \u03bc=0, in the range <code>\u03bc\u2208[0,1]</code> and distance between consecutive values <code>0.2</code>.</p> <pre><code>slippery_cycle = PhasePortrait2D(dF_limit_cycle, [-3, 3], Polar=True, Title='And slide you', xlabel='X', ylabel='Y')\nslippery_cycle.add_slider('\u03bc', valinit=0, valinterval=[0,1], valstep=0.2)\nfig, ax = slippery_cycle.plot()\n</code></pre> <p></p>"},{"location":"reference/legacy/phaseportrait2d_examples/#nullclines","title":"Nullclines","text":"<p>This method allows the user to plot in the same figure the \"lines\" where the velocity is some specific value (by default 0), in either X or Y axis.</p> <p>For example, we will mark with black where Vx=0 and green Vy=0.</p> <pre><code>def dF_limit_cycle(r, \u03b8, *, \u03bc=0.5,\u03b7=0):\n    return \u03bc*r*(1 - r*r), 1+\u03b7*\u03b8\n\n\nslippery_cycle = PhasePortrait2D(dF_limit_cycle, [-3, 3], Polar=True, Title='You know the nulls and so do I')\nslippery_cycle.add_slider('\u03bc', valinit=0, valinterval=[-1,1], valstep=0.05)\nslippery_cycle.add_nullclines(xcolor='black', ycolor='green')\nslippery_cycle.plot(color='cool')\n</code></pre> <p></p> <p>For more information about nullclines see documentation.</p>"},{"location":"reference/legacy/phaseportrait2d_examples/#more-examples","title":"More examples","text":"<ul> <li>A Jupyter Notebook with more examples, with physical or mathematical background can be found here.</li> </ul>"},{"location":"reference/legacy/phaseportrait3d/","title":"PhasePortrait3D","text":"<p>class phaseportrait.PhasePortrait3D(dF, Range, *, MeshDim=6, dF_args={}, Density=1, Polar=False, **kargs)</p> <p>Gives the option to represent a 3D phase portrait given a dF function with 3 args.</p>"},{"location":"reference/legacy/phaseportrait3d/#parameters","title":"Parameters","text":"<ul> <li> <p>dF : callable</p> <p>A dF type funcion. Computes the derivatives of given coordinates.</p> </li> <li> <p>Range : [x_range, y_range, z_range]</p> <p>Ranges of the axis in the main plot. See Defining Range.</p> </li> </ul>"},{"location":"reference/legacy/phaseportrait3d/#key-arguments","title":"Key Arguments","text":"<ul> <li> <p>MeshDim : int, default=6</p> <p>Lattice side used to make lines not intersect. It has a great impact on performance. We recommend 6~8.</p> </li> <li> <p>dF_args : dict</p> <p>If necesary, must contain the kargs for the <code>dF</code> function.</p> </li> <li> <p>maxLen : int</p> <p>Max number of points in every trajectory.</p> </li> <li> <p>Density : float, default=1</p> <p>[Deprecated] Number of elements in the arrows grid plot.</p> </li> <li> <p>Polar : bool, default=False</p> <p>Whether to use polar (spherical) coordinates or not.</p> </li> <li> <p>Title : str, default='Phase Portrait'</p> <p>Title of the plot.</p> </li> <li> <p>xlabel : str, default='X'</p> <p>x label of the plot.</p> </li> <li> <p>ylabel : str, default='Y' </p> <p>y label of the plot.</p> </li> <li> <p>zlabel : str, default='Z' </p> <p>z label of the plot.</p> </li> <li> <p>color : str, default='rainbow'</p> <p>Matplotlib <code>Cmap</code>.</p> </li> <li> <p>xScale : str, default='linear'</p> <p>X axis scale.</p> </li> <li> <p>yScale : str, default='linear'</p> <p>Y axis scale.</p> </li> <li> <p>zScale : str, default='linear'</p> <p>Z axis scale.</p> </li> </ul>"},{"location":"reference/legacy/phaseportrait3d/#methods","title":"Methods","text":""},{"location":"reference/legacy/phaseportrait3d/#phaseportrait3dplot","title":"PhasePortrait3D.plot","text":"<p>PhasePortrait3D.plot(*, color=None, grid=None)</p> <p>Prepares the plots and computes the values.. Color scheme can be changed introducing key argument <code>color</code>. A list with accepted values can be found here. </p> <p>Returns</p> <ul> <li>tuple(matplotlib Figure, matplotlib Axis)</li> </ul>"},{"location":"reference/legacy/phaseportrait3d/#phaseportrait3dadd_slider","title":"PhasePortrait3D.add_slider","text":"<p>PhasePortrait3D.add_slider(param_name, *, valinit=None, valstep=0.1, valinterval=10)</p> <p>Adds a slider which can change the value of a parameter in execution time.</p> <p>Parameters</p> <ul> <li> <p>param_name : str</p> <p>The string key of the variable. Must be the same as the key in the <code>dF</code> function.</p> </li> </ul> <p>Key Arguments</p> <ul> <li> <p>valinit : float, default=None</p> <p>Initial value of the parameter.</p> </li> <li> <p>valinterval : Union[float, list], default=0.1</p> <p>The range of values the slider of the parameter will cover.</p> </li> <li> <p>valstep : float, default=10</p> <p>Precision in the slider.</p> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/phaseportrait3d/#phaseportrait3dcolorbar","title":"PhasePortrait3D.colorbar","text":"<p>PhasePortrait3D.colorbar(toggle=True)</p> <p>Adds a colorbar for speed.</p> <p>Parameters</p> <ul> <li> <p>toggle : bool, default=True</p> <p>If <code>True</code> colorbar is visible.</p> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/phaseportrait3d/#defining-range","title":"Defining Range","text":"<ol> <li> <p>A range, such <code>[lowerLimit , upperLimit]</code>.  All three axes will take the same limits.</p> </li> <li> <p>Three ranges, such that <code>[[xLowerLimit , xUpperLimit], [yLowerLimit , yUpperLimit], [zLowerLimit , zUpperLimit]]</code></p> </li> </ol>"},{"location":"reference/legacy/phaseportrait3d/#examples","title":"Examples","text":"<pre><code>import matplotlib.pyplot as plt\nimport phaseportrait\n\n# Include streamlines clases to change line styles\nfrom phaseportrait.streamlines import *\n\ndef dF(x,y,z, *, w=1):\n    return -y, x, -z\n\nexample = phaseportrait.PhasePortrait3D(dF, [-3, 3], MeshDim=6, maxLen=2500, deltat=0.1)\n\nexample.add_slider('w')\nexample.Title = \"PhaserPortrait3D\"\n\n# Change from color proportional to speed to wind like plot\n# Default callback is Streamlines_Velocity_Color_Gradient.\n# example.streamplot_callback = Streamlines_Size_Gradient\nexample.plot(color='viridis', grid=True)\nplt.show()\n</code></pre>"},{"location":"reference/legacy/rungekutta/","title":"RungeKutta","text":"<p>class phaseportrait.trajectories.RungeKutta(portrait, dF, dimension, max_values, *, dt=0.1, dF_args=None, initial_values=None, thermalization=0)</p> <p>This class is used internally in Trajectories. It is not intended to be used by the user.</p> <p>This class is an implementation of _Generator_ for a Runge-Kutta 4th order data generator.</p>"},{"location":"reference/legacy/rungekutta/#parameters","title":"Parameters","text":"<ul> <li> <p>portrait : </p> <p>Class that uses the RungeKutta objects.</p> </li> <li> <p>dF : callable</p> <p>A dF type funcion.</p> </li> <li> <p>dimension : int</p> <p>Number of dimensions in which it calculates the next values. Must equal the amount of outputs the <code>dF</code> funcion gives.</p> </li> <li> <p>max_values : int</p> <p>Max number of values saved.</p> </li> </ul>"},{"location":"reference/legacy/rungekutta/#key-arguments","title":"Key Arguments","text":"<ul> <li> <p>dt : double, optional, by default 0.1</p> <p>Time interval used in the Runge-Kutta 4th order method.</p> </li> <li> <p>dF_args : dict</p> <p>If necesary, must contain the kargs for the <code>dF</code> funcion. By default, None.</p> </li> <li> <p>initial_values : float, list, optional</p> <p>Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate.</p> </li> <li> <p>thermalization : int, optional</p> <p>Thermalization steps before data is saved, by default None.  If None, thermalization steps are set to 0.</p> </li> </ul>"},{"location":"reference/legacy/rungekutta/#overwritten-methods","title":"Overwritten methods","text":""},{"location":"reference/legacy/rungekutta/#_generator__next","title":"_Generator_._next","text":"<p>_Generator_._next()</p> <p>Generates from <code>self.position</code> its following value via the Runge-Kutta 4th order method. Explicitly:</p> <pre><code>def _next(self):\n    k1 = np.array(self.dF(*(self.position), **self.dF_args))\n    k2 = np.array(self.dF(*(self.position+0.5*k1*self.dt), **self.dF_args))\n    k3 = np.array(self.dF(*(self.position+0.5*k2*self.dt), **self.dF_args))\n    k4 = np.array(self.dF(*(self.position+k3*self.dt), **self.dF_args))\n    self.velocity = 1/6*(k1+2*k2+2*k3+k4)\n    self.position += self.velocity*self.dt\n</code></pre> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/rungekutta/#_generator_save","title":"_Generator_.save","text":"<p>_Generator_.save(i)</p> <p>Saves <code>self.position</code> in the attribute <code>self.positions</code>, and <code>self.velocity</code> in <code>self.velocities</code>.</p> <p>Parameters</p> <ul> <li> <p>i : int</p> <p>Index in which the data is saved.</p> </li> </ul> <p>Explicitly:</p> <pre><code>def save(self, i):\n    try:\n        self.positions[:, i] = self.position\n        self.velocities[:, i] = self.velocity\n    except IndexError:\n        np.concatenate(self.positions, self._create_values_array(), axis=1)\n        np.concatenate(self.velocities, self._create_values_array(), axis=1)\n        self.max_values += 2000\n        self.save(i)\n</code></pre> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/rungekutta/#_generator_clear_values","title":"_Generator_.clear_values","text":"<p>_Generator_.clear_values()</p> <p>Clears the data arrays <code>self.positions</code> and <code>self.velocities</code>.</p> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/rungekutta/#methods","title":"Methods","text":""},{"location":"reference/legacy/rungekutta/#_generator_instance_and_compute_all","title":"_Generator_.instance_and_compute_all","text":"<p>_Generator_.instance_and_compute_all(portrait, dF, dimension, dF_args, initial_values, max_values, save_freq=1, dt=0.1, thermalization=0)</p> <p>Creates an instance of phase-portrait.trajectories.RungeKutta. Computes all the data requested and returns the instance.</p> <p>Parameters</p> <ul> <li> <p>portrait : </p> <p>Class that uses the RungeKutta objects.</p> </li> <li> <p>dF : callable</p> <p>A dF type funcion.</p> </li> <li> <p>dimension : int</p> <p>Number of dimensions in which it calculates the next values. Must equal the amount of outputs the <code>dF</code> funcion gives.</p> </li> <li> <p>dF_args : dict</p> <p>If necesary, must contain the kargs for the <code>dF</code> funcion. By default, None.</p> </li> <li> <p>initial_values : float, list, optional</p> <p>Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat</p> </li> <li> <p>max_values : int</p> <p>Max number of values saved.</p> </li> <li> <p>save_freq : int, optional, by default 1</p> <p>Number of values computed before saving them.</p> </li> <li> <p>dt : double, by default 0.1</p> <p>Time interval used in the Runge-Kutta 4th order method.</p> </li> <li> <p>thermalization : int, optional</p> <p>Thermalization steps before data is saved, by default None.  If None, thermalization steps are set to 0.</p> </li> </ul> <p>Returns</p> <ul> <li>phase-portrait.trajectories.RungeKutta</li> </ul>"},{"location":"reference/legacy/rungekutta/#examples","title":"Examples","text":"<p>This class is implemented in other classes, check out:</p> <ul> <li>Trajectory</li> </ul>"},{"location":"reference/legacy/slider/","title":"Sliders","text":"<p>class phaseportrait.sliders.Slider(portrait, param_name, valinit=None, valstep=0.1, valinterval=[])</p> <p>This class is not pretended to be used by the user. It is handled by the other objects automatically.</p> <p>Adds a slider which can change the value of a parameter in dF during execution time.</p> <p>Integrated via method <code>add_slider</code> in: * Map1D</p> <ul> <li> <p>Cobweb</p> </li> <li> <p>PhasePortrait2D</p> </li> <li> <p>Trajectory2D</p> </li> <li> <p>Trajectory3D</p> </li> </ul>"},{"location":"reference/legacy/slider/#parameters","title":"Parameters","text":"<ul> <li> <p>portrait : </p> <p>Class that uses the Slider.</p> </li> <li> <p>param_name : str</p> <p>Name of the parameter to slide over.</p> </li> <li> <p>valinit : float</p> <p>Initial value of the parameter in the slider.</p> </li> <li> <p>valsetp : float, default=0.1</p> <p>Precision of the slider.</p> </li> <li> <p>valinterval : Union[float, list]</p> <p>Parameter range in the slider. Default value is <code>[-10, 10]</code> </p> </li> </ul>"},{"location":"reference/legacy/slider/#methods","title":"Methods","text":""},{"location":"reference/legacy/slider/#slider__call__","title":"Slider.__call__","text":"<p>method __call__(value)</p> <p>Updates internal dF_args and replots the graphs.</p> <p>Arguments</p> <ul> <li> <p>value : float</p> <p>New value for the parameter of the slider</p> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/slider/#examples","title":"Examples","text":"<p>Slider is implemented in several classes via add_slider method (tipically), check out:</p> <ul> <li>Cobweb</li> <li>Map1D</li> <li>PhasePortrait2D</li> <li>Trajectory2D</li> <li>Trajectory3D</li> </ul>"},{"location":"reference/legacy/streamlines_base/","title":"Streamlines_base2D","text":"<p>class phaseportrait.streamlines.Streamlines_base2D(dF, X, Y, maxLen=500, deltat=0.01, , dF_args=None, polar=False, density=1, scypi_odeint=False, **kargs*)</p> <p>Compute a set of streamlines given velocity function <code>dF</code>.</p>"},{"location":"reference/legacy/streamlines_base/#parameters","title":"Parameters","text":"<ul> <li> <p>dF : callable</p> <p>A dF type funcion. Computes the derivatives of given coordinates.</p> </li> <li> <p>X and Y : 1D or 2D arrays</p> <p>Arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.</p> </li> <li> <p>maxLen : int, default=500</p> <p>The maximum length of an individual streamline segment.</p> </li> <li> <p>polar : bool, default=false</p> <p>Whether to use polar coordinates or not.</p> </li> <li> <p>density : int, default=1</p> <p>Density of mask grid. Used for making the stream lines not collide.</p> </li> <li> <p>scypi_odeint : bool, default=False</p> <p>Use scipy.odeint for integration. If <code>False</code> Runge-Kutta 3rd order is used.</p> </li> </ul>"},{"location":"reference/legacy/streamlines_base/#key-arguments","title":"Key Arguments","text":"<pre><code>    --------\n    dF_args: dict|None, default=None\n        dF_args of `dF` function.\n</code></pre>"},{"location":"reference/legacy/streamlines_base/#streamlines_based3","title":"Streamlines_baseD3","text":"<p>class phaseportrait.streamlines.Streamlines_baseD3(dF, X, Y, Z, maxLen=500, deltat=0.01, , dF_args=None, polar=False, density=1, scypi_odeint=False, **kargs*)</p> <p>Compute a set of streamlines given velocity function <code>dF</code>.</p>"},{"location":"reference/legacy/streamlines_base/#parameters_1","title":"Parameters","text":"<ul> <li> <p>dF : callable</p> <p>A dF type funcion. Computes the derivatives of given coordinates.</p> </li> <li> <p>X, Y and Z : 1D or 2D arrays</p> <p>Arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.</p> </li> <li> <p>maxLen : int, default=500</p> <p>The maximum length of an individual streamline segment.</p> </li> <li> <p>polar : bool, default=false</p> <p>Whether to use polar coordinates or not.</p> </li> <li> <p>density : int, default=1</p> <p>Density of mask grid. Used for making the stream lines not collide.</p> </li> <li> <p>scypi_odeint : bool, default=False</p> <p>Use scipy.odeint for integration. If <code>False</code> Runge-Kutta 3rd order is used.</p> </li> </ul>"},{"location":"reference/legacy/streamlines_base/#key-arguments_1","title":"Key Arguments","text":"<pre><code>    --------\n    dF_args: dict|None, default=None\n        dF_args of `dF` function.\n</code></pre>"},{"location":"reference/legacy/trajectories_examples/","title":"2D & 3D trajectories","text":""},{"location":"reference/legacy/trajectories_examples/#first-steps","title":"First steps","text":"<p>In this examples, we will be using Trajectory2D and Trajectory3D classes. So, we'll have to import them from phaseportrait module:</p> <pre><code>from phaseportrait import Trajectory2D, Trajectory3D\n</code></pre> <p>Both classes take 1 necessary argument:</p> <ul> <li>dF function : a function that, in this case, returns a tuple, corresponding of the evolution of the 2/3 coordinates.</li> </ul>"},{"location":"reference/legacy/trajectories_examples/#trajectory2d","title":"Trajectory2D","text":"<p>Let's start with an easy example: just a circle.</p> <p>In order to compute the trajectory you need the amount of points <code>n_points</code>, the function <code>dF</code>, and initial position <code>initial_position(x,y)</code>. In a circle it should look something like this:</p> <pre><code>def dF(x,y):\n    return -y, x\n\ncircle = Trajectory2D(dF, n_points=628, size=2)\ncircle.initial_position(1,0)\n\ncircle.plot()\n</code></pre> <p></p>"},{"location":"reference/legacy/trajectories_examples/#multiple-trajectories","title":"Multiple trajectories","text":"<p>Just add more initial positions:</p> <pre><code>circles = Trajectory2D(dF, n_points=628, size=2)\ncircles.initial_position(1,0)\ncircles.initial_position(0,2)\ncircles.initial_position(-3,0)\n\ncircles.plot()\n</code></pre> <p></p> <p>If you want to diferenciate between multiple trajectories use karg <code>lines=True</code>, as in the following:</p> <pre><code>def Lorenz(x,y,z,*, s=10, r=28, b=8/3):\n        return -s*x+s*y, -x*z+r*x-y, x*y-b*z\n\nchaos = Trajectory3D(Lorenz, lines=True, n_points=1300, mark_start_position=True, size=3, Title='Nearby IC on Lorenz attractor')\nchaos.initial_position(10,10,10)\nchaos.initial_position(10,10,10.0001)\nchaos.plot()\n</code></pre> <p></p>"},{"location":"reference/legacy/trajectories_examples/#ranges-title-labels-and-colormaps","title":"Ranges, title, labels and colormaps","text":"<p>Ranges can be defined in several ways.</p> <ol> <li> <p>A single number. In this case the range is defined from zero to the given number in all axes.</p> </li> <li> <p>A range, such <code>[lowerLimit , upperLimit]</code>. All axes will take the same limits.</p> </li> <li> <p>Three ranges, such that <code>[[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit], [zAxisLowerLimit , zAxisUpperLimit]]</code></p> </li> </ol> <p>Title and labels with the kargs: <code>Title</code>, <code>xlabel</code>, <code>ylabel</code> and <code>zlabel</code>. For example:</p> <pre><code>def dF(x,y, *, w=2):\n    return -y, w*x\n\nexample = Trajectory2D(dF, n_points=628, Range=[[-1,1],[-3,3]], size=2, Title='This is an ellipse', xlabel='This the X label', ylabel='This is the Y label')\nexample.initial_position(1,0)\n\nexample.plot()\n</code></pre> <p></p> <p>Colormap expresses the velocity of the trajectory, it can be changed with <code>color</code> kwarg. Default colormap is <code>'viridis'</code>, in which purple-shifted colors indicate less velocity than yellow-shifted colors. A list with accepted values can be found here. </p> <p>An also valid value is <code>t</code>, which will represent the colors as the evolution in time of the trajectory, according to <code>viridis</code> cmap. Using karg <code>color</code> when calling plot method permits changing the colormap to another.</p>"},{"location":"reference/legacy/trajectories_examples/#numba","title":"Numba","text":"<p>Numba can be used to compute trajectories. To use it, give <code>numba=True</code> as kwarg. When using Numba, <code>dF_args</code> karg is compulsory. For instance:</p> <pre><code>def Lorenz(x,y,z,*, s=10, r=28, b=8/3):\n    return -s*x+s*y, -x*z+r*x-y, x*y-b*z\n\nLorentz_plot = Trajectory3D(Lorenz, dF_args={'s':10, 'r':28, 'b':8/3}, color='t', n_points=4000, numba=True, size=2, Title='Lorenz attractor')\nLorentz_plot.initial_position(10,10,10)\nLorentz_plot.plot()\n</code></pre> <p></p>"},{"location":"reference/legacy/trajectories_examples/#thermalization","title":"Thermalization","text":"<p>If you want to see an attractor you should discard the initial points. In order to do that use karg <code>thermalization=N</code> where N is the number of points calculated and rejected. Just like this:</p> <pre><code>def Halvorsen(x,y,z, *, s=1.4):\n    delta = (3*s+15)\n    return -s*x + 2*y - 4*z - y**2 + delta , -s*y + 2*z - 4*x - z**2 + delta, -s*z + 2*x - 4*y - x**2 + delta\n\nattractor1 = Trajectory3D(Halvorsen, dF_args={'s':1.4}, n_points=10000, thermalization=500, numba=True, size=2, Title='Halvorsen attractor')\nattractor1.initial_position(0,5,10)\nattractor1.plot(color='inferno')\n</code></pre> <p>Or you can use the method <code>thermalize</code>, then the initial position taken will be random.</p> <pre><code>def Halvorsen(x,y,z, *, s=1.4):\n    delta = (3*s+15)\n    return -s*x + 2*y - 4*z - y**2 + delta , -s*y + 2*z - 4*x - z**2 + delta, -s*z + 2*x - 4*y - x**2 + delta\n\nattractor1 = Trajectory3D(Halvorsen, dF_args={'s':1.4}, n_points=10000, numba=True, size=2, Title='Halvorsen attractor')\nattractor1.thermalize(thermalization_steps=1000)\nattractor1.plot(color='inferno')\n</code></pre> <p></p>"},{"location":"reference/legacy/trajectories_examples/#sliders","title":"Sliders","text":"<p>This method allows the user to modify the <code>dF_args</code> in the plot, so it is easier to visualize interesting behaviours.</p> <p>To use them the user must declare the specific name of the karg. Initial value, range of values and step between selectionable consecutive values are optional. </p> <pre><code>def Aizawa(x,y,z,*, a=0.95, b=0.7, c=0.6, d=3.5, e=0.25, f=0.1):\n    return (z-b)*x - d*y, d*x + (z-b)*y, c + a*z - z*z*z/3 - (x*x + y*y) * (1 + e*z) + f*z*x*x*x\n\nattractor2 = Trajectory3D(Aizawa, n_points=10000, size=1, thermalization=2000, Title='Aizawa attractor')\nattractor2.thermalize()\nattractor2.add_slider('a', valinit=0.95, valinterval=[0,1], valstep=0.005)\nattractor2.add_slider('b', valinit=0.7, valinterval=[0,1], valstep=0.005)\nattractor2.add_slider('c', valinit=0.6, valinterval=[0,1], valstep=0.005)\nattractor2.add_slider('d', valinit=3.5, valinterval=[0,4], valstep=0.05)\nattractor2.add_slider('e', valinit=0.24, valinterval=[0,1], valstep=0.005)\nattractor2.add_slider('f', valinit=0.1, valinterval=[0,1], valstep=0.005)\nattractor2.plot()\n</code></pre> <p></p> <p>We've taken a look to the most important arguments in order to visualize trajectories. Nevertheless, trajectory classes have more features that can be seen by taking a look into the docs:</p> <ul> <li>Trajectory2D</li> <li>Trajectory3D</li> <li>trajectory</li> </ul>"},{"location":"reference/legacy/trajectories_examples/#some-more-examples","title":"Some more examples","text":"<p>If you want to take a look to some more 'elaborated' plots, we recommend you taking a look to the following file, in which you cand find several famous chaotic attractors.</p>"},{"location":"reference/legacy/trajectory/","title":"Trajectory","text":"<p>class phaseportrait.trajectories.trajectory(dF, dimension, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **karg)</p> <p>This class is not meant to be used by the user.</p> <p>Parent class for trajectory2d and trajectory3d. Represents trajectories given a dF function with N args.</p> <p>Class inheriting must have the following methods:</p> <ul> <li> <p>def _prepare_plot(self): ...</p> <p>Prepares the plots: axis titles, graph title, grid, etc.</p> </li> <li> <p>def _plot_lines(self, val, val_init): ...</p> <p>Plots a line of points given in a tuple of positions <code>val</code> and an initial position <code>val_init</code>, both N-dimensional.</p> </li> <li> <p>def _scatter_start_point(self, val_init): ...</p> <p>Marks starting position <code>val_init</code> (N-dimensional) in the several plots created. </p> </li> <li> <p>def _scatter_trajectory(self, val, color, cmap): ...</p> <p>Plots with points <code>val</code> (N-dimensional list) according to <code>color</code> (N-dimensional) with <code>cmap</code> color map.</p> </li> </ul>"},{"location":"reference/legacy/trajectory/#methods","title":"Methods","text":""},{"location":"reference/legacy/trajectory/#trajectorythermalize","title":"trajectory.thermalize","text":"<p>trajectory.thermalize(*, thermalization_steps=200)</p> <p>Sets the thermalization steps if given and executes self.initial_position method.</p> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/trajectory/#trajectoryinitial_position","title":"trajectory.initial_position","text":"<p>trajectory.initial_position(*position)</p> <p>Adds a initial position for the computation. More than one can be added.</p> <p>Parameters</p> <ul> <li> <p>position : Union[float, list[2], list[3]], optional</p> <p>Initial position for the computation. If None, a random position is chosen.</p> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/trajectory/#trajectoryinitial_positions","title":"trajectory.initial_positions","text":"<p>trajectory.initial_positions(*positions)</p> <p>Adds initial positions for the computation.</p> <p>Parameters</p> <ul> <li> <p>positions : list, optional</p> <p>Initial positiond for the computation. Must be iterable.</p> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/trajectory/#trajectoryplot","title":"trajectory.plot","text":"<p>trajectory.plot()</p> <p>Prepares the plots and computes the values.</p> <p>Key Arguments</p> <ul> <li> <p>color : str</p> <p>Matplotlib <code>Cmap</code>. If given <code>'t'</code> value, color follows the temporal evolution of the trajectory.  </p> </li> </ul> <p>Returns</p> <ul> <li> <p>tuple(matplotlib Figure, matplotlib Axis)</p> </li> <li> <p>None (if attribute <code>fig</code> or <code>ax</code> is not found)</p> </li> </ul>"},{"location":"reference/legacy/trajectory/#trajectoryadd_slider","title":"trajectory.add_slider","text":"<p>trajectory.add_slider(param_name, *, valinit=None, valstep=0.1, valinterval=10)</p> <p>Adds a slider which can change the value of a parameter in execution time.</p> <p>Parameters</p> <ul> <li> <p>param_name : str</p> <p>The string key of the variable. Must be the same as the key in the <code>dF</code> function.</p> </li> </ul> <p>Key Arguments</p> <ul> <li> <p>valinit : float, default=None</p> <p>Initial value of the parameter.</p> </li> <li> <p>valinterval : Union[float, list], default=0.1</p> <p>The range of values the slider of the parameter will cover.</p> </li> <li> <p>valstep : float, default=10</p> <p>Precision in the slider.</p> </li> </ul> <p>Returns</p> <ul> <li>None</li> </ul>"},{"location":"reference/legacy/trajectory/#examples","title":"Examples","text":"<p>This class is implemented in other classes, check out:</p> <ul> <li>Trajectory2D</li> <li>Trajectory3D</li> </ul>"},{"location":"reference/legacy/trajectory2d/","title":"Trajectory2D","text":"<p>class phaseportrait.Trajectory2D(dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs)</p> <p>Inherits from parent class trajectory.</p> <p>Computes a trajectory on a 2D system given a dF function consisting of 2 args.</p>"},{"location":"reference/legacy/trajectory2d/#parameters","title":"Parameters","text":"<ul> <li> <p>dF : callable</p> <p>A dF type function.</p> </li> </ul>"},{"location":"reference/legacy/trajectory2d/#key-arguments","title":"Key Arguments","text":"<ul> <li> <p>Range : list</p> <p>Ranges if the axis in the main plot, by default None. See Defining Range.</p> </li> <li> <p>dF_args : dict</p> <p>If necesary, must contain the kargs for the <code>dF</code> function, by default {}</p> </li> <li> <p>n_points : int</p> <p>Maximum number of points to be calculated and represented, by default 10000</p> </li> <li> <p>runge_kutta_step : float</p> <p>Step of 'time' in the Runge-Kutta method, by default 0.01</p> </li> <li> <p>runge_kutta_freq : int</p> <p>Number of times <code>dF</code> is aplied between positions saved, by default 1</p> </li> <li> <p>xlabel : str</p> <p>x label of the plot, by default 'X'</p> </li> <li> <p>ylabel : str</p> <p>y label of the plot, by default 'Y'</p> </li> </ul>"},{"location":"reference/legacy/trajectory2d/#methods","title":"Methods","text":"<p>Inherits methods from parent class trajectory, a brief resume is offered, click on the method to see more information:</p> <ul> <li> <p>thermalize :</p> <p>Adds thermalization steps and random initial position.</p> </li> <li> <p>initial_position :</p> <p>Adds a trajectory with the given initial position.</p> </li> <li> <p>initial_positions :</p> <p>Adds multiple trajectories with the given initial positions.</p> </li> <li> <p>plot : </p> <p>Prepares the plots and computes the values.  Returns the axis and the figure.</p> </li> <li> <p>add_slider :</p> <p>Adds a slider for the dF function.</p> </li> </ul>"},{"location":"reference/legacy/trajectory2d/#defining-range","title":"Defining Range","text":"<ol> <li> <p>A single number. In this case the range is defined from zero to the given number in both axes.</p> </li> <li> <p>A range, such <code>[lowerLimit , upperLimit]</code>.  Both axes will take the same limits.</p> </li> <li> <p>Two ranges, such that <code>[[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]]</code></p> </li> </ol>"},{"location":"reference/legacy/trajectory2d/#examples","title":"Examples","text":"<pre><code>from phaseportrait import Trajectories2D\nimport numpy as np\n\ndef dF(x,y,*, w=1, z=1):\n    return w*np.sin(y*y*y), -z*np.exp(x*x)\n\nexample = Trajectory2D(dF, n_points=1300, size=2, mark_start_position=True, Title='Just an example')\nexample.initial_position(1,1)\nexample.add_slider('w', valinterval=[-1,5])\nexample.add_slider('z', valinterval=[-1,5])\nexample.plot()\nplt.show()\n\n</code></pre>"},{"location":"reference/legacy/trajectory3d/","title":"Trajectory3D","text":"<p>class phaseportrait.Trajectory3D(dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs)</p> <p>Inherits from parent class trajectory.</p> <p>Gives the option to represent 3D trajectories given a dF function with 3 args.</p>"},{"location":"reference/legacy/trajectory3d/#parameters","title":"Parameters","text":"<ul> <li> <p>dF : callable</p> <p>A dF type function.</p> </li> </ul>"},{"location":"reference/legacy/trajectory3d/#key-arguments","title":"Key Arguments","text":"<ul> <li> <p>Range : list</p> <p>Ranges of the axis in the main plot, by default None. See Defining Range.</p> </li> <li> <p>dF_args : dict</p> <p>If necesary, must contain the kargs for the <code>dF</code> function, by default {}</p> </li> <li> <p>n_points : int</p> <p>Maximum number of points to be calculated and represented, by default 10000</p> </li> <li> <p>runge_kutta_step : float</p> <p>Step of 'time' in the Runge-Kutta method, by default 0.01</p> </li> <li> <p>runge_kutta_freq : int</p> <p>Number of times <code>dF</code> is aplied between positions saved, by default 1</p> </li> <li> <p>xlabel : str</p> <p>x label of the plot, by default 'X'</p> </li> <li> <p>ylabel : str</p> <p>y label of the plot, by default 'Y'</p> </li> <li> <p>zlabel : str</p> <p>z label of the plot, by default 'Z'</p> </li> </ul>"},{"location":"reference/legacy/trajectory3d/#methods","title":"Methods","text":"<p>Inherits methods from parent class trajectory, a brief resume is offered, click on the method to see more information:</p> <ul> <li> <p>thermalize :</p> <p>Adds thermalization steps and random initial position.</p> </li> <li> <p>initial_position :</p> <p>Adds a trajectory with the given initial position.</p> </li> <li> <p>initial_positions :</p> <p>Adds multiple trajectories with the given initial positions.</p> </li> <li> <p>plot : </p> <p>Prepares the plots and computes the values.  Returns the axis and the figure.</p> </li> <li> <p>add_slider :</p> <p>Adds a slider for the dF function.</p> </li> </ul>"},{"location":"reference/legacy/trajectory3d/#defining-range","title":"Defining Range","text":"<ol> <li> <p>A single number. In this case the range is defined from zero to the given number in all axes.</p> </li> <li> <p>A range, such <code>[lowerLimit , upperLimit]</code>. All axes will take the same limits.</p> </li> <li> <p>Three ranges, such that <code>[[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit], [zAxisLowerLimit , zAxisUpperLimit]]</code></p> </li> </ol>"},{"location":"reference/legacy/trajectory3d/#examples","title":"Examples","text":""},{"location":"reference/legacy/trajectory3d/#lorentz-attractor-chaos","title":"Lorentz attractor: chaos","text":"<p>Two trajectories with similar initial positions under the influence of Lorentz equations.</p> <pre><code>from phaseportrait import Trajectories3D\n\ndef Lorenz(x,y,z,*, s=10, r=28, b=8/3):\n    return  -s*x+s*y, \n            -x*z+r*x-y, \n            x*y-b*z\n\na = Trajectory3D(\n    Lorenz, \n    lines=True, \n    n_points=1300, \n    size=3, \n    mark_start_position=True, \n    Title='Nearby IC on Lorenz attractor'\n    )\n\na.initial_position(10,10,10)\na.initial_position(10,10,10.0001)\na.plot()\n</code></pre> <p></p>"},{"location":"reference/legacy/trajectory3d/#halvorsen-attractor","title":"Halvorsen attractor","text":"<p>In this example we are interested in seeing the attractor, not trajectories, under the Halvorsen equations.</p> <pre><code>from phaseportrait import Trajectories3D\n\ndef Halvorsen(x,y,z, *, s=1.4):\n    delta = (3*s+15)\n    return  -s*x+2*y-4*z-y**2+delta, \n            -s*y+2*z-4*x-z**2+delta, \n            -s*z+2*x-4*y-x**2+delta\n\nd = Trajectory3D(\n    Halvorsen, \n    dF_args={'s':1.4}, \n    n_points=10000, \n    thermalization=0, \n    numba=True, \n    size=2, \n    mark_start_point=True, \n    Title='Halvorsen attractor'\n    )\n\nd.initial_position(0,5,10)\nd.plot()\n</code></pre> <p></p>"},{"location":"reference/phaseportrait/Cobweb/","title":"Cobweb","text":""},{"location":"reference/phaseportrait/Cobweb/#phaseportrait.Cobweb.Cobweb","title":"<code>Cobweb</code>","text":"<p>A class used to represent a Cobweb plot and a time series to study the convergence of a map.</p>"},{"location":"reference/phaseportrait/Cobweb/#phaseportrait.Cobweb.Cobweb--methods","title":"Methods","text":"<ul> <li>plot : Creates two figures, one containing the Cobweb plot and other with the time series.</li> <li>add_slider : Adds a slider which can change the value of a parameter in execution time.</li> <li>initial_position_slider : Adds a slider for changing initial value on a cobweb plot.</li> </ul> Source code in <code>phaseportrait/Cobweb.py</code> <pre><code>class Cobweb:\n\"\"\"\n    A class used to represent a Cobweb plot and a time series to study the convergence of a map.\n\n    Methods\n    -------\n    * plot : Creates two figures, one containing the Cobweb plot and other with the time series.\n    * add_slider : Adds a slider which can change the value of a parameter in execution time.\n    * initial_position_slider : Adds a slider for changing initial value on a cobweb plot.\n    \"\"\"\n    _name_ = 'Cobweb'\n    def __init__(self, dF, initial_position, xrange, *, dF_args={}, yrange=[], max_steps=100, n_points=10000, **kargs):\n\"\"\"Cobweb\n\n        Args: \n            dF (function) : Map function, which returns value given a point and some parameters.\n            initial_position (float) : Initial position for iterating the map.\n            xrange (float or list) : Range of representation on x axis.\n            dF_args (dict, optional) : Dictionary with parameters for `dF` function.\n            yrange (float or list, optional) : Range of representation on y axis.\n            max_steps (int, optional) : Number of iterations of the map.\n            n_points (int, optional) : Number of points to plot the map.\n            xlabel (str, optional) : x axis label in the plot. Default value is `r'$X_{n}$'`\n            ylabel (str, optional) : y axis label in the plot. Default value is `r'$X_{n+1}$'`\n            Title (str, optional) : title of the plot. Default value is `'Cobweb plot'`.\n        \"\"\"\n        self.dF = dF\n        self.dF_args = dF_args.copy()\n        self.initial_position = initial_position \n        self.xrange = xrange\n\n        self.yrange = yrange\n        self.max_steps = max_steps\n        self.n_points = n_points\n\n        self.Title = kargs['Title'] if kargs.get('Title') else 'Cobweb plot'\n        self.xlabel = kargs['xlabel'] if kargs.get('xlabel') else r'$X_n$'\n        self.ylabel = kargs['ylabel'] if kargs.get('ylabel') else r'$X_{n+1}$'\n\n        figCobweb, axCobweb = plt.subplots()\n        figTimeSeries, axTimeSeries = plt.subplots()\n\n        self.fig = {\n            'Cobweb': figCobweb,\n            'TimeSeries': figTimeSeries\n        }\n        self.ax = {\n            'Cobweb': axCobweb,\n            'TimeSeries': axTimeSeries\n        }\n\n        self.sliders = {}\n        self.sliders_fig = False\n\n\n\n    def _prepare_plot(self, min_value, max_value):\n\"\"\"\n        Internally used method. Sets titles and axis for Cobweb and Time Series plots.\n\n        Args\n            min_value (float): Minimum value of the function in the interval.\n            max_value (float): Maximum value of the function in the interval.\n        \"\"\"\n        self.ax['Cobweb'].set_title(self.Title)\n        self.ax['Cobweb'].set_xlabel(self.xlabel)\n        self.ax['Cobweb'].set_ylabel(self.ylabel)\n\n        if self.yrange==[]:\n            self.ax['Cobweb'].set_ylim(bottom= 1.10*min_value,top=1.10*max_value)\n        else:\n            self.ax['Cobweb'].set_ylim(self.yrange)\n\n        self.ax['Cobweb'].grid()\n\n        self.ax['TimeSeries'].set_title('Time Series')\n        self.ax['TimeSeries'].set_ylabel(r'$x_t$')\n        self.ax['TimeSeries'].set_xlabel('t')\n        self.ax['TimeSeries'].set_ylim(self.xrange)\n        self.ax['TimeSeries'].grid()\n\n\n    def plot(self, *args, **kargs):\n\"\"\"\n        Prepares the plots, compute the values and plots them.\n\n        Returns:\n            (tuple[matplotlib Figure (Cobweb plot), matplotlib Axis (Cobweb plot), matplotlib Figure (Time series), matplotlib Axis (Time series)]):\n        \"\"\"\n        bisector = np.linspace(self.xrange[0], self.xrange[1], self.n_points)\n        func_result = self.dF(bisector, **self.dF_args)\n\n        xTimeSeries = []\n        yTimeSeries = []\n\n        self._prepare_plot(np.min(func_result), np.max(func_result))\n\n        self.ax['Cobweb'].plot(bisector, func_result, 'b')\n        self.ax['Cobweb'].plot(bisector, bisector, \":\", color='grey')\n\n        x, y = self.initial_position, self.dF(self.initial_position, **self.dF_args)\n        self.ax['Cobweb'].plot([x, x], [0, y], ':')\n        self.ax['Cobweb'].scatter(x , 0, color='green')\n\n        xTimeSeries.append(0)\n        yTimeSeries.append(x)\n\n        for i in range(self.max_steps):\n\n            self.ax['Cobweb'].plot([x, y], [y, y], 'k:')\n            self.ax['Cobweb'].plot([y, y], [y, self.dF(y, **self.dF_args)], 'k:')\n\n            x, y = y, self.dF(y, **self.dF_args)\n\n            xTimeSeries.append(i)\n            yTimeSeries.append(x)\n\n            if y&gt;self.xrange[1] or y&lt;self.xrange[0]:\n                print(f'Warning: cobweb plot got out of range and could not compute {self.max_steps} steps.')\n                break\n\n        self.ax['TimeSeries'].scatter(xTimeSeries , yTimeSeries, color='black', s=10)\n        self.ax['TimeSeries'].plot(xTimeSeries , yTimeSeries, ':', color='grey')\n\n        self.fig['Cobweb'].canvas.draw_idle()\n        self.fig['TimeSeries'].canvas.draw_idle()\n\n        return self.fig['Cobweb'], self.ax['TimeSeries'], self.fig['TimeSeries'], self.ax['TimeSeries']\n\n    def _create_sliders_plot(self):\n\"\"\"\n        Internally used method. Checks if there is already a sliders plot. If not, it creates it.\n        \"\"\"\n        if not isinstance(self.sliders_fig, plt.Figure):\n            self.sliders_fig, self.sliders_ax = plt.subplots() \n            self.sliders_ax.set_visible(False)\n\n\n    def add_slider(self, param_name, *, valinit=None, valstep=0.1, valinterval=10):\n\"\"\"\n        Adds a slider on an existing plot.\n\n        Args: \n            param_name (str) : The string key of the variable. Must be the same as the key in the `dF` function.\n            valinit (float) : Initial value of the parameter.\n            valinterval (Union[float, list]) : The range of values the slider of the parameter will cover.\n            valstep (float) : Precision in the slider.\n        \"\"\"\n        self._create_sliders_plot()\n\n        self.sliders.update({param_name: sliders.Slider(self, param_name, valinit=valinit, valstep=valstep, valinterval=valinterval)})\n\n        self.sliders[param_name].slider.on_changed(self.sliders[param_name])\n\n\n    def update_dF_args(self):\n\"\"\"\n        Internally used method. It is used for setting the new values of dF_args and also for initial position.\n\n        It is meant to be called on `call` method in Slider class.\n        \"\"\"\n        for name, slider in self.sliders.items():\n            if slider.value!= None and name!=r'$x_0$':\n                self.dF_args[name] = slider.value \n\n        if self.sliders.get(r'$x_0$'):\n            self.initial_position = self.sliders[r'$x_0$'].value\n\n    def initial_position_slider(self, *, valinit=None, valstep=0.05, valinterval=None):\n\"\"\"\n        Adds a slider for changing initial value on a cobweb plot.\n\n        Args: \n            valinit (float, optional) : Initial position. Default value is the same as initial position given when initializing Cobweb object.\n            valinterval (Union[float, list]) : The range of values the slider of the parameter will cover.\n            valstep (float) : Precision in the slider.\n        \"\"\"\n        if valinit is None:\n            valinit = self.initial_position\n\n        if valinterval is None:\n            valinterval = list(self.xrange)\n\n        self.add_slider(r'$x_0$', valinit=valinit, valstep=valstep, valinterval=valinterval)\n\n\n    @property\n    def dF(self):\n        return self._dF\n\n    @dF.setter\n    def dF(self, func):\n        if not callable(func):\n            raise exceptions.dFNotCallable(func)\n        try:\n            sig = signature(func)\n        except ValueError:\n            pass\n        self._dF = func\n\n    @property\n    def xrange(self):\n        return self._xrange\n\n    @xrange.setter\n    def xrange(self, value):\n        if value == None:\n            self._xrange = None\n            return\n        self._xrange = np.array(utils.construct_interval(value, dim=1))\n\n    @property\n    def yrange(self):\n        return self._yrange\n\n    @yrange.setter\n    def yrange(self, value):\n        if value == []:\n            self._yrange = []\n            return\n        self._yrange = np.array(utils.construct_interval(value, dim=1))\n\n    @property\n    def dF_args(self):\n        return self._dF_args\n\n    @dF_args.setter\n    def dF_args(self, value):\n        if value:\n            if not isinstance(value, dict):\n                raise exceptions.dF_argsInvalid(value)\n        self._dF_args = value\n</code></pre>"},{"location":"reference/phaseportrait/Cobweb/#phaseportrait.Cobweb.Cobweb.__init__","title":"<code>__init__(dF, initial_position, xrange, *, dF_args={}, yrange=[], max_steps=100, n_points=10000, **kargs)</code>","text":"<p>Cobweb</p> <p>Parameters:</p> Name Type Description Default <code>dF</code> <code>function) </code> <p>Map function, which returns value given a point and some parameters.</p> required <code>initial_position</code> <code>float) </code> <p>Initial position for iterating the map.</p> required <code>xrange</code> <code>float or list) </code> <p>Range of representation on x axis.</p> required <code>dF_args</code> <code>dict, optional) </code> <p>Dictionary with parameters for <code>dF</code> function.</p> <code>{}</code> <code>yrange</code> <code>float or list, optional) </code> <p>Range of representation on y axis.</p> <code>[]</code> <code>max_steps</code> <code>int, optional) </code> <p>Number of iterations of the map.</p> <code>100</code> <code>n_points</code> <code>int, optional) </code> <p>Number of points to plot the map.</p> <code>10000</code> <code>xlabel</code> <code>str, optional) </code> <p>x axis label in the plot. Default value is <code>r'$X_{n}$'</code></p> required <code>ylabel</code> <code>str, optional) </code> <p>y axis label in the plot. Default value is <code>r'$X_{n+1}$'</code></p> required <code>Title</code> <code>str, optional) </code> <p>title of the plot. Default value is <code>'Cobweb plot'</code>.</p> required Source code in <code>phaseportrait/Cobweb.py</code> <pre><code>def __init__(self, dF, initial_position, xrange, *, dF_args={}, yrange=[], max_steps=100, n_points=10000, **kargs):\n\"\"\"Cobweb\n\n    Args: \n        dF (function) : Map function, which returns value given a point and some parameters.\n        initial_position (float) : Initial position for iterating the map.\n        xrange (float or list) : Range of representation on x axis.\n        dF_args (dict, optional) : Dictionary with parameters for `dF` function.\n        yrange (float or list, optional) : Range of representation on y axis.\n        max_steps (int, optional) : Number of iterations of the map.\n        n_points (int, optional) : Number of points to plot the map.\n        xlabel (str, optional) : x axis label in the plot. Default value is `r'$X_{n}$'`\n        ylabel (str, optional) : y axis label in the plot. Default value is `r'$X_{n+1}$'`\n        Title (str, optional) : title of the plot. Default value is `'Cobweb plot'`.\n    \"\"\"\n    self.dF = dF\n    self.dF_args = dF_args.copy()\n    self.initial_position = initial_position \n    self.xrange = xrange\n\n    self.yrange = yrange\n    self.max_steps = max_steps\n    self.n_points = n_points\n\n    self.Title = kargs['Title'] if kargs.get('Title') else 'Cobweb plot'\n    self.xlabel = kargs['xlabel'] if kargs.get('xlabel') else r'$X_n$'\n    self.ylabel = kargs['ylabel'] if kargs.get('ylabel') else r'$X_{n+1}$'\n\n    figCobweb, axCobweb = plt.subplots()\n    figTimeSeries, axTimeSeries = plt.subplots()\n\n    self.fig = {\n        'Cobweb': figCobweb,\n        'TimeSeries': figTimeSeries\n    }\n    self.ax = {\n        'Cobweb': axCobweb,\n        'TimeSeries': axTimeSeries\n    }\n\n    self.sliders = {}\n    self.sliders_fig = False\n</code></pre>"},{"location":"reference/phaseportrait/Cobweb/#phaseportrait.Cobweb.Cobweb.add_slider","title":"<code>add_slider(param_name, *, valinit=None, valstep=0.1, valinterval=10)</code>","text":"<p>Adds a slider on an existing plot.</p> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str) </code> <p>The string key of the variable. Must be the same as the key in the <code>dF</code> function.</p> required <code>valinit</code> <code>float) </code> <p>Initial value of the parameter.</p> <code>None</code> <code>valinterval</code> <code>Union[float, list]) </code> <p>The range of values the slider of the parameter will cover.</p> <code>10</code> <code>valstep</code> <code>float) </code> <p>Precision in the slider.</p> <code>0.1</code> Source code in <code>phaseportrait/Cobweb.py</code> <pre><code>def add_slider(self, param_name, *, valinit=None, valstep=0.1, valinterval=10):\n\"\"\"\n    Adds a slider on an existing plot.\n\n    Args: \n        param_name (str) : The string key of the variable. Must be the same as the key in the `dF` function.\n        valinit (float) : Initial value of the parameter.\n        valinterval (Union[float, list]) : The range of values the slider of the parameter will cover.\n        valstep (float) : Precision in the slider.\n    \"\"\"\n    self._create_sliders_plot()\n\n    self.sliders.update({param_name: sliders.Slider(self, param_name, valinit=valinit, valstep=valstep, valinterval=valinterval)})\n\n    self.sliders[param_name].slider.on_changed(self.sliders[param_name])\n</code></pre>"},{"location":"reference/phaseportrait/Cobweb/#phaseportrait.Cobweb.Cobweb.initial_position_slider","title":"<code>initial_position_slider(*, valinit=None, valstep=0.05, valinterval=None)</code>","text":"<p>Adds a slider for changing initial value on a cobweb plot.</p> <p>Parameters:</p> Name Type Description Default <code>valinit</code> <code>float, optional) </code> <p>Initial position. Default value is the same as initial position given when initializing Cobweb object.</p> <code>None</code> <code>valinterval</code> <code>Union[float, list]) </code> <p>The range of values the slider of the parameter will cover.</p> <code>None</code> <code>valstep</code> <code>float) </code> <p>Precision in the slider.</p> <code>0.05</code> Source code in <code>phaseportrait/Cobweb.py</code> <pre><code>def initial_position_slider(self, *, valinit=None, valstep=0.05, valinterval=None):\n\"\"\"\n    Adds a slider for changing initial value on a cobweb plot.\n\n    Args: \n        valinit (float, optional) : Initial position. Default value is the same as initial position given when initializing Cobweb object.\n        valinterval (Union[float, list]) : The range of values the slider of the parameter will cover.\n        valstep (float) : Precision in the slider.\n    \"\"\"\n    if valinit is None:\n        valinit = self.initial_position\n\n    if valinterval is None:\n        valinterval = list(self.xrange)\n\n    self.add_slider(r'$x_0$', valinit=valinit, valstep=valstep, valinterval=valinterval)\n</code></pre>"},{"location":"reference/phaseportrait/Cobweb/#phaseportrait.Cobweb.Cobweb.plot","title":"<code>plot(*args, **kargs)</code>","text":"<p>Prepares the plots, compute the values and plots them.</p> <p>Returns:</p> Type Description <code>tuple[matplotlib Figure (Cobweb plot), matplotlib Axis (Cobweb plot), matplotlib Figure (Time series), matplotlib Axis (Time series)]</code> Source code in <code>phaseportrait/Cobweb.py</code> <pre><code>def plot(self, *args, **kargs):\n\"\"\"\n    Prepares the plots, compute the values and plots them.\n\n    Returns:\n        (tuple[matplotlib Figure (Cobweb plot), matplotlib Axis (Cobweb plot), matplotlib Figure (Time series), matplotlib Axis (Time series)]):\n    \"\"\"\n    bisector = np.linspace(self.xrange[0], self.xrange[1], self.n_points)\n    func_result = self.dF(bisector, **self.dF_args)\n\n    xTimeSeries = []\n    yTimeSeries = []\n\n    self._prepare_plot(np.min(func_result), np.max(func_result))\n\n    self.ax['Cobweb'].plot(bisector, func_result, 'b')\n    self.ax['Cobweb'].plot(bisector, bisector, \":\", color='grey')\n\n    x, y = self.initial_position, self.dF(self.initial_position, **self.dF_args)\n    self.ax['Cobweb'].plot([x, x], [0, y], ':')\n    self.ax['Cobweb'].scatter(x , 0, color='green')\n\n    xTimeSeries.append(0)\n    yTimeSeries.append(x)\n\n    for i in range(self.max_steps):\n\n        self.ax['Cobweb'].plot([x, y], [y, y], 'k:')\n        self.ax['Cobweb'].plot([y, y], [y, self.dF(y, **self.dF_args)], 'k:')\n\n        x, y = y, self.dF(y, **self.dF_args)\n\n        xTimeSeries.append(i)\n        yTimeSeries.append(x)\n\n        if y&gt;self.xrange[1] or y&lt;self.xrange[0]:\n            print(f'Warning: cobweb plot got out of range and could not compute {self.max_steps} steps.')\n            break\n\n    self.ax['TimeSeries'].scatter(xTimeSeries , yTimeSeries, color='black', s=10)\n    self.ax['TimeSeries'].plot(xTimeSeries , yTimeSeries, ':', color='grey')\n\n    self.fig['Cobweb'].canvas.draw_idle()\n    self.fig['TimeSeries'].canvas.draw_idle()\n\n    return self.fig['Cobweb'], self.ax['TimeSeries'], self.fig['TimeSeries'], self.ax['TimeSeries']\n</code></pre>"},{"location":"reference/phaseportrait/Cobweb/#phaseportrait.Cobweb.Cobweb.update_dF_args","title":"<code>update_dF_args()</code>","text":"<p>Internally used method. It is used for setting the new values of dF_args and also for initial position.</p> <p>It is meant to be called on <code>call</code> method in Slider class.</p> Source code in <code>phaseportrait/Cobweb.py</code> <pre><code>def update_dF_args(self):\n\"\"\"\n    Internally used method. It is used for setting the new values of dF_args and also for initial position.\n\n    It is meant to be called on `call` method in Slider class.\n    \"\"\"\n    for name, slider in self.sliders.items():\n        if slider.value!= None and name!=r'$x_0$':\n            self.dF_args[name] = slider.value \n\n    if self.sliders.get(r'$x_0$'):\n        self.initial_position = self.sliders[r'$x_0$'].value\n</code></pre>"},{"location":"reference/phaseportrait/Map1D/","title":"Map1D","text":""},{"location":"reference/phaseportrait/Map1D/#phaseportrait.Map1D.Map1D","title":"<code>Map1D</code>","text":""},{"location":"reference/phaseportrait/Map1D/#phaseportrait.Map1D.Map1D--map1d","title":"Map1D","text":"<p>Class dedicated to 1 dimensional maps <code>x(t+1) = f(x)</code>.</p>"},{"location":"reference/phaseportrait/Map1D/#phaseportrait.Map1D.Map1D--methods","title":"Methods","text":"<ul> <li>plot_over_variable : Creates every <code>map</code> instance.</li> <li>plot_trajectory : Creates a <code>map</code> instance and computes it's positions.</li> <li>add_function : Adds a function to the <code>dF</code> plot.</li> <li>add_slider : Adds a <code>Slider</code> for the <code>dF</code> function.</li> <li>plot : Prepares the plots and computes the values.</li> </ul> Source code in <code>phaseportrait/Map1D.py</code> <pre><code>class Map1D():\n\"\"\"\n    Map1D\n    --------\n    Class dedicated to 1 dimensional maps `x(t+1) = f(x)`.\n\n    Methods\n    -------    \n    * plot_over_variable : Creates every `map` instance.\n    * plot_trajectory : Creates a `map` instance and computes it's positions.\n    * add_function : Adds a function to the `dF` plot.\n    * add_slider : Adds a `Slider` for the `dF` function.\n    * plot : Prepares the plots and computes the values. \n    \"\"\"\n\n    _name_ = 'Map1D'\n\n    def __init__(self, dF, x_range, y_range, n_points, *, composition_grade=1, dF_args={}, Title='1D Map', xlabel=r'Control parameter', ylabel=r'$X_{n+1}$', **kargs):\n\"\"\"\n        Map1D\n        --------\n\n        Args:\n            dF (callable) : A dF type function.\n            Range ([x_range, y_range]) : Ranges of the axis in the main plot.\n            n_points (int) : Maximum number of points\n            dF_args (dict) : If necesary, must contain the kargs for the `dF` function.\n            composition_grade (int) : Number of times `dF` is applied between positions saved.\n            Title (str) : Title of the plot.\n            xlabel (str) : x label of the plot.\n            ylabel (str) : y label of the plot.\n            color (str) : Matplotlib `Cmap`.\n            size (float) : Size of the scattered points.\n            thermalization (int) : Thermalization steps before points saved.\n        \"\"\"\n\n        self.dF_args = dF_args.copy()\n        self.dF = dF\n        self.Range = np.array([x_range, y_range])\n        self.n_points = n_points\n        self.dimension = 1\n\n        self.composition_grade = composition_grade\n\n        self.Title = Title\n        self.xlabel = xlabel\n        self.ylabel = ylabel\n\n        self.fig, self.ax = plt.subplots()\n        self.color = kargs.get('color')\n        if not self.color:\n            self.color = 'inferno'\n\n        self.maps = {}\n\n        self.sliders = {}\n\n        self.functions = []\n\n        self._trajectory = None\n\n        self.size = kargs.get('size')\n        if self.size is None:\n            self.size = 1\n        self.thermalization = kargs.get('thermalization')\n\n        self._initial_x = random.uniform(*self.Range[1])\n\n        self._prepare_plot()\n\n    def _thread_compute_date(self, params):\n        dF_args = self.dF_args.copy()\n        for p in params:\n            dF_args.update({self._param_name: p})\n            self.maps.update({p: Map.instance_and_compute_all(self, self.dF, self.dimension,\n                             self.n_points, dF_args, self._initial_x, thermalization=self.thermalization,\n                             limit_cycle_check=self._limit_cycle_check_first, delta=self._delta_cycle_check, save_freq=self.composition_grade)})\n\n    def _compute_data(self):\n        self._range = np.arange(\n            self._valinterval[0], self._valinterval[1], self._valstep)\n\n        threads_list = []\n        for th in range(8):\n            params = self._range[th::8]\n            t = threading.Thread(target=self._thread_compute_date, args=(params,))\n            t.start()\n            threads_list.append(t)\n\n        for t in threads_list:\n            t.join()\n\n\n    def plot_over_variable(self, param_name, valinterval, valstep, *, initial_x=None, limit_cycle_check_first=50, delta_cycle_check=0.0001):\n\"\"\"\n        Creates every `map` instance.\n\n        Args:\n            param_name (str) : Name of the variable. Must be in the `dF` kargs.\n            valinterval (list) : Min and max value for the param range.\n            valstep (float) : Separation between consecutive values in the param range.\n            initial_x (float) : Initial x position of every data series.\n            limit_cycle_check_first (int) : Number of points saved before checking for repeated elemets.\n            delta_cycle_check (float) : Diference between two positions to be considerated identical.\n        \"\"\"\n\n        self._param_name = param_name\n        self._valinterval = valinterval\n\n        if initial_x is None:\n            initial_x = self._initial_x\n        self._initial_x = initial_x\n\n        self._valstep = valstep\n        self._limit_cycle_check_first = limit_cycle_check_first\n        self._delta_cycle_check = delta_cycle_check\n\n    def _prepare_plot(self):\n        self.ax.set_title(f'{self.Title}')\n        self._cmap = self.color\n        self._colores_norm = plt.Normalize(\n            vmin=self.Range[1][0], vmax=self.Range[1][1])\n        self.ax.set_xlim(*self.Range[0])\n        self.ax.set_ylim(*self.Range[1])\n        try:\n            self.__done\n\n            self.ax.grid()\n\n        except AttributeError:\n            self.__done = None\n\n            self.ax.set_xlabel(self.xlabel)\n            self.ax.set_ylabel(self.ylabel)\n            self.fig.colorbar(matplotlib.cm.ScalarMappable(\n                norm=self._colores_norm, cmap=self._cmap), label=r'$X_{n}$')\n\n\n\n    def update_dF_args(self):\n\"\"\"\n        Updates the internal dF_args attributes to match the sliders.\n        \"\"\"\n        self.dF_args.update({name: slider.value for name, slider in self.sliders.items() if slider.value!= None})\n\n\n    def plot(self, *, color=None):\n\"\"\"\n        Prepares the plots and computes the values.\n\n        Args:\n            color (str) : Matplotlib `Cmap`.\n\n        Returns: \n            (tuple[matplotlib Figure, matplotlib Axis]):\n        \"\"\"\n        for func in self.functions:\n            func.plot()\n\n        self.update_dF_args()\n        self._prepare_plot()\n        self._compute_data()\n\n        if color is not None:\n            self._cmap = color\n\n        for i in self._range:\n            values = self.maps[i].positions\n            color = values[0, 0:-2]\n            range_x = np.zeros(len(color)) + i\n            self.ax.scatter(\n                range_x, values[0, 1:-1],\n                s=self.size, c=color, cmap=self._cmap, norm=self._colores_norm\n            )\n\n        return self.fig, self.ax\n\n\n    def add_slider(self, param_name, *, valinit=None, valstep=0.1, valinterval=10):\n\"\"\"\n        Adds a `Slider` for the `dF` function.\n\n        Args:\n            param_name (str) : Name of the variable. Must be in the `dF` kargs of the `Map1D.dF` function.\n            valinit (float, defautl=None) : Initial position of the Slider\n            valinterval (Union[float,list], default=10) : Min and max value for the param range.\n            valstep (float, default=0.1) : Separation between consecutive values in the param range.\n        \"\"\" \n        self.sliders.update({param_name: Slider(\n            self, param_name, valinit=valinit, valstep=valstep, valinterval=valinterval)})\n\n        self.fig.subplots_adjust(bottom=0.25)\n\n        self.sliders[param_name].slider.on_changed(self.sliders[param_name])\n\n\n    def _prepare_plot_trajectory(self):\n        if self._trajectory is None:\n            self._trajectory = plt.subplots()\n        self._trajectory[1].cla()\n        self._trajectory[1].set_title(f'{self.Title}: {self.xlabel}={self._param_name}')\n        self._trajectory[1].set_ylim(*self.Range[1])\n        self._trajectory[1].set_xlabel('t')\n        self._trajectory[1].set_ylabel(r'$X_{n}$')\n        self._trajectory[1].grid()\n\n\n    def plot_trajectory(self, n_points, *, dF_args=None, initial_x=None, color='b', save_freq=1, thermalization=0):\n\"\"\"\n        Creates a `map` instance and computes it's positions.\n\n        Args:\n            n_points (int) : Number of points to be calculated.\n            dF_args (dict) : If necesary, must contain the kargs for the `dF` function. By default takes the dF_args of the `Map1D` instance.\n            initial_x (float) : Initial position of the trajectory.\n            color (str) : String  matplotlib color identifier.\n            save_freq (int) : Number of times `dF` is aplied before a position is saved.\n            thermalization (int) : Thermalization steps before points saved.\n\n        Returns:\n            (`plt.Figure`, `plt.Axis`):   \n        \"\"\"\n        try:\n            if self._param_name:\n                pass\n        except AttributeError:\n            print('Method plot_over_variable must be executed before.')\n            return\n\n        if dF_args is None:\n            dF_args = self.dF_args\n        if initial_x is None:\n            initial_x = self._initial_x\n\n        self._prepare_plot_trajectory()\n        s_map = Map.instance_and_compute_all(None, self.dF, self.dimension, n_points, dF_args=dF_args, initial_values=initial_x, save_freq=save_freq, thermalization=thermalization)\n        self._trajectory[1].plot(s_map.positions[0], '.-', color=color)\n        return self._trajectory\n</code></pre>"},{"location":"reference/phaseportrait/Map1D/#phaseportrait.Map1D.Map1D.__init__","title":"<code>__init__(dF, x_range, y_range, n_points, *, composition_grade=1, dF_args={}, Title='1D Map', xlabel='Control parameter', ylabel='$X_{n+1}$', **kargs)</code>","text":""},{"location":"reference/phaseportrait/Map1D/#phaseportrait.Map1D.Map1D.__init__--map1d","title":"Map1D","text":"<p>Parameters:</p> Name Type Description Default <code>dF</code> <code>callable) </code> <p>A dF type function.</p> required <code>Range</code> <code>[x_range, y_range]) </code> <p>Ranges of the axis in the main plot.</p> required <code>n_points</code> <code>int) </code> <p>Maximum number of points</p> required <code>dF_args</code> <code>dict) </code> <p>If necesary, must contain the kargs for the <code>dF</code> function.</p> <code>{}</code> <code>composition_grade</code> <code>int) </code> <p>Number of times <code>dF</code> is applied between positions saved.</p> <code>1</code> <code>Title</code> <code>str) </code> <p>Title of the plot.</p> <code>'1D Map'</code> <code>xlabel</code> <code>str) </code> <p>x label of the plot.</p> <code>'Control parameter'</code> <code>ylabel</code> <code>str) </code> <p>y label of the plot.</p> <code>'$X_{n+1}$'</code> <code>color</code> <code>str) </code> <p>Matplotlib <code>Cmap</code>.</p> required <code>size</code> <code>float) </code> <p>Size of the scattered points.</p> required <code>thermalization</code> <code>int) </code> <p>Thermalization steps before points saved.</p> required Source code in <code>phaseportrait/Map1D.py</code> <pre><code>def __init__(self, dF, x_range, y_range, n_points, *, composition_grade=1, dF_args={}, Title='1D Map', xlabel=r'Control parameter', ylabel=r'$X_{n+1}$', **kargs):\n\"\"\"\n    Map1D\n    --------\n\n    Args:\n        dF (callable) : A dF type function.\n        Range ([x_range, y_range]) : Ranges of the axis in the main plot.\n        n_points (int) : Maximum number of points\n        dF_args (dict) : If necesary, must contain the kargs for the `dF` function.\n        composition_grade (int) : Number of times `dF` is applied between positions saved.\n        Title (str) : Title of the plot.\n        xlabel (str) : x label of the plot.\n        ylabel (str) : y label of the plot.\n        color (str) : Matplotlib `Cmap`.\n        size (float) : Size of the scattered points.\n        thermalization (int) : Thermalization steps before points saved.\n    \"\"\"\n\n    self.dF_args = dF_args.copy()\n    self.dF = dF\n    self.Range = np.array([x_range, y_range])\n    self.n_points = n_points\n    self.dimension = 1\n\n    self.composition_grade = composition_grade\n\n    self.Title = Title\n    self.xlabel = xlabel\n    self.ylabel = ylabel\n\n    self.fig, self.ax = plt.subplots()\n    self.color = kargs.get('color')\n    if not self.color:\n        self.color = 'inferno'\n\n    self.maps = {}\n\n    self.sliders = {}\n\n    self.functions = []\n\n    self._trajectory = None\n\n    self.size = kargs.get('size')\n    if self.size is None:\n        self.size = 1\n    self.thermalization = kargs.get('thermalization')\n\n    self._initial_x = random.uniform(*self.Range[1])\n\n    self._prepare_plot()\n</code></pre>"},{"location":"reference/phaseportrait/Map1D/#phaseportrait.Map1D.Map1D.add_slider","title":"<code>add_slider(param_name, *, valinit=None, valstep=0.1, valinterval=10)</code>","text":"<p>Adds a <code>Slider</code> for the <code>dF</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str) </code> <p>Name of the variable. Must be in the <code>dF</code> kargs of the <code>Map1D.dF</code> function.</p> required <code>valinit</code> <code>float, defautl=None) </code> <p>Initial position of the Slider</p> <code>None</code> <code>valinterval</code> <code>Union[float,list], default=10) </code> <p>Min and max value for the param range.</p> <code>10</code> <code>valstep</code> <code>float, default=0.1) </code> <p>Separation between consecutive values in the param range.</p> <code>0.1</code> Source code in <code>phaseportrait/Map1D.py</code> <pre><code>def add_slider(self, param_name, *, valinit=None, valstep=0.1, valinterval=10):\n\"\"\"\n    Adds a `Slider` for the `dF` function.\n\n    Args:\n        param_name (str) : Name of the variable. Must be in the `dF` kargs of the `Map1D.dF` function.\n        valinit (float, defautl=None) : Initial position of the Slider\n        valinterval (Union[float,list], default=10) : Min and max value for the param range.\n        valstep (float, default=0.1) : Separation between consecutive values in the param range.\n    \"\"\" \n    self.sliders.update({param_name: Slider(\n        self, param_name, valinit=valinit, valstep=valstep, valinterval=valinterval)})\n\n    self.fig.subplots_adjust(bottom=0.25)\n\n    self.sliders[param_name].slider.on_changed(self.sliders[param_name])\n</code></pre>"},{"location":"reference/phaseportrait/Map1D/#phaseportrait.Map1D.Map1D.plot","title":"<code>plot(*, color=None)</code>","text":"<p>Prepares the plots and computes the values.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str) </code> <p>Matplotlib <code>Cmap</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[matplotlib Figure, matplotlib Axis]</code> Source code in <code>phaseportrait/Map1D.py</code> <pre><code>def plot(self, *, color=None):\n\"\"\"\n    Prepares the plots and computes the values.\n\n    Args:\n        color (str) : Matplotlib `Cmap`.\n\n    Returns: \n        (tuple[matplotlib Figure, matplotlib Axis]):\n    \"\"\"\n    for func in self.functions:\n        func.plot()\n\n    self.update_dF_args()\n    self._prepare_plot()\n    self._compute_data()\n\n    if color is not None:\n        self._cmap = color\n\n    for i in self._range:\n        values = self.maps[i].positions\n        color = values[0, 0:-2]\n        range_x = np.zeros(len(color)) + i\n        self.ax.scatter(\n            range_x, values[0, 1:-1],\n            s=self.size, c=color, cmap=self._cmap, norm=self._colores_norm\n        )\n\n    return self.fig, self.ax\n</code></pre>"},{"location":"reference/phaseportrait/Map1D/#phaseportrait.Map1D.Map1D.plot_over_variable","title":"<code>plot_over_variable(param_name, valinterval, valstep, *, initial_x=None, limit_cycle_check_first=50, delta_cycle_check=0.0001)</code>","text":"<p>Creates every <code>map</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str) </code> <p>Name of the variable. Must be in the <code>dF</code> kargs.</p> required <code>valinterval</code> <code>list) </code> <p>Min and max value for the param range.</p> required <code>valstep</code> <code>float) </code> <p>Separation between consecutive values in the param range.</p> required <code>initial_x</code> <code>float) </code> <p>Initial x position of every data series.</p> <code>None</code> <code>limit_cycle_check_first</code> <code>int) </code> <p>Number of points saved before checking for repeated elemets.</p> <code>50</code> <code>delta_cycle_check</code> <code>float) </code> <p>Diference between two positions to be considerated identical.</p> <code>0.0001</code> Source code in <code>phaseportrait/Map1D.py</code> <pre><code>def plot_over_variable(self, param_name, valinterval, valstep, *, initial_x=None, limit_cycle_check_first=50, delta_cycle_check=0.0001):\n\"\"\"\n    Creates every `map` instance.\n\n    Args:\n        param_name (str) : Name of the variable. Must be in the `dF` kargs.\n        valinterval (list) : Min and max value for the param range.\n        valstep (float) : Separation between consecutive values in the param range.\n        initial_x (float) : Initial x position of every data series.\n        limit_cycle_check_first (int) : Number of points saved before checking for repeated elemets.\n        delta_cycle_check (float) : Diference between two positions to be considerated identical.\n    \"\"\"\n\n    self._param_name = param_name\n    self._valinterval = valinterval\n\n    if initial_x is None:\n        initial_x = self._initial_x\n    self._initial_x = initial_x\n\n    self._valstep = valstep\n    self._limit_cycle_check_first = limit_cycle_check_first\n    self._delta_cycle_check = delta_cycle_check\n</code></pre>"},{"location":"reference/phaseportrait/Map1D/#phaseportrait.Map1D.Map1D.plot_trajectory","title":"<code>plot_trajectory(n_points, *, dF_args=None, initial_x=None, color='b', save_freq=1, thermalization=0)</code>","text":"<p>Creates a <code>map</code> instance and computes it's positions.</p> <p>Parameters:</p> Name Type Description Default <code>n_points</code> <code>int) </code> <p>Number of points to be calculated.</p> required <code>dF_args</code> <code>dict) </code> <p>If necesary, must contain the kargs for the <code>dF</code> function. By default takes the dF_args of the <code>Map1D</code> instance.</p> <code>None</code> <code>initial_x</code> <code>float) </code> <p>Initial position of the trajectory.</p> <code>None</code> <code>color</code> <code>str) </code> <p>String  matplotlib color identifier.</p> <code>'b'</code> <code>save_freq</code> <code>int) </code> <p>Number of times <code>dF</code> is aplied before a position is saved.</p> <code>1</code> <code>thermalization</code> <code>int) </code> <p>Thermalization steps before points saved.</p> <code>0</code> <p>Returns:</p> Type Description <code>`plt.Figure`, `plt.Axis`</code> Source code in <code>phaseportrait/Map1D.py</code> <pre><code>def plot_trajectory(self, n_points, *, dF_args=None, initial_x=None, color='b', save_freq=1, thermalization=0):\n\"\"\"\n    Creates a `map` instance and computes it's positions.\n\n    Args:\n        n_points (int) : Number of points to be calculated.\n        dF_args (dict) : If necesary, must contain the kargs for the `dF` function. By default takes the dF_args of the `Map1D` instance.\n        initial_x (float) : Initial position of the trajectory.\n        color (str) : String  matplotlib color identifier.\n        save_freq (int) : Number of times `dF` is aplied before a position is saved.\n        thermalization (int) : Thermalization steps before points saved.\n\n    Returns:\n        (`plt.Figure`, `plt.Axis`):   \n    \"\"\"\n    try:\n        if self._param_name:\n            pass\n    except AttributeError:\n        print('Method plot_over_variable must be executed before.')\n        return\n\n    if dF_args is None:\n        dF_args = self.dF_args\n    if initial_x is None:\n        initial_x = self._initial_x\n\n    self._prepare_plot_trajectory()\n    s_map = Map.instance_and_compute_all(None, self.dF, self.dimension, n_points, dF_args=dF_args, initial_values=initial_x, save_freq=save_freq, thermalization=thermalization)\n    self._trajectory[1].plot(s_map.positions[0], '.-', color=color)\n    return self._trajectory\n</code></pre>"},{"location":"reference/phaseportrait/Map1D/#phaseportrait.Map1D.Map1D.update_dF_args","title":"<code>update_dF_args()</code>","text":"<p>Updates the internal dF_args attributes to match the sliders.</p> Source code in <code>phaseportrait/Map1D.py</code> <pre><code>def update_dF_args(self):\n\"\"\"\n    Updates the internal dF_args attributes to match the sliders.\n    \"\"\"\n    self.dF_args.update({name: slider.value for name, slider in self.sliders.items() if slider.value!= None})\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortrait2D/","title":"PhasePortrait2D","text":""},{"location":"reference/phaseportrait/PhasePortrait2D/#phaseportrait.PhasePortrait2D.PhasePortrait2D","title":"<code>PhasePortrait2D</code>","text":"<p>Makes a phase portrait of a 2D system.</p>"},{"location":"reference/phaseportrait/PhasePortrait2D/#phaseportrait.PhasePortrait2D.PhasePortrait2D--examples","title":"Examples","text":"<pre><code>from phaseportrait import PhasePortrait2D\n\ndef dF(r, \u03b8, *, \u03bc=0.5,\u03b7=0):\n    return \u03bc*r*(1 - r*r), 1+\u03b7*\u03b8\n\n\nexample = PhasePortrait2D(dF, [-3, 3], Density=2, Polar=True, Title='Limit cycle')\nexample.add_slider('\u03bc', valinit=0.5)\nexample.add_slider('\u03b7', valinit=0.0)\nexample.add_nullclines()\nexample.plot()\n</code></pre> <ul> <li>Click here to see more examples.</li> </ul>"},{"location":"reference/phaseportrait/PhasePortrait2D/#phaseportrait.PhasePortrait2D.PhasePortrait2D--defining-range","title":"Defining Range","text":"<ol> <li> <p>A single number. In this case the range is defined from zero to the given number in both axes.</p> </li> <li> <p>A range, such <code>[lowerLimit , upperLimit]</code>.  Both axes will take the same limits.</p> </li> <li> <p>Two ranges, such that <code>[[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]]</code></p> </li> </ol>"},{"location":"reference/phaseportrait/PhasePortrait2D/#phaseportrait.PhasePortrait2D.PhasePortrait2D--methods","title":"Methods","text":"<ul> <li>draw_plot: Draws the streamplot. Is internaly used by method <code>plot</code>.</li> <li>add_function:  Adds a function to the <code>dF</code> plot.</li> <li>add_slider: Adds a <code>Slider</code> for the <code>dF</code> function.</li> <li>plot: Prepares the plots and computes the values. Returns the axis and the figure.</li> </ul> Source code in <code>phaseportrait/PhasePortrait2D.py</code> <pre><code>class PhasePortrait2D:\n\"\"\"\n    Makes a phase portrait of a 2D system.\n\n    Examples\n    -------\n    ```py\n    from phaseportrait import PhasePortrait2D\n\n    def dF(r, \u03b8, *, \u03bc=0.5,\u03b7=0):\n        return \u03bc*r*(1 - r*r), 1+\u03b7*\u03b8\n\n\n    example = PhasePortrait2D(dF, [-3, 3], Density=2, Polar=True, Title='Limit cycle')\n    example.add_slider('\u03bc', valinit=0.5)\n    example.add_slider('\u03b7', valinit=0.0)\n    example.add_nullclines()\n    example.plot()\n    ``` \n    * [Click here to see more examples.](../legacy/phaseportrait2d_examples.md)\n\n    ![image](../../imgs/doc_examples/pp2d_example.png)\n\n    Defining Range\n    -------\n\n    1. A single number. In this case the range is defined from zero to the given number in both axes.\n\n    2. A range, such `[lowerLimit , upperLimit]`.  Both axes will take the same limits.\n\n    3. Two ranges, such that `[[xAxisLowerLimit , xAxisUpperLimit], [yAxisLowerLimit , yAxisUpperLimit]]`\n\n    Methods\n    -------    \n    * draw_plot: Draws the streamplot. Is internaly used by method `plot`.\n    * add_function:  Adds a function to the `dF` plot.\n    * add_slider: Adds a `Slider` for the `dF` function.\n    * plot: Prepares the plots and computes the values. Returns the axis and the figure.\n    \"\"\"\n    _name_ = 'PhasePortrait2D'\n    def __init__(self, dF, Range, *, MeshDim=30, dF_args={}, Density = 1, Polar = False, Title = 'Phase Portrait', xlabel = 'X', ylabel = \"$\\\\dot{X}$\", \n                 color='rainbow', xScale='linear', yScale='linear', maxLen=500, odeint_method=\"scipy\", **kargs):\n\"\"\"PhasePortrait2D\n\n        Args:\n            dF (callable): A dF type function.\n            Range ([x_range, y_range]): Ranges of the axis in the main plot.\n            MeshDim (int, optional): Number of elements in the arrows grid. Defaults to 30.\n            dF_args (dict, optional): If necesary, must contain the kargs for the `dF` function. Defaults to {}.\n            Density (int, optional): [Deprecated] Number of elements in the arrows grid plot. Defaults to 1.\n            Polar (bool, optional): Whether to use polar coordinates or not. Defaults to False.\n            Title (str, optional): title of the plot. Defaults to 'Phase Portrait'.\n            xlabel (str, optional): x label of the plot. Defaults to 'X'.\n            ylabel (regexp, optional): y label of the plot. Defaults to r\"$\\dot{X}$\".\n            color (str, optional): Matplotlib `Cmap`. Defaults to 'rainbow'.\n            xScale (str, optional): x axis scale. Can be `linear`, `log`, `symlog`, `logit`. Defaults to 'linear'.\n            yScale (str, optional): y axis scale. Can be `linear`, `log`, `symlog`, `logit`. Defaults to 'linear'.\n            maxLen (int, optional): Max integrations per line of streamlines. Defaults to 500.\n            odeint_method (str, optional): Selects integration method, by default uses scipy.odeint. `euler` and `rungekutta3` are also available. Defaults to \"scipy\".\n        \"\"\"        \n\n        self.sliders = {}\n        self.nullclines = []\n\n        self.dF_args = dF_args.copy()                    # dF function's args\n        self.dF = dF                                     # Function containing system's equations\n\n\n        self.MeshDim  = MeshDim\n        self.Density = Density                           # Controls concentration of nearby trajectories\n        self.Polar = Polar                               # If dF expression given in polar coord. mark as True\n        self.Title = Title                               # Title of the plot\n        self.xlabel = xlabel                             # Title on X axis\n        self.ylabel = ylabel                             # Title on Y axis\n\n        self.xScale = xScale                             # x axis scale\n        self.yScale = yScale                             # x axis scale \n\n        self.Range = Range                               # Range of graphical representation\n\n        self.streamplot_callback = Streamlines_Velocity_Color_Gradient\n\n        # Variables for plotting\n        self.fig = kargs.get('fig', None)\n        if self.fig:\n            self.ax = self.fig.gca()\n        else:\n            self.fig, self.ax = plt.subplots()\n\n        self.color = color\n        self.grid = True\n\n        self.streamplot_args = {\"maxLen\": maxLen, \"odeint_method\": odeint_method}\n\n        self.manager = manager.Manager(self)\n\n\n    def _create_arrays(self):\n        # If scale is log and min range value is 0 or negative the plots is not correct\n        _Range = self.Range.copy().astype(np.float64)\n        for i, (scale, Range) in enumerate(zip([self.xScale, self.yScale], self.Range)):\n            if scale == 'log':\n                for j in range(len(Range)):\n                    if Range[j]&lt;=0:\n                        _Range[i,j] = abs(max(Range))/100 if j==0 else abs(max(Range))\n        self._Range = _Range\n\n        for i, (_P, scale, Range) in enumerate(zip([\"_X\", \"_Y\"],[self.xScale, self.yScale], self.Range)):\n            if scale == 'linear':\n                setattr(self, _P, np.linspace(Range[0], Range[1], self.MeshDim))\n            if scale == 'log':\n                setattr(self, _P, np.logspace(np.log10(Range[0]), np.log10(Range[1]), self.MeshDim))\n            if scale == 'symlog':\n                setattr(self, _P, np.linspace(Range[0], Range[1], self.MeshDim))\n\n        self._X, self._Y = np.meshgrid(self._X, self._Y)\n\n        # self._X, self._Y = np.meshgrid(np.linspace(*self.Range[0,:], self.MeshDim), np.linspace(*self.Range[1,:], self.MeshDim))\n\n        if self.Polar:   \n            self._R, self._Theta = (self._X**2 + self._Y**2)**0.5, np.arctan2(self._Y, self._X)\n\n\n    def plot(self, *, color=None, grid=None):\n\"\"\"Prepares th plots and computes the values\n\n        Args:\n            color (str, optional): Matplotlib `Cmap`. Defaults to None.\n            grid (bool, optional): Overrides general configuration of grid. Defaults to None.\n\n        Returns:\n            (Figure, Axes): returns the figure and axes in which the streamplot was drawn.\n        \"\"\"\n        if color is not None:\n            self.color = color\n        if grid is not None:\n            self.grid = grid\n\n        self.stream = self.draw_plot(color=self.color, grid=grid)\n\n        if hasattr(self, \"colorbar_ax\"):\n            cb = plt.colorbar(mplcm.ScalarMappable(\n                    norm=self.stream._velocity_normalization(), \n                    cmap=self.color),\n                ax=self.ax,\n                cax=self.colorbar_ax)\n\n            self.colorbar_ax = cb.ax\n\n        self.fig.canvas.draw_idle()\n\n        return self.fig, self.ax \n\n    def colorbar(self, toggle=True):\n\"\"\"Adds a colrobar for speed.\n\n        Args:\n            toggle (bool, optional): If `True` colorbar is visible. Defaults to True.\n        \"\"\"\n        if (not hasattr(self, \"colorbar_ax\")) and toggle:\n            self.colorbar_ax = None\n        else:\n            if hasattr(self, \"colorbar_ax\"):\n                self.colorbar_ax.remove()\n                del(self.colorbar_ax)\n\n    def draw_plot(self, *, color=None, grid=None):\n\"\"\"Draws the streamplot. Is internaly uesd by method `plot`.\n\n        Args:\n            color (str, optional): Matplotlib `Cmap`.. Defaults to None.\n            grid (bool, optional): Overrides general configuration of grid. Defaults to None.\n\n        Returns:\n            (matplotlib.Streamplot): Streamplot drawn.\n        \"\"\"\n        self.dF_args.update({name: slider.value for name, slider in self.sliders.items() if slider.value!= None})\n\n        # Re-create arrays in case Range or scale is changed\n        self._create_arrays()\n\n        try:\n            for nullcline in self.nullclines:\n                nullcline.plot()\n        except AttributeError:\n            pass\n\n        if color is not None:\n            self.color = color\n\n\n        stream = self.streamplot_callback(self.dF, self._X, self._Y, \n            dF_args=self.dF_args, polar=self.Polar, **self.streamplot_args)\n\n        try:\n            norm = stream._velocity_normalization()\n        except AttributeError:\n            norm = None\n        cmap = plt.get_cmap(self.color)\n\n        stream.plot(self.ax, cmap, norm, arrowsize=self.streamplot_args.get('arrow_width', 1))\n\n\n        self.ax.set_xlim(self.Range[0,:])\n        self.ax.set_ylim(self.Range[1,:])\n\n        self.ax.set_title(f'{self.Title}')\n        self.ax.set_xlabel(f'{self.xlabel}')\n        self.ax.set_ylabel(f'{self.ylabel}')\n        self.ax.set_xscale(self.xScale)\n        self.ax.set_yscale(self.yScale)\n        self.ax.grid(grid if grid is not None else self.grid)\n\n        return stream\n\n\n\n    def add_nullclines(self, *, precision=0.01, xprecision=None, yprecision=None, show: Literal['x', 'y', None]=None, offset=0., density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='g', bgcolor='w', alpha=0):\n\"\"\"Adds nullclines for both axis.\n\n        Args:\n            precision (float, optional): Precision if not specific axis precision is specified. Defaults to 0.01.\n            xprecision (float, optional): Precision for x axis nullcline. Defaults to None.\n            yprecision (float, optional): Precision for y axis nullcline. Defaults to None.\n            show (Literal['x', 'y', None], optinal) : Used to show only x or y nullclines, both if None. Defaults to None.\n            offset (float, optional): Specifies the value in which the countours will be drawn. Defaults to 0.\n            density (int, optional): Density of grid used in interpolation. Defaults to 50.\n            xRange (list[float], optional): Range of x nullcline, by default global range. Defaults to None.\n            yRange (list[float], optional): Range of y nullcline, by default global range. Defaults to None.\n            dF_args (dict, optional): Overrides general `dFargs` if is not None. Defaults to None.\n            xcolor (str, optional): Color for x nullcline. Defaults to 'r'.\n            ycolor (str, optional): Color for y nullcline. Defaults to 'g'.\n            bgcolor (str, optional): Color for background. Defaults to 'w'.\n            alpha (int, optional): Alpha of nullclines and background. Defaults to 0.\n        \"\"\"        \n        self.nullclines.append(Nullcline2D(self, self.dF,\n                                          precision=precision, xprecision=xprecision, yprecision=yprecision, show=show, offset=offset, density=density, \n                                          xRange=xRange, yRange=yRange, dF_args=dF_args, \n                                          xcolor=xcolor, ycolor=ycolor, bgcolor=bgcolor, alpha=alpha, polar=self.Polar))\n\n\n\n    def add_slider(self, param_name, *, valinit=None, valstep=0.1, valinterval=10):\n\"\"\"\n        Adds a slider which can change the value of a parameter in execution time.\n\n        Args:\n            param_name (str): It takes the name of the parameter on which the slider will be defined. Must be the same as the one appearing as karg in the `dF` function.\n            valinit (float, optional): Initial value of *param_name* variable. Default value is 0.5.   \n            valstep (flaot, optional): Slider step value. Default value is 0.1.\n            valinterval : (float|list[float], optional): Slider range. Default value is [-10, 10].\n        \"\"\"\n\n        self.sliders.update({param_name: sliders.Slider(self, param_name, valinit=valinit, valstep=valstep, valinterval=valinterval)})\n\n        self.fig.subplots_adjust(bottom=0.25)\n\n        self.sliders[param_name].slider.on_changed(self.sliders[param_name])\n\n    def _PolarTransformation(self):\n\"\"\"\n        Computes the expression of the velocity field if coordinates are given in polar representation.\n        \"\"\"\n        if not hasattr(self, \"_dR\") or not hasattr(self, \"_dTheta\"):\n            self._R, self._Theta = (self._X**2 + self._Y**2)**0.5, np.arctan2(self._Y, self._X)\n\n        self._dR, self._dTheta = self.dF(self._R, self._Theta, **self.dF_args)\n        self._dX, self._dY = self._dR*np.cos(self._Theta) - self._R*np.sin(self._Theta)*self._dTheta, self._dR*np.sin(self._Theta)+self._R*np.cos(self._Theta)*self._dTheta\n\n\n\n    @property\n    def dF(self):\n        return self._dF\n\n    @dF.setter\n    def dF(self, func):\n        if not callable(func):\n            raise exceptions.dFNotCallable(func)\n        sig = signature(func)\n        if len(sig.parameters)&lt;2 + len(self.dF_args):\n            raise exceptions.dFInvalid(sig, self.dF_args)\n\n        # TODO: when a slider is created it should create and append an axis to the figure. For easier cleaning\n        for s in self.sliders.copy():\n            if s not in sig.parameters:\n                raise exceptions.dF_argsInvalid(self.dF_args)\n\n        self._dF = func\n\n    @property\n    def Range(self):\n        return self._Range\n\n\n    @Range.setter\n    def Range(self, value):\n        self._Range = np.array(utils.construct_interval(value, dim=2))\n        self._create_arrays()\n\n    @property\n    def dF_args(self):\n        return self._dF_args\n\n    @dF_args.setter\n    def dF_args(self, value):\n        if value:\n            if not isinstance(value, dict):\n                raise exceptions.dF_argsInvalid(value)\n        self._dF_args = value\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortrait2D/#phaseportrait.PhasePortrait2D.PhasePortrait2D.__init__","title":"<code>__init__(dF, Range, *, MeshDim=30, dF_args={}, Density=1, Polar=False, Title='Phase Portrait', xlabel='X', ylabel='$\\\\dot{X}$', color='rainbow', xScale='linear', yScale='linear', maxLen=500, odeint_method='scipy', **kargs)</code>","text":"<p>PhasePortrait2D</p> <p>Parameters:</p> Name Type Description Default <code>dF</code> <code>callable</code> <p>A dF type function.</p> required <code>Range</code> <code>[x_range, y_range]</code> <p>Ranges of the axis in the main plot.</p> required <code>MeshDim</code> <code>int</code> <p>Number of elements in the arrows grid. Defaults to 30.</p> <code>30</code> <code>dF_args</code> <code>dict</code> <p>If necesary, must contain the kargs for the <code>dF</code> function. Defaults to {}.</p> <code>{}</code> <code>Density</code> <code>int</code> <p>[Deprecated] Number of elements in the arrows grid plot. Defaults to 1.</p> <code>1</code> <code>Polar</code> <code>bool</code> <p>Whether to use polar coordinates or not. Defaults to False.</p> <code>False</code> <code>Title</code> <code>str</code> <p>title of the plot. Defaults to 'Phase Portrait'.</p> <code>'Phase Portrait'</code> <code>xlabel</code> <code>str</code> <p>x label of the plot. Defaults to 'X'.</p> <code>'X'</code> <code>ylabel</code> <code>regexp</code> <p>y label of the plot. Defaults to r\"$\\dot{X}$\".</p> <code>'$\\\\dot{X}$'</code> <code>color</code> <code>str</code> <p>Matplotlib <code>Cmap</code>. Defaults to 'rainbow'.</p> <code>'rainbow'</code> <code>xScale</code> <code>str</code> <p>x axis scale. Can be <code>linear</code>, <code>log</code>, <code>symlog</code>, <code>logit</code>. Defaults to 'linear'.</p> <code>'linear'</code> <code>yScale</code> <code>str</code> <p>y axis scale. Can be <code>linear</code>, <code>log</code>, <code>symlog</code>, <code>logit</code>. Defaults to 'linear'.</p> <code>'linear'</code> <code>maxLen</code> <code>int</code> <p>Max integrations per line of streamlines. Defaults to 500.</p> <code>500</code> <code>odeint_method</code> <code>str</code> <p>Selects integration method, by default uses scipy.odeint. <code>euler</code> and <code>rungekutta3</code> are also available. Defaults to \"scipy\".</p> <code>'scipy'</code> Source code in <code>phaseportrait/PhasePortrait2D.py</code> <pre><code>def __init__(self, dF, Range, *, MeshDim=30, dF_args={}, Density = 1, Polar = False, Title = 'Phase Portrait', xlabel = 'X', ylabel = \"$\\\\dot{X}$\", \n             color='rainbow', xScale='linear', yScale='linear', maxLen=500, odeint_method=\"scipy\", **kargs):\n\"\"\"PhasePortrait2D\n\n    Args:\n        dF (callable): A dF type function.\n        Range ([x_range, y_range]): Ranges of the axis in the main plot.\n        MeshDim (int, optional): Number of elements in the arrows grid. Defaults to 30.\n        dF_args (dict, optional): If necesary, must contain the kargs for the `dF` function. Defaults to {}.\n        Density (int, optional): [Deprecated] Number of elements in the arrows grid plot. Defaults to 1.\n        Polar (bool, optional): Whether to use polar coordinates or not. Defaults to False.\n        Title (str, optional): title of the plot. Defaults to 'Phase Portrait'.\n        xlabel (str, optional): x label of the plot. Defaults to 'X'.\n        ylabel (regexp, optional): y label of the plot. Defaults to r\"$\\dot{X}$\".\n        color (str, optional): Matplotlib `Cmap`. Defaults to 'rainbow'.\n        xScale (str, optional): x axis scale. Can be `linear`, `log`, `symlog`, `logit`. Defaults to 'linear'.\n        yScale (str, optional): y axis scale. Can be `linear`, `log`, `symlog`, `logit`. Defaults to 'linear'.\n        maxLen (int, optional): Max integrations per line of streamlines. Defaults to 500.\n        odeint_method (str, optional): Selects integration method, by default uses scipy.odeint. `euler` and `rungekutta3` are also available. Defaults to \"scipy\".\n    \"\"\"        \n\n    self.sliders = {}\n    self.nullclines = []\n\n    self.dF_args = dF_args.copy()                    # dF function's args\n    self.dF = dF                                     # Function containing system's equations\n\n\n    self.MeshDim  = MeshDim\n    self.Density = Density                           # Controls concentration of nearby trajectories\n    self.Polar = Polar                               # If dF expression given in polar coord. mark as True\n    self.Title = Title                               # Title of the plot\n    self.xlabel = xlabel                             # Title on X axis\n    self.ylabel = ylabel                             # Title on Y axis\n\n    self.xScale = xScale                             # x axis scale\n    self.yScale = yScale                             # x axis scale \n\n    self.Range = Range                               # Range of graphical representation\n\n    self.streamplot_callback = Streamlines_Velocity_Color_Gradient\n\n    # Variables for plotting\n    self.fig = kargs.get('fig', None)\n    if self.fig:\n        self.ax = self.fig.gca()\n    else:\n        self.fig, self.ax = plt.subplots()\n\n    self.color = color\n    self.grid = True\n\n    self.streamplot_args = {\"maxLen\": maxLen, \"odeint_method\": odeint_method}\n\n    self.manager = manager.Manager(self)\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortrait2D/#phaseportrait.PhasePortrait2D.PhasePortrait2D.add_nullclines","title":"<code>add_nullclines(*, precision=0.01, xprecision=None, yprecision=None, show=None, offset=0.0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='g', bgcolor='w', alpha=0)</code>","text":"<p>Adds nullclines for both axis.</p> <p>Parameters:</p> Name Type Description Default <code>precision</code> <code>float</code> <p>Precision if not specific axis precision is specified. Defaults to 0.01.</p> <code>0.01</code> <code>xprecision</code> <code>float</code> <p>Precision for x axis nullcline. Defaults to None.</p> <code>None</code> <code>yprecision</code> <code>float</code> <p>Precision for y axis nullcline. Defaults to None.</p> <code>None</code> <code>show</code> <code>Literal['x', 'y', None], optinal) </code> <p>Used to show only x or y nullclines, both if None. Defaults to None.</p> <code>None</code> <code>offset</code> <code>float</code> <p>Specifies the value in which the countours will be drawn. Defaults to 0.</p> <code>0.0</code> <code>density</code> <code>int</code> <p>Density of grid used in interpolation. Defaults to 50.</p> <code>50</code> <code>xRange</code> <code>list[float]</code> <p>Range of x nullcline, by default global range. Defaults to None.</p> <code>None</code> <code>yRange</code> <code>list[float]</code> <p>Range of y nullcline, by default global range. Defaults to None.</p> <code>None</code> <code>dF_args</code> <code>dict</code> <p>Overrides general <code>dFargs</code> if is not None. Defaults to None.</p> <code>None</code> <code>xcolor</code> <code>str</code> <p>Color for x nullcline. Defaults to 'r'.</p> <code>'r'</code> <code>ycolor</code> <code>str</code> <p>Color for y nullcline. Defaults to 'g'.</p> <code>'g'</code> <code>bgcolor</code> <code>str</code> <p>Color for background. Defaults to 'w'.</p> <code>'w'</code> <code>alpha</code> <code>int</code> <p>Alpha of nullclines and background. Defaults to 0.</p> <code>0</code> Source code in <code>phaseportrait/PhasePortrait2D.py</code> <pre><code>def add_nullclines(self, *, precision=0.01, xprecision=None, yprecision=None, show: Literal['x', 'y', None]=None, offset=0., density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='g', bgcolor='w', alpha=0):\n\"\"\"Adds nullclines for both axis.\n\n    Args:\n        precision (float, optional): Precision if not specific axis precision is specified. Defaults to 0.01.\n        xprecision (float, optional): Precision for x axis nullcline. Defaults to None.\n        yprecision (float, optional): Precision for y axis nullcline. Defaults to None.\n        show (Literal['x', 'y', None], optinal) : Used to show only x or y nullclines, both if None. Defaults to None.\n        offset (float, optional): Specifies the value in which the countours will be drawn. Defaults to 0.\n        density (int, optional): Density of grid used in interpolation. Defaults to 50.\n        xRange (list[float], optional): Range of x nullcline, by default global range. Defaults to None.\n        yRange (list[float], optional): Range of y nullcline, by default global range. Defaults to None.\n        dF_args (dict, optional): Overrides general `dFargs` if is not None. Defaults to None.\n        xcolor (str, optional): Color for x nullcline. Defaults to 'r'.\n        ycolor (str, optional): Color for y nullcline. Defaults to 'g'.\n        bgcolor (str, optional): Color for background. Defaults to 'w'.\n        alpha (int, optional): Alpha of nullclines and background. Defaults to 0.\n    \"\"\"        \n    self.nullclines.append(Nullcline2D(self, self.dF,\n                                      precision=precision, xprecision=xprecision, yprecision=yprecision, show=show, offset=offset, density=density, \n                                      xRange=xRange, yRange=yRange, dF_args=dF_args, \n                                      xcolor=xcolor, ycolor=ycolor, bgcolor=bgcolor, alpha=alpha, polar=self.Polar))\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortrait2D/#phaseportrait.PhasePortrait2D.PhasePortrait2D.add_slider","title":"<code>add_slider(param_name, *, valinit=None, valstep=0.1, valinterval=10)</code>","text":"<p>Adds a slider which can change the value of a parameter in execution time.</p> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>It takes the name of the parameter on which the slider will be defined. Must be the same as the one appearing as karg in the <code>dF</code> function.</p> required <code>valinit</code> <code>float</code> <p>Initial value of param_name variable. Default value is 0.5.   </p> <code>None</code> <code>valstep</code> <code>flaot</code> <p>Slider step value. Default value is 0.1.</p> <code>0.1</code> <code>valinterval</code> <p>(float|list[float], optional): Slider range. Default value is [-10, 10].</p> <code>10</code> Source code in <code>phaseportrait/PhasePortrait2D.py</code> <pre><code>def add_slider(self, param_name, *, valinit=None, valstep=0.1, valinterval=10):\n\"\"\"\n    Adds a slider which can change the value of a parameter in execution time.\n\n    Args:\n        param_name (str): It takes the name of the parameter on which the slider will be defined. Must be the same as the one appearing as karg in the `dF` function.\n        valinit (float, optional): Initial value of *param_name* variable. Default value is 0.5.   \n        valstep (flaot, optional): Slider step value. Default value is 0.1.\n        valinterval : (float|list[float], optional): Slider range. Default value is [-10, 10].\n    \"\"\"\n\n    self.sliders.update({param_name: sliders.Slider(self, param_name, valinit=valinit, valstep=valstep, valinterval=valinterval)})\n\n    self.fig.subplots_adjust(bottom=0.25)\n\n    self.sliders[param_name].slider.on_changed(self.sliders[param_name])\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortrait2D/#phaseportrait.PhasePortrait2D.PhasePortrait2D.colorbar","title":"<code>colorbar(toggle=True)</code>","text":"<p>Adds a colrobar for speed.</p> <p>Parameters:</p> Name Type Description Default <code>toggle</code> <code>bool</code> <p>If <code>True</code> colorbar is visible. Defaults to True.</p> <code>True</code> Source code in <code>phaseportrait/PhasePortrait2D.py</code> <pre><code>def colorbar(self, toggle=True):\n\"\"\"Adds a colrobar for speed.\n\n    Args:\n        toggle (bool, optional): If `True` colorbar is visible. Defaults to True.\n    \"\"\"\n    if (not hasattr(self, \"colorbar_ax\")) and toggle:\n        self.colorbar_ax = None\n    else:\n        if hasattr(self, \"colorbar_ax\"):\n            self.colorbar_ax.remove()\n            del(self.colorbar_ax)\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortrait2D/#phaseportrait.PhasePortrait2D.PhasePortrait2D.draw_plot","title":"<code>draw_plot(*, color=None, grid=None)</code>","text":"<p>Draws the streamplot. Is internaly uesd by method <code>plot</code>.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Matplotlib <code>Cmap</code>.. Defaults to None.</p> <code>None</code> <code>grid</code> <code>bool</code> <p>Overrides general configuration of grid. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>matplotlib.Streamplot</code> <p>Streamplot drawn.</p> Source code in <code>phaseportrait/PhasePortrait2D.py</code> <pre><code>def draw_plot(self, *, color=None, grid=None):\n\"\"\"Draws the streamplot. Is internaly uesd by method `plot`.\n\n    Args:\n        color (str, optional): Matplotlib `Cmap`.. Defaults to None.\n        grid (bool, optional): Overrides general configuration of grid. Defaults to None.\n\n    Returns:\n        (matplotlib.Streamplot): Streamplot drawn.\n    \"\"\"\n    self.dF_args.update({name: slider.value for name, slider in self.sliders.items() if slider.value!= None})\n\n    # Re-create arrays in case Range or scale is changed\n    self._create_arrays()\n\n    try:\n        for nullcline in self.nullclines:\n            nullcline.plot()\n    except AttributeError:\n        pass\n\n    if color is not None:\n        self.color = color\n\n\n    stream = self.streamplot_callback(self.dF, self._X, self._Y, \n        dF_args=self.dF_args, polar=self.Polar, **self.streamplot_args)\n\n    try:\n        norm = stream._velocity_normalization()\n    except AttributeError:\n        norm = None\n    cmap = plt.get_cmap(self.color)\n\n    stream.plot(self.ax, cmap, norm, arrowsize=self.streamplot_args.get('arrow_width', 1))\n\n\n    self.ax.set_xlim(self.Range[0,:])\n    self.ax.set_ylim(self.Range[1,:])\n\n    self.ax.set_title(f'{self.Title}')\n    self.ax.set_xlabel(f'{self.xlabel}')\n    self.ax.set_ylabel(f'{self.ylabel}')\n    self.ax.set_xscale(self.xScale)\n    self.ax.set_yscale(self.yScale)\n    self.ax.grid(grid if grid is not None else self.grid)\n\n    return stream\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortrait2D/#phaseportrait.PhasePortrait2D.PhasePortrait2D.plot","title":"<code>plot(*, color=None, grid=None)</code>","text":"<p>Prepares th plots and computes the values</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Matplotlib <code>Cmap</code>. Defaults to None.</p> <code>None</code> <code>grid</code> <code>bool</code> <p>Overrides general configuration of grid. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure, Axes</code> <p>returns the figure and axes in which the streamplot was drawn.</p> Source code in <code>phaseportrait/PhasePortrait2D.py</code> <pre><code>def plot(self, *, color=None, grid=None):\n\"\"\"Prepares th plots and computes the values\n\n    Args:\n        color (str, optional): Matplotlib `Cmap`. Defaults to None.\n        grid (bool, optional): Overrides general configuration of grid. Defaults to None.\n\n    Returns:\n        (Figure, Axes): returns the figure and axes in which the streamplot was drawn.\n    \"\"\"\n    if color is not None:\n        self.color = color\n    if grid is not None:\n        self.grid = grid\n\n    self.stream = self.draw_plot(color=self.color, grid=grid)\n\n    if hasattr(self, \"colorbar_ax\"):\n        cb = plt.colorbar(mplcm.ScalarMappable(\n                norm=self.stream._velocity_normalization(), \n                cmap=self.color),\n            ax=self.ax,\n            cax=self.colorbar_ax)\n\n        self.colorbar_ax = cb.ax\n\n    self.fig.canvas.draw_idle()\n\n    return self.fig, self.ax \n</code></pre>"},{"location":"reference/phaseportrait/PhasePortrait3D/","title":"PhasePortrait3D","text":""},{"location":"reference/phaseportrait/PhasePortrait3D/#phaseportrait.PhasePortrait3D.PhasePortrait3D","title":"<code>PhasePortrait3D</code>","text":""},{"location":"reference/phaseportrait/PhasePortrait3D/#phaseportrait.PhasePortrait3D.PhasePortrait3D--phaseportrait3d","title":"PhasePortrait3D","text":"<p>Makes a phase portrait of a 3D system.</p>"},{"location":"reference/phaseportrait/PhasePortrait3D/#phaseportrait.PhasePortrait3D.PhasePortrait3D--examples","title":"Examples","text":""},{"location":"reference/phaseportrait/PhasePortrait3D/#phaseportrait.PhasePortrait3D.PhasePortrait3D--methods","title":"Methods","text":"<ul> <li>draw_plot : Draws the streamplot. Is intenally used by method <code>plot</code>.</li> <li>add_function : Adds a function to the <code>dF</code> plot.</li> <li>add_slider : Adds a <code>Slider</code> for the <code>dF</code> function.</li> <li>plot : Prepares the plots and computes the values. Returns the axis and the figure.</li> </ul> Source code in <code>phaseportrait/PhasePortrait3D.py</code> <pre><code>class PhasePortrait3D:\n\"\"\"\n    PhasePortrait3D\n    ----------------\n    Makes a phase portrait of a 3D system.\n\n    Examples\n    -------\n    ![image](../../imgs/doc_examples/pp3d_example.png)\n\n    Methods \n    -----\n    * draw_plot : Draws the streamplot. Is intenally used by method `plot`.\n    * add_function : Adds a function to the `dF` plot.\n    * add_slider : Adds a `Slider` for the `dF` function.\n    * plot : Prepares the plots and computes the values. Returns the axis and the figure.\n    \"\"\"\n    _name_ = 'PhasePortrait3D'\n    def __init__(self, dF, Range, *, MeshDim=6, dF_args={}, Density = 1, Polar = False, Title = 'Phase Portrait', xlabel = 'X', ylabel = 'Y', \n                 zlabel='Z', color='rainbow', xScale='linear', yScale='linear', zScale='linear', maxLen=500, odeint_method=\"scipy\", **kargs):\n\"\"\" PhasePortrait3D\n\n        Args:\n            dF (callable): A dF type function.\n            Range ([x_range, y_range, z_range]): Ranges of the axis in the main plot.\n            MeshDim (int, default=30): Number of elements in the arrows grid.\n            dF_args (dict): If necesary, must contain the kargs for the `dF` function.\n            Density (float, default=1): [Deprecated] Number of elements in the arrows grid plot.\n            Polar (bool, default=False): Whether to use polar coordinates or not.\n            Title (str, default='Phase Portrait' ): xlabel (str, default='X'): x label of the plot.\n            ylabel (str, default='Y' ): y label of the plot.\n            zlabel (str, default='Z' ): z label of the plot.\n            color (str, default='rainbow'): Matplotlib `Cmap`.\n            xScale (str, default='linear'): x axis scale. Can be `linear`, `log`, `symlog`, `logit`.\n            yScale (str, default='linear'): y axis scale. Can be `linear`, `log`, `symlog`, `logit`.\n            zScale (str, default='linear'): z axis scale. Can be `linear`, `log`, `symlog`, `logit`.\n            odeint_method (str, default=\"scipy\"): Selects integration method, by default uses scipy.odeint. `euler` and `rungekutta3` are also available.\n        \"\"\"\n        self.sliders = {}\n        self.nullclines = []\n\n        self.dF_args = dF_args.copy()                    # dF function's args\n        self.dF = dF                                     # Function containing system's equations\n\n\n        self.MeshDim  = MeshDim\n        self.Density = Density                           # Controls concentration of nearby trajectories\n        self.Polar = Polar                               # If dF expression given in polar coord. mark as True\n        self.Title = Title                               # Title of the plot\n        self.xlabel = xlabel                             # Title on X axis\n        self.ylabel = ylabel                             # Title on Y axis\n        self.zlabel = zlabel\n\n        self.xScale = xScale                             # x axis scale\n        self.yScale = yScale                             # y axis scale\n        self.zScale = zScale                             # z axis scale\n        self.Range = Range                               # Range of graphical representation\n\n        self.streamplot_callback = Streamlines_Velocity_Color_Gradient\n\n        self._create_arrays()\n\n        # Variables for plotting\n        self.fig = kargs.get('fig', None)\n        if self.fig:\n            self.fig.gca().remove()\n        else:\n            self.fig = plt.figure()\n\n        self.ax = self.fig.add_subplot(projection='3d')\n        self.color = color\n        self.grid = True\n\n        self.streamplot_args = {\"maxLen\": maxLen, \"odeint_method\": odeint_method}\n\n\n        self.manager = manager.Manager(self)\n\n\n    def _create_arrays(self):\n        # If scale is log and min range value is 0 or negative the plots is not correct\n        _Range = self.Range.copy()\n        for i, (scale, Range) in enumerate(zip([self.xScale, self.yScale, self.zScale], self.Range)):\n            if scale == 'log':\n                for j in range(len(Range)):\n                    if Range[j]&lt;=0:\n                        _Range[i,j] = abs(max(Range))/100 if j==0 else abs(max(Range))\n        self.Range = _Range\n\n\n        for i, (_P, scale, Range) in enumerate(zip([\"_X\", \"_Y\", \"_Z\"],[self.xScale, self.yScale, self.zScale], self.Range)):\n            if scale == 'linear':\n                setattr(self, _P, np.linspace(Range[0], Range[1], self.MeshDim))\n            if scale == 'log':\n                setattr(self, _P, np.logspace(np.log10(Range[0]), np.log10(Range[1]), self.MeshDim))\n            if scale == 'symlog':\n                setattr(self, _P, np.linspace(Range[0], Range[1], self.MeshDim))\n\n        self._X, self._Y, self._Z = np.meshgrid(self._X, self._Y, self._Z)\n\n        if self.Polar:   \n            self._R, self._Theta = (self._X**2 + self._Y**2)**0.5, np.arctan2(self._Y, self._X)\n\n\n    def plot(self, *, color=None, grid=None):\n\"\"\"\n        Prepares the plots and computes the values.\n\n        Args: \n            color (str): Matplotlib `Cmap`.\n\n        Returns:\n            (tuple(matplotlib Figure, matplotlib Axis)):\n        \"\"\"\n        if color is not None:\n            self.color = color\n        if grid is not None:\n            self.grid = grid\n\n        self.stream = self.draw_plot(color=self.color, grid=grid)\n\n        if hasattr(self, \"colorbar_ax\"):\n            cb = plt.colorbar(mplcm.ScalarMappable(\n                norm=self.stream._velocity_normalization(), \n                cmap=self.color),\n            ax=self.ax,\n            cax=self.colorbar_ax)\n\n            self.colorbar_ax = cb.ax\n\n        self.fig.canvas.draw_idle()\n\n        return self.fig, self.ax \n\n    def colorbar(self, toggle=True):\n\"\"\"\n        Adds a colorbar for speed.\n\n        Args:\n            toggle (bool, default=True): If `True` colorbar is visible.\n        \"\"\"\n        if (not hasattr(self, \"colorbar_ax\")) and toggle:\n            self.colorbar_ax = None\n        else:\n            if hasattr(self, \"colorbar_ax\"):\n                self.colorbar_ax.remove()\n                del(self.colorbar_ax)\n\n\n    def draw_plot(self, *, color=None, grid=None):\n\"\"\"\n        Draws the streamplot. Is intenally used by method `plot`.\n\n        Args:\n            color (str, default='viridis'): Matplotlib `Cmap`.\n            grid (bool, default=True): Show grid lines.\n\n        Returns:\n            (matplotlib.Streamplot):\n        \"\"\"\n        self.dF_args.update({name: slider.value for name, slider in self.sliders.items() if slider.value!= None})\n\n        self._create_arrays()\n\n        try:\n            for nullcline in self.nullclines:\n                nullcline.plot()\n        except AttributeError:\n            pass\n\n        if color is not None:\n            self.color = color\n\n        # if self.Polar:\n        #     self._PolarTransformation()\n        # else:\n        #     self._dX, self._dY = self.dF(self._X, self._Y, **self.dF_args)\n\n        # if utils.is_number(self._dX):\n        #     self._dX = self._X.copy() * 0 + self._dX\n        # if utils.is_number(self._dY):\n        #     self._dY = self._Y.copy() * 0 + self._dY\n\n\n\n        stream = self.streamplot_callback(self.dF, self._X, self._Y, self._Z,\n            dF_args=self.dF_args, polar=self.Polar, **self.streamplot_args)\n\n        try:\n            norm = stream._velocity_normalization()\n        except AttributeError:\n            norm = None\n        cmap = plt.get_cmap(self.color)\n\n        stream.plot(self.ax, cmap, norm, arrowsize=self.streamplot_args.get('arrow_width', 1))\n\n\n        self.ax.set_xlim3d(self.Range[0])\n        self.ax.set_ylim3d(self.Range[1])\n        self.ax.set_zlim3d(self.Range[2])\n        # self.ax.set_aspect(abs(self.Range[0,1]-self.Range[0,0])/abs(self.Range[1,1]-self.Range[1,0]))\n\n        self.ax.set_title(f'{self.Title}')\n        self.ax.set_xlabel(f'{self.xlabel}')\n        self.ax.set_ylabel(f'{self.ylabel}')\n        self.ax.set_zlabel(f'{self.zlabel}')\n        self.ax.set_xscale(self.xScale)\n        self.ax.set_yscale(self.yScale)\n        self.ax.set_zscale(self.zScale)\n\n\n\n\n        def log_tick_formatter(val, pos=None):\n            return r\"$10^{{{:.0f}}}$\".format(val)\n\n        if self.xScale in ['log', 'symlog']:\n            self.ax.xaxis.set_major_formatter(mticker.FuncFormatter(log_tick_formatter))\n        if self.yScale in ['log', 'symlog']:\n            self.ax.yaxis.set_major_formatter(mticker.FuncFormatter(log_tick_formatter))\n        if self.zScale in ['log', 'symlog']:\n            self.ax.zaxis.set_major_formatter(mticker.FuncFormatter(log_tick_formatter))\n\n        self.ax.grid(grid if grid is not None else self.grid)\n\n        return stream\n\n\n    def add_slider(self, param_name, *, valinit=None, valstep=0.1, valinterval=10):\n\"\"\"\n        Adds a slider which can change the value of a parameter in execution time.\n\n        Args:\n            param_name (str): It takes the name of the parameter on which the slider will be defined. Must be the same as the one appearing as karg in the `dF` function.\n            valinit (float, optional): Initial value of *param_name* variable. Default value is 0.5.\n            valstep (float, optional): Slider step value. Default value is 0.1.\n            valinterval (float|list[float], optional): Slider range. Default value is [-10, 10].\n        \"\"\"\n\n        self.sliders.update({param_name: sliders.Slider(self, param_name, valinit=valinit, valstep=valstep, valinterval=valinterval)})\n\n        self.fig.subplots_adjust(bottom=0.25)\n\n        self.sliders[param_name].slider.on_changed(self.sliders[param_name])\n\n    def _PolarTransformation(self):\n\"\"\"\n        Computes the expression of the velocity field if coordinates are given in polar representation.\n        \"\"\"\n        if not hasattr(self, \"_dR\") or not hasattr(self, \"_dTheta\") or not hasattr(self, \"_dPhi\"):\n            self._R, self._Theta = np.sqrt(self._X**2 + self._Y**2 + self._Z**2), np.arctan2(self._Y, self._X)\n            self._Phi = np.arccos(self._Z / self._R)\n\n        self._dR, self._dTheta, self._dPhi = self.dF(self._R, self._Theta, self._Phi **self.dF_args)\n        self._dX, self._dY, self._dZ = \\\n            self._dR*np.cos(self._Theta)*np.sin(self._Phi) - self._R*np.sin(self._Theta)*np.sin(self._Phi)*self._dTheta + self._R*np.cos(self._Theta)*np.cos(self._Phi) * self._dPhi, \\\n            self._dR*np.sin(self._Theta)*np.sin(self._Phi) + self._R*np.cos(self._Theta)*np.sin(self._Phi)*self._dTheta + self._R*np.sin(self._Theta)*np.cos(self._Phi)*self._dPhi, \\\n            self._dR*np.cos(self._Phi) - self._R*np.sin(self._Phi)*self._dPhi\n\n\n\n    @property\n    def dF(self):\n        return self._dF\n\n    @dF.setter\n    def dF(self, func):\n        if not callable(func):\n            raise exceptions.dFNotCallable(func)\n        sig = signature(func)\n        if len(sig.parameters)&lt;2 + len(self.dF_args):\n            raise exceptions.dFInvalid(sig, self.dF_args)\n\n        # TODO: when a slider is created it should create and append an axis to the figure. For easier cleaning\n        for s in self.sliders.copy():\n            if s not in sig.parameters:\n                raise exceptions.dF_argsInvalid(self.dF_args)\n\n        self._dF = func\n\n    @property\n    def Range(self):\n        return self._Range\n\n\n    @Range.setter\n    def Range(self, value):\n        if len(value)==3:\n            if np.array([len(value[i])==2 for i in range(3)]).all():\n                self._Range = value\n                return\n        self._Range = np.array(utils.construct_interval(value, dim=3))\n        self._create_arrays()\n\n    @property\n    def dF_args(self):\n        return self._dF_args\n\n    @dF_args.setter\n    def dF_args(self, value):\n        if value:\n            if not isinstance(value, dict):\n                raise exceptions.dF_argsInvalid(value)\n        self._dF_args = value\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortrait3D/#phaseportrait.PhasePortrait3D.PhasePortrait3D.__init__","title":"<code>__init__(dF, Range, *, MeshDim=6, dF_args={}, Density=1, Polar=False, Title='Phase Portrait', xlabel='X', ylabel='Y', zlabel='Z', color='rainbow', xScale='linear', yScale='linear', zScale='linear', maxLen=500, odeint_method='scipy', **kargs)</code>","text":"<p>PhasePortrait3D</p> <p>Parameters:</p> Name Type Description Default <code>dF</code> <code>callable</code> <p>A dF type function.</p> required <code>Range</code> <code>[x_range, y_range, z_range]</code> <p>Ranges of the axis in the main plot.</p> required <code>MeshDim</code> <code>int, default=30</code> <p>Number of elements in the arrows grid.</p> <code>6</code> <code>dF_args</code> <code>dict</code> <p>If necesary, must contain the kargs for the <code>dF</code> function.</p> <code>{}</code> <code>Density</code> <code>float, default=1</code> <p>[Deprecated] Number of elements in the arrows grid plot.</p> <code>1</code> <code>Polar</code> <code>bool, default=False</code> <p>Whether to use polar coordinates or not.</p> <code>False</code> <code>Title</code> <code>str, default='Phase Portrait' </code> <p>xlabel (str, default='X'): x label of the plot.</p> <code>'Phase Portrait'</code> <code>ylabel</code> <code>str, default='Y' </code> <p>y label of the plot.</p> <code>'Y'</code> <code>zlabel</code> <code>str, default='Z' </code> <p>z label of the plot.</p> <code>'Z'</code> <code>color</code> <code>str, default='rainbow'</code> <p>Matplotlib <code>Cmap</code>.</p> <code>'rainbow'</code> <code>xScale</code> <code>str, default='linear'</code> <p>x axis scale. Can be <code>linear</code>, <code>log</code>, <code>symlog</code>, <code>logit</code>.</p> <code>'linear'</code> <code>yScale</code> <code>str, default='linear'</code> <p>y axis scale. Can be <code>linear</code>, <code>log</code>, <code>symlog</code>, <code>logit</code>.</p> <code>'linear'</code> <code>zScale</code> <code>str, default='linear'</code> <p>z axis scale. Can be <code>linear</code>, <code>log</code>, <code>symlog</code>, <code>logit</code>.</p> <code>'linear'</code> <code>odeint_method</code> <code>str, default=\"scipy\"</code> <p>Selects integration method, by default uses scipy.odeint. <code>euler</code> and <code>rungekutta3</code> are also available.</p> <code>'scipy'</code> Source code in <code>phaseportrait/PhasePortrait3D.py</code> <pre><code>def __init__(self, dF, Range, *, MeshDim=6, dF_args={}, Density = 1, Polar = False, Title = 'Phase Portrait', xlabel = 'X', ylabel = 'Y', \n             zlabel='Z', color='rainbow', xScale='linear', yScale='linear', zScale='linear', maxLen=500, odeint_method=\"scipy\", **kargs):\n\"\"\" PhasePortrait3D\n\n    Args:\n        dF (callable): A dF type function.\n        Range ([x_range, y_range, z_range]): Ranges of the axis in the main plot.\n        MeshDim (int, default=30): Number of elements in the arrows grid.\n        dF_args (dict): If necesary, must contain the kargs for the `dF` function.\n        Density (float, default=1): [Deprecated] Number of elements in the arrows grid plot.\n        Polar (bool, default=False): Whether to use polar coordinates or not.\n        Title (str, default='Phase Portrait' ): xlabel (str, default='X'): x label of the plot.\n        ylabel (str, default='Y' ): y label of the plot.\n        zlabel (str, default='Z' ): z label of the plot.\n        color (str, default='rainbow'): Matplotlib `Cmap`.\n        xScale (str, default='linear'): x axis scale. Can be `linear`, `log`, `symlog`, `logit`.\n        yScale (str, default='linear'): y axis scale. Can be `linear`, `log`, `symlog`, `logit`.\n        zScale (str, default='linear'): z axis scale. Can be `linear`, `log`, `symlog`, `logit`.\n        odeint_method (str, default=\"scipy\"): Selects integration method, by default uses scipy.odeint. `euler` and `rungekutta3` are also available.\n    \"\"\"\n    self.sliders = {}\n    self.nullclines = []\n\n    self.dF_args = dF_args.copy()                    # dF function's args\n    self.dF = dF                                     # Function containing system's equations\n\n\n    self.MeshDim  = MeshDim\n    self.Density = Density                           # Controls concentration of nearby trajectories\n    self.Polar = Polar                               # If dF expression given in polar coord. mark as True\n    self.Title = Title                               # Title of the plot\n    self.xlabel = xlabel                             # Title on X axis\n    self.ylabel = ylabel                             # Title on Y axis\n    self.zlabel = zlabel\n\n    self.xScale = xScale                             # x axis scale\n    self.yScale = yScale                             # y axis scale\n    self.zScale = zScale                             # z axis scale\n    self.Range = Range                               # Range of graphical representation\n\n    self.streamplot_callback = Streamlines_Velocity_Color_Gradient\n\n    self._create_arrays()\n\n    # Variables for plotting\n    self.fig = kargs.get('fig', None)\n    if self.fig:\n        self.fig.gca().remove()\n    else:\n        self.fig = plt.figure()\n\n    self.ax = self.fig.add_subplot(projection='3d')\n    self.color = color\n    self.grid = True\n\n    self.streamplot_args = {\"maxLen\": maxLen, \"odeint_method\": odeint_method}\n\n\n    self.manager = manager.Manager(self)\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortrait3D/#phaseportrait.PhasePortrait3D.PhasePortrait3D.add_slider","title":"<code>add_slider(param_name, *, valinit=None, valstep=0.1, valinterval=10)</code>","text":"<p>Adds a slider which can change the value of a parameter in execution time.</p> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str</code> <p>It takes the name of the parameter on which the slider will be defined. Must be the same as the one appearing as karg in the <code>dF</code> function.</p> required <code>valinit</code> <code>float</code> <p>Initial value of param_name variable. Default value is 0.5.</p> <code>None</code> <code>valstep</code> <code>float</code> <p>Slider step value. Default value is 0.1.</p> <code>0.1</code> <code>valinterval</code> <code>float | list[float]</code> <p>Slider range. Default value is [-10, 10].</p> <code>10</code> Source code in <code>phaseportrait/PhasePortrait3D.py</code> <pre><code>def add_slider(self, param_name, *, valinit=None, valstep=0.1, valinterval=10):\n\"\"\"\n    Adds a slider which can change the value of a parameter in execution time.\n\n    Args:\n        param_name (str): It takes the name of the parameter on which the slider will be defined. Must be the same as the one appearing as karg in the `dF` function.\n        valinit (float, optional): Initial value of *param_name* variable. Default value is 0.5.\n        valstep (float, optional): Slider step value. Default value is 0.1.\n        valinterval (float|list[float], optional): Slider range. Default value is [-10, 10].\n    \"\"\"\n\n    self.sliders.update({param_name: sliders.Slider(self, param_name, valinit=valinit, valstep=valstep, valinterval=valinterval)})\n\n    self.fig.subplots_adjust(bottom=0.25)\n\n    self.sliders[param_name].slider.on_changed(self.sliders[param_name])\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortrait3D/#phaseportrait.PhasePortrait3D.PhasePortrait3D.colorbar","title":"<code>colorbar(toggle=True)</code>","text":"<p>Adds a colorbar for speed.</p> <p>Parameters:</p> Name Type Description Default <code>toggle</code> <code>bool, default=True</code> <p>If <code>True</code> colorbar is visible.</p> <code>True</code> Source code in <code>phaseportrait/PhasePortrait3D.py</code> <pre><code>def colorbar(self, toggle=True):\n\"\"\"\n    Adds a colorbar for speed.\n\n    Args:\n        toggle (bool, default=True): If `True` colorbar is visible.\n    \"\"\"\n    if (not hasattr(self, \"colorbar_ax\")) and toggle:\n        self.colorbar_ax = None\n    else:\n        if hasattr(self, \"colorbar_ax\"):\n            self.colorbar_ax.remove()\n            del(self.colorbar_ax)\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortrait3D/#phaseportrait.PhasePortrait3D.PhasePortrait3D.draw_plot","title":"<code>draw_plot(*, color=None, grid=None)</code>","text":"<p>Draws the streamplot. Is intenally used by method <code>plot</code>.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str, default='viridis'</code> <p>Matplotlib <code>Cmap</code>.</p> <code>None</code> <code>grid</code> <code>bool, default=True</code> <p>Show grid lines.</p> <code>None</code> <p>Returns:</p> Type Description <code>matplotlib.Streamplot</code> Source code in <code>phaseportrait/PhasePortrait3D.py</code> <pre><code>def draw_plot(self, *, color=None, grid=None):\n\"\"\"\n    Draws the streamplot. Is intenally used by method `plot`.\n\n    Args:\n        color (str, default='viridis'): Matplotlib `Cmap`.\n        grid (bool, default=True): Show grid lines.\n\n    Returns:\n        (matplotlib.Streamplot):\n    \"\"\"\n    self.dF_args.update({name: slider.value for name, slider in self.sliders.items() if slider.value!= None})\n\n    self._create_arrays()\n\n    try:\n        for nullcline in self.nullclines:\n            nullcline.plot()\n    except AttributeError:\n        pass\n\n    if color is not None:\n        self.color = color\n\n    # if self.Polar:\n    #     self._PolarTransformation()\n    # else:\n    #     self._dX, self._dY = self.dF(self._X, self._Y, **self.dF_args)\n\n    # if utils.is_number(self._dX):\n    #     self._dX = self._X.copy() * 0 + self._dX\n    # if utils.is_number(self._dY):\n    #     self._dY = self._Y.copy() * 0 + self._dY\n\n\n\n    stream = self.streamplot_callback(self.dF, self._X, self._Y, self._Z,\n        dF_args=self.dF_args, polar=self.Polar, **self.streamplot_args)\n\n    try:\n        norm = stream._velocity_normalization()\n    except AttributeError:\n        norm = None\n    cmap = plt.get_cmap(self.color)\n\n    stream.plot(self.ax, cmap, norm, arrowsize=self.streamplot_args.get('arrow_width', 1))\n\n\n    self.ax.set_xlim3d(self.Range[0])\n    self.ax.set_ylim3d(self.Range[1])\n    self.ax.set_zlim3d(self.Range[2])\n    # self.ax.set_aspect(abs(self.Range[0,1]-self.Range[0,0])/abs(self.Range[1,1]-self.Range[1,0]))\n\n    self.ax.set_title(f'{self.Title}')\n    self.ax.set_xlabel(f'{self.xlabel}')\n    self.ax.set_ylabel(f'{self.ylabel}')\n    self.ax.set_zlabel(f'{self.zlabel}')\n    self.ax.set_xscale(self.xScale)\n    self.ax.set_yscale(self.yScale)\n    self.ax.set_zscale(self.zScale)\n\n\n\n\n    def log_tick_formatter(val, pos=None):\n        return r\"$10^{{{:.0f}}}$\".format(val)\n\n    if self.xScale in ['log', 'symlog']:\n        self.ax.xaxis.set_major_formatter(mticker.FuncFormatter(log_tick_formatter))\n    if self.yScale in ['log', 'symlog']:\n        self.ax.yaxis.set_major_formatter(mticker.FuncFormatter(log_tick_formatter))\n    if self.zScale in ['log', 'symlog']:\n        self.ax.zaxis.set_major_formatter(mticker.FuncFormatter(log_tick_formatter))\n\n    self.ax.grid(grid if grid is not None else self.grid)\n\n    return stream\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortrait3D/#phaseportrait.PhasePortrait3D.PhasePortrait3D.plot","title":"<code>plot(*, color=None, grid=None)</code>","text":"<p>Prepares the plots and computes the values.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Matplotlib <code>Cmap</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple(matplotlib Figure, matplotlib Axis)</code> Source code in <code>phaseportrait/PhasePortrait3D.py</code> <pre><code>def plot(self, *, color=None, grid=None):\n\"\"\"\n    Prepares the plots and computes the values.\n\n    Args: \n        color (str): Matplotlib `Cmap`.\n\n    Returns:\n        (tuple(matplotlib Figure, matplotlib Axis)):\n    \"\"\"\n    if color is not None:\n        self.color = color\n    if grid is not None:\n        self.grid = grid\n\n    self.stream = self.draw_plot(color=self.color, grid=grid)\n\n    if hasattr(self, \"colorbar_ax\"):\n        cb = plt.colorbar(mplcm.ScalarMappable(\n            norm=self.stream._velocity_normalization(), \n            cmap=self.color),\n        ax=self.ax,\n        cax=self.colorbar_ax)\n\n        self.colorbar_ax = cb.ax\n\n    self.fig.canvas.draw_idle()\n\n    return self.fig, self.ax \n</code></pre>"},{"location":"reference/phaseportrait/PhasePortraitManager/","title":"PhasePortraitManager","text":""},{"location":"reference/phaseportrait/PhasePortraitManager/#phaseportrait.PhasePortraitManager.PhasePortrait2DManager","title":"<code>PhasePortrait2DManager</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>phaseportrait/PhasePortraitManager.py</code> <pre><code>class PhasePortrait2DManager(object):\n    @staticmethod\n    def plot_from_json(json_str: str) -&gt; str:\n\"\"\"Returns a string containing SVG figure path for given json.\n        For a json example view `phaseportrait/examples/api_examples/phaseportrait2d_example.json`.\"\"\"\n        info = json.loads(json_str)\n\n        representation = PhasePortrait2D(lambda x,y:(x,y), [-1,1])\n\n        # Function\n        try:\n            match = re.search(r\"def\\s+(\\w+)\\(\", info['dF'])\n            function_name = match.group(1)\n            match = re.search(r\"(\\s+)def\", info['dF'])\n            if match is not None:\n                info['dF'] = info['dF'].replace(match.group(0), \"\\ndef\")\n            del match\n\n            exec(info['dF'], globals())\n            representation.dF = globals()[function_name]\n        except  Exception as e:\n            return 0\n\n        # Range\n        representation.Range = [[info['Range']['x_min'],info['Range']['x_max']],\n                                [info['Range']['y_min'],info['Range']['y_max']]]\n\n        # Parameters\n        kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xlabel', 'ylabel', 'color', 'xScale', 'yScale']\n        for k,v in info.items():\n            if k in kargs:\n                setattr(representation, k, v)\n\n        # Nullcline\n        try:\n            if nc:=info['nullcline']:\n                representation.add_nullclines(**nc)\n        except KeyError:\n            pass\n\n        # Plot and save\n        fig, ax = representation.plot()\n\n        # path = info['path']\n        # fig_name = time.strftime('%a%d%b%Y%H%M%SGMT',time.localtime())\n        # fig.savefig(path + fig_name +'.svg', transparent=True)\n\n        return fig\n        return fig_name + '.svg'\n\n\n    @staticmethod\n    def json_to_python_code(json_str: str) -&gt; str:\n\"\"\"Returns a string containing equivalent Python code for the given json.\n        For a json example view `phaseportrait/examples/api_examples/phaseportrait2d_example.json`.\"\"\"\n\n        info = json.loads(json_str)\n\n        match = re.search(r\"def\\s+(\\w+)\\(\", info['dF'])\n        function_name = match.group(1)\n\n        header = f\"\"\"from phaseportrait import *\\nimport matplotlib.pyplot as plt\"\"\"\n\n        function = f\"\"\"\\n{info['dF']}\"\"\"\n\n        portrait = f\"\"\"\\nphase_diagram = PhasePortrait2D({function_name}, [[{info['Range']['x_min']},{info['Range']['x_max']}],[{info['Range']['y_min']},{info['Range']['y_max']}]]\"\"\"\n\n        portrait_kargs = \"\"\n        kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xlabel', 'ylabel', 'color', 'xScale', 'yScale']\n        first = True\n        for k in info.keys():\n            if k in kargs:\n                if info[k]:\n                    if first:\n                        portrait += \",\"\n                        first = False\n                    if isinstance(info[k], str):\n                        portrait_kargs += f\"\\t{k} = '{info[k]}',\\n\"\n                    else:\n                        portrait_kargs += f\"\\t{k} = {info[k]},\\n\"\n\n        if first:\n            portrait += ')\\n'\n        else:\n            portrait_kargs += ')\\n'\n\n        nullcline = ''\n        if nc := info.get('nullcline'):\n            nullcline = f\"\\nphase_diagram.add_nullclines(precision={nc['precision']}, offset={nc['offset']})\"\n\n        finisher = '\\nphase_diagram.plot()\\nplt.show()'\n\n        return header +\"\\n\\t\\n\"+ function +\"\\n\\t\\n\"+ portrait +\"\\n\"+ portrait_kargs +\"\\n\\t\\n\"+ nullcline +\"\\n\\t\\n\"+ finisher\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortraitManager/#phaseportrait.PhasePortraitManager.PhasePortrait2DManager.json_to_python_code","title":"<code>json_to_python_code(json_str)</code>  <code>staticmethod</code>","text":"<p>Returns a string containing equivalent Python code for the given json. For a json example view <code>phaseportrait/examples/api_examples/phaseportrait2d_example.json</code>.</p> Source code in <code>phaseportrait/PhasePortraitManager.py</code> <pre><code>@staticmethod\ndef json_to_python_code(json_str: str) -&gt; str:\n\"\"\"Returns a string containing equivalent Python code for the given json.\n    For a json example view `phaseportrait/examples/api_examples/phaseportrait2d_example.json`.\"\"\"\n\n    info = json.loads(json_str)\n\n    match = re.search(r\"def\\s+(\\w+)\\(\", info['dF'])\n    function_name = match.group(1)\n\n    header = f\"\"\"from phaseportrait import *\\nimport matplotlib.pyplot as plt\"\"\"\n\n    function = f\"\"\"\\n{info['dF']}\"\"\"\n\n    portrait = f\"\"\"\\nphase_diagram = PhasePortrait2D({function_name}, [[{info['Range']['x_min']},{info['Range']['x_max']}],[{info['Range']['y_min']},{info['Range']['y_max']}]]\"\"\"\n\n    portrait_kargs = \"\"\n    kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xlabel', 'ylabel', 'color', 'xScale', 'yScale']\n    first = True\n    for k in info.keys():\n        if k in kargs:\n            if info[k]:\n                if first:\n                    portrait += \",\"\n                    first = False\n                if isinstance(info[k], str):\n                    portrait_kargs += f\"\\t{k} = '{info[k]}',\\n\"\n                else:\n                    portrait_kargs += f\"\\t{k} = {info[k]},\\n\"\n\n    if first:\n        portrait += ')\\n'\n    else:\n        portrait_kargs += ')\\n'\n\n    nullcline = ''\n    if nc := info.get('nullcline'):\n        nullcline = f\"\\nphase_diagram.add_nullclines(precision={nc['precision']}, offset={nc['offset']})\"\n\n    finisher = '\\nphase_diagram.plot()\\nplt.show()'\n\n    return header +\"\\n\\t\\n\"+ function +\"\\n\\t\\n\"+ portrait +\"\\n\"+ portrait_kargs +\"\\n\\t\\n\"+ nullcline +\"\\n\\t\\n\"+ finisher\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortraitManager/#phaseportrait.PhasePortraitManager.PhasePortrait2DManager.plot_from_json","title":"<code>plot_from_json(json_str)</code>  <code>staticmethod</code>","text":"<p>Returns a string containing SVG figure path for given json. For a json example view <code>phaseportrait/examples/api_examples/phaseportrait2d_example.json</code>.</p> Source code in <code>phaseportrait/PhasePortraitManager.py</code> <pre><code>@staticmethod\ndef plot_from_json(json_str: str) -&gt; str:\n\"\"\"Returns a string containing SVG figure path for given json.\n    For a json example view `phaseportrait/examples/api_examples/phaseportrait2d_example.json`.\"\"\"\n    info = json.loads(json_str)\n\n    representation = PhasePortrait2D(lambda x,y:(x,y), [-1,1])\n\n    # Function\n    try:\n        match = re.search(r\"def\\s+(\\w+)\\(\", info['dF'])\n        function_name = match.group(1)\n        match = re.search(r\"(\\s+)def\", info['dF'])\n        if match is not None:\n            info['dF'] = info['dF'].replace(match.group(0), \"\\ndef\")\n        del match\n\n        exec(info['dF'], globals())\n        representation.dF = globals()[function_name]\n    except  Exception as e:\n        return 0\n\n    # Range\n    representation.Range = [[info['Range']['x_min'],info['Range']['x_max']],\n                            [info['Range']['y_min'],info['Range']['y_max']]]\n\n    # Parameters\n    kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xlabel', 'ylabel', 'color', 'xScale', 'yScale']\n    for k,v in info.items():\n        if k in kargs:\n            setattr(representation, k, v)\n\n    # Nullcline\n    try:\n        if nc:=info['nullcline']:\n            representation.add_nullclines(**nc)\n    except KeyError:\n        pass\n\n    # Plot and save\n    fig, ax = representation.plot()\n\n    # path = info['path']\n    # fig_name = time.strftime('%a%d%b%Y%H%M%SGMT',time.localtime())\n    # fig.savefig(path + fig_name +'.svg', transparent=True)\n\n    return fig\n    return fig_name + '.svg'\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortraitManager/#phaseportrait.PhasePortraitManager.PhasePortrait3DManager","title":"<code>PhasePortrait3DManager</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>phaseportrait/PhasePortraitManager.py</code> <pre><code>class PhasePortrait3DManager(object):\n    @staticmethod\n    def plot_from_json(json_str: str) -&gt; str:\n\"\"\"Returns a string containing SVG figure path for given json.\n        For a json example view `phaseportrait/examples/api_examples/phaseportrait3D_example.json`.\"\"\"\n        info = json.loads(json_str)\n\n        representation = PhasePortrait3D(lambda x,y,z:(x,y,-z), [[-1,1]*3])\n\n        # Function\n        try:\n            match = re.search(r\"def\\s+(\\w+)\\(\", info['dF'])\n            function_name = match.group(1)\n            match = re.search(r\"(\\s+)def\", info['dF'])\n            if match is not None:\n                info['dF'] = info['dF'].replace(match.group(0), \"\\ndef\")\n            del match\n\n            exec(info['dF'], globals())\n            representation.dF = globals()[function_name]\n        except  Exception as e:\n            return 0\n\n        # Range\n        representation.Range = [[info['Range']['x_min'],info['Range']['x_max']],\n                                [info['Range']['y_min'],info['Range']['y_max']],\n                                [info['Range']['z_min'],info['Range']['z_max']]]\n\n        # Parameters\n        kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xlabel', 'ylabel', 'zlabel', 'color', 'xScale', 'yScale', 'zScale']\n        for k,v in info.items():\n            if k in kargs:\n                setattr(representation, k, v)\n\n        # Nullcline\n        try:\n            if nc:=info['nullcline']:\n                representation.add_nullclines(**nc)\n        except KeyError:\n            pass\n\n        # Plot and save\n        fig, ax = representation.plot()\n\n        # path = info['path']\n        # fig_name = time.strftime('%a%d%b%Y%H%M%SGMT',time.localtime())\n        # fig.savefig(path + fig_name +'.svg', transparent=True)\n\n        return fig\n        return fig_name + '.svg'\n\n\n    @staticmethod\n    def json_to_python_code(json_str: str) -&gt; str:\n\"\"\"Returns a string containing equivalent Python code for the given json.\"\"\"\n\n        info = json.loads(json_str)\n\n        match = re.search(r\"def\\s+(\\w+)\\(\", info['dF'])\n        function_name = match.group(1)\n\n        header = f\"\"\"from phaseportrait import *\\nimport matplotlib.pyplot as plt\"\"\"\n\n        function = f\"\"\"\\n{info['dF']}\"\"\"\n\n        portrait = f\"\"\"\\nphase_diagram = PhasePortrait3D({function_name}, [[{info['Range']['x_min']},{info['Range']['x_max']}],[{info['Range']['y_min']},{info['Range']['y_max']}],[{info['Range']['z_min']},{info['Range']['z_max']}]]\"\"\"\n\n        portrait_kargs = \"\"\n        kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xlabel', 'ylabel', 'zlabel', 'color', 'xScale', 'yScale', 'zScale']\n        first = True\n        for k in info.keys():\n            if k in kargs:\n                if info[k]:\n                    if first:\n                        portrait += \",\"\n                        first = False\n                    if isinstance(info[k], str):\n                        portrait_kargs += f\"\\t{k} = '{info[k]}',\\n\"\n                    else:\n                        portrait_kargs += f\"\\t{k} = {info[k]},\\n\"\n\n        if first:\n            portrait += ')\\n'\n        else:\n            portrait_kargs += ')\\n'\n\n        nullcline = ''\n        if nc := info.get('nullcline'):\n            nullcline = f\"\\nphase_diagram.add_nullclines(precision={nc['precision']}, offset={nc['offset']})\"\n\n        finisher = '\\nphase_diagram.plot()\\nplt.show()'\n\n        return header +\"\\n\\t\\n\"+ function +\"\\n\\t\\n\"+ portrait +\"\\n\"+ portrait_kargs +\"\\n\\t\\n\"+ nullcline +\"\\n\\t\\n\"+ finisher\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortraitManager/#phaseportrait.PhasePortraitManager.PhasePortrait3DManager.json_to_python_code","title":"<code>json_to_python_code(json_str)</code>  <code>staticmethod</code>","text":"<p>Returns a string containing equivalent Python code for the given json.</p> Source code in <code>phaseportrait/PhasePortraitManager.py</code> <pre><code>@staticmethod\ndef json_to_python_code(json_str: str) -&gt; str:\n\"\"\"Returns a string containing equivalent Python code for the given json.\"\"\"\n\n    info = json.loads(json_str)\n\n    match = re.search(r\"def\\s+(\\w+)\\(\", info['dF'])\n    function_name = match.group(1)\n\n    header = f\"\"\"from phaseportrait import *\\nimport matplotlib.pyplot as plt\"\"\"\n\n    function = f\"\"\"\\n{info['dF']}\"\"\"\n\n    portrait = f\"\"\"\\nphase_diagram = PhasePortrait3D({function_name}, [[{info['Range']['x_min']},{info['Range']['x_max']}],[{info['Range']['y_min']},{info['Range']['y_max']}],[{info['Range']['z_min']},{info['Range']['z_max']}]]\"\"\"\n\n    portrait_kargs = \"\"\n    kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xlabel', 'ylabel', 'zlabel', 'color', 'xScale', 'yScale', 'zScale']\n    first = True\n    for k in info.keys():\n        if k in kargs:\n            if info[k]:\n                if first:\n                    portrait += \",\"\n                    first = False\n                if isinstance(info[k], str):\n                    portrait_kargs += f\"\\t{k} = '{info[k]}',\\n\"\n                else:\n                    portrait_kargs += f\"\\t{k} = {info[k]},\\n\"\n\n    if first:\n        portrait += ')\\n'\n    else:\n        portrait_kargs += ')\\n'\n\n    nullcline = ''\n    if nc := info.get('nullcline'):\n        nullcline = f\"\\nphase_diagram.add_nullclines(precision={nc['precision']}, offset={nc['offset']})\"\n\n    finisher = '\\nphase_diagram.plot()\\nplt.show()'\n\n    return header +\"\\n\\t\\n\"+ function +\"\\n\\t\\n\"+ portrait +\"\\n\"+ portrait_kargs +\"\\n\\t\\n\"+ nullcline +\"\\n\\t\\n\"+ finisher\n</code></pre>"},{"location":"reference/phaseportrait/PhasePortraitManager/#phaseportrait.PhasePortraitManager.PhasePortrait3DManager.plot_from_json","title":"<code>plot_from_json(json_str)</code>  <code>staticmethod</code>","text":"<p>Returns a string containing SVG figure path for given json. For a json example view <code>phaseportrait/examples/api_examples/phaseportrait3D_example.json</code>.</p> Source code in <code>phaseportrait/PhasePortraitManager.py</code> <pre><code>@staticmethod\ndef plot_from_json(json_str: str) -&gt; str:\n\"\"\"Returns a string containing SVG figure path for given json.\n    For a json example view `phaseportrait/examples/api_examples/phaseportrait3D_example.json`.\"\"\"\n    info = json.loads(json_str)\n\n    representation = PhasePortrait3D(lambda x,y,z:(x,y,-z), [[-1,1]*3])\n\n    # Function\n    try:\n        match = re.search(r\"def\\s+(\\w+)\\(\", info['dF'])\n        function_name = match.group(1)\n        match = re.search(r\"(\\s+)def\", info['dF'])\n        if match is not None:\n            info['dF'] = info['dF'].replace(match.group(0), \"\\ndef\")\n        del match\n\n        exec(info['dF'], globals())\n        representation.dF = globals()[function_name]\n    except  Exception as e:\n        return 0\n\n    # Range\n    representation.Range = [[info['Range']['x_min'],info['Range']['x_max']],\n                            [info['Range']['y_min'],info['Range']['y_max']],\n                            [info['Range']['z_min'],info['Range']['z_max']]]\n\n    # Parameters\n    kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xlabel', 'ylabel', 'zlabel', 'color', 'xScale', 'yScale', 'zScale']\n    for k,v in info.items():\n        if k in kargs:\n            setattr(representation, k, v)\n\n    # Nullcline\n    try:\n        if nc:=info['nullcline']:\n            representation.add_nullclines(**nc)\n    except KeyError:\n        pass\n\n    # Plot and save\n    fig, ax = representation.plot()\n\n    # path = info['path']\n    # fig_name = time.strftime('%a%d%b%Y%H%M%SGMT',time.localtime())\n    # fig.savefig(path + fig_name +'.svg', transparent=True)\n\n    return fig\n    return fig_name + '.svg'\n</code></pre>"},{"location":"reference/phaseportrait/Trajectories2D/","title":"Trajectories2D","text":""},{"location":"reference/phaseportrait/Trajectories2D/#phaseportrait.Trajectories2D.Trajectory2D","title":"<code>Trajectory2D</code>","text":"<p>         Bases: <code>trajectory</code></p>"},{"location":"reference/phaseportrait/Trajectories2D/#phaseportrait.Trajectories2D.Trajectory2D--trajectory2d","title":"Trajectory2D","text":"<p>Class dedicated to compute and represent trajectories in 2D.</p>"},{"location":"reference/phaseportrait/Trajectories2D/#phaseportrait.Trajectories2D.Trajectory2D--methods","title":"Methods","text":"<ul> <li>thermalize : Adds thermalization steps and random initial position.</li> <li>initial_position : Adds a trajectory with the given initial position.</li> <li>plot : Prepares the plots and computes the values. Returns the axis and the figure.</li> <li>add_slider : Adds a <code>Slider</code> for the <code>dF</code> function.</li> <li>_prepare_plot : Prepares the plots.</li> <li>_scatter_start_point : Scatter all the start points.</li> <li>_scatter_trajectory : Scatter all the trajectories.</li> <li>_plot_lines : Plots the lines of all the trajectories.</li> <li>_create_sliders_plot : Creates the sliders plot.</li> </ul> Source code in <code>phaseportrait/Trajectories2D.py</code> <pre><code>class Trajectory2D(trajectory):\n\"\"\"\n    Trajectory2D\n    ----------\n    Class dedicated to compute and represent trajectories in 2D.\n\n    Methods\n    -------\n    * thermalize : Adds thermalization steps and random initial position.\n    * initial_position : Adds a trajectory with the given initial position.\n    * plot : Prepares the plots and computes the values. Returns the axis and the figure.\n    * add_slider : Adds a `Slider` for the `dF` function.\n    * _prepare_plot : Prepares the plots.\n    * _scatter_start_point : Scatter all the start points.\n    * _scatter_trajectory : Scatter all the trajectories.\n    * _plot_lines : Plots the lines of all the trajectories.\n    * _create_sliders_plot : Creates the sliders plot.\n    \"\"\" \n\n    _name_ = 'Trajectory2D'\n\n    def __init__(self, dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs):\n\"\"\"\n        Creates an instance of Trjaectoy2D\n\n        Args:\n            dF (callable) : A `dF` type function.\n            Range (list, optional) : Ranges if the axis in the main plot, by default None\n            dF_args (dict, optional) : If necesary, must contain the kargs for the `dF` function, by default {}\n            n_points (int, optional) : Maximum number of points to be calculated and represented, by default 10000\n            runge_kutta_step (float, optional) : Step of 'time' in the Runge-Kutta method, by default 0.01\n            runge_kutta_freq (int, optional) : Number of times `dF` is aplied between positions saved, by default 1\n            xlabel (str, optional) : x label of the plot, by default 'X'\n            ylabel (str, optional) : y label of the plot, by default 'Y'\n        \"\"\"\n\n        super().__init__(dF, 2, Range=Range, dF_args=dF_args, n_points=n_points, runge_kutta_step=runge_kutta_step, runge_kutta_freq=runge_kutta_freq, **kargs)\n\n        # Variables for plots\n        self.xlabel = kargs['xlabel'] if kargs.get('xlabel') else 'X'\n        self.ylabel = kargs['ylabel'] if kargs.get('ylabel') else 'Y'\n\n\n        figZ, axZ= plt.subplots()\n\n        self.fig = {\n            'Z': figZ,\n        }\n        self.ax = {\n            'Z': axZ,\n        }\n\n\n    def _plot_lines(self, val, vel, val_init, *, cnorm=None):\n        label = f\"({','.join(tuple(map(str, val_init)))})\"\n\n        val_ = val.T.reshape(-1, 1, 2)\n        segments = np.concatenate([val_[:-1], val_[1:]], axis=1)\n\n        vel_ = np.sqrt(np.sum(np.square(vel), axis=0))\n        if cnorm is None:\n            cnorm = Normalize(vel_.min(), vel_.max())\n        C = plt.get_cmap(self.color)(cnorm(vel_))\n\n        linez = LineCollection(segments[:,:,(0,1)], linewidth=self.size, color=C, label=label)\n        self.ax['Z'].add_collection(linez)\n        self.ax['Z'].plot([val_init[0],val[0,0]], [val_init[1], val[1,0]], '-', linewidth=self.size, color=C[0], zorder=-1)\n        # self.ax['Z'].plot(val[0,1:], val[1,1:], label=f\"({','.join(tuple(map(str, val_init)))})\")\n\n\n    def _scatter_start_point(self, val_init):\n        self.ax['Z'].scatter(val_init[0], val_init[1], s=self.size+1, c=[0])\n\n\n    def _scatter_trajectory(self, val, color, cmap):\n        self.ax['Z'].scatter(val[0,:], val[1,:], s=self.size, c=color, cmap=cmap)\n\n\n    def _prepare_plot(self, grid=False):\n        for coord, r0, r1, x_label, y_label in [\n            ('Z', 0, 1, self.xlabel, self.ylabel),\n        ]:\n\n            self.ax[coord].set_title(f'{self.Title}')\n            if self.Range is not None:\n                self.ax[coord].set_xlim(self.Range[r0,:])\n                self.ax[coord].set_ylim(self.Range[r1,:])\n            self.ax[coord].set_xlabel(f'{x_label}')\n            self.ax[coord].set_ylabel(f'{y_label}')\n            self.ax[coord].grid(grid)\n</code></pre>"},{"location":"reference/phaseportrait/Trajectories2D/#phaseportrait.Trajectories2D.Trajectory2D.__init__","title":"<code>__init__(dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs)</code>","text":"<p>Creates an instance of Trjaectoy2D</p> <p>Parameters:</p> Name Type Description Default <code>dF</code> <code>callable) </code> <p>A <code>dF</code> type function.</p> required <code>Range</code> <code>list, optional) </code> <p>Ranges if the axis in the main plot, by default None</p> <code>None</code> <code>dF_args</code> <code>dict, optional) </code> <p>If necesary, must contain the kargs for the <code>dF</code> function, by default {}</p> <code>{}</code> <code>n_points</code> <code>int, optional) </code> <p>Maximum number of points to be calculated and represented, by default 10000</p> <code>10000</code> <code>runge_kutta_step</code> <code>float, optional) </code> <p>Step of 'time' in the Runge-Kutta method, by default 0.01</p> <code>0.01</code> <code>runge_kutta_freq</code> <code>int, optional) </code> <p>Number of times <code>dF</code> is aplied between positions saved, by default 1</p> <code>1</code> <code>xlabel</code> <code>str, optional) </code> <p>x label of the plot, by default 'X'</p> required <code>ylabel</code> <code>str, optional) </code> <p>y label of the plot, by default 'Y'</p> required Source code in <code>phaseportrait/Trajectories2D.py</code> <pre><code>def __init__(self, dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs):\n\"\"\"\n    Creates an instance of Trjaectoy2D\n\n    Args:\n        dF (callable) : A `dF` type function.\n        Range (list, optional) : Ranges if the axis in the main plot, by default None\n        dF_args (dict, optional) : If necesary, must contain the kargs for the `dF` function, by default {}\n        n_points (int, optional) : Maximum number of points to be calculated and represented, by default 10000\n        runge_kutta_step (float, optional) : Step of 'time' in the Runge-Kutta method, by default 0.01\n        runge_kutta_freq (int, optional) : Number of times `dF` is aplied between positions saved, by default 1\n        xlabel (str, optional) : x label of the plot, by default 'X'\n        ylabel (str, optional) : y label of the plot, by default 'Y'\n    \"\"\"\n\n    super().__init__(dF, 2, Range=Range, dF_args=dF_args, n_points=n_points, runge_kutta_step=runge_kutta_step, runge_kutta_freq=runge_kutta_freq, **kargs)\n\n    # Variables for plots\n    self.xlabel = kargs['xlabel'] if kargs.get('xlabel') else 'X'\n    self.ylabel = kargs['ylabel'] if kargs.get('ylabel') else 'Y'\n\n\n    figZ, axZ= plt.subplots()\n\n    self.fig = {\n        'Z': figZ,\n    }\n    self.ax = {\n        'Z': axZ,\n    }\n</code></pre>"},{"location":"reference/phaseportrait/Trajectories3D/","title":"Trajectories3D","text":""},{"location":"reference/phaseportrait/Trajectories3D/#phaseportrait.Trajectories3D.Trajectory3D","title":"<code>Trajectory3D</code>","text":"<p>         Bases: <code>trajectory</code></p>"},{"location":"reference/phaseportrait/Trajectories3D/#phaseportrait.Trajectories3D.Trajectory3D--trajectory3d","title":"Trajectory3D","text":"<p>Class dedicated to compute and represent trajectories in 2D.</p>"},{"location":"reference/phaseportrait/Trajectories3D/#phaseportrait.Trajectories3D.Trajectory3D--methods","title":"Methods","text":"<ul> <li>thermalize : Adds thermalization steps and random initial position. </li> <li>initial_position : Adds a trajectory with the given initial position. </li> <li>plot : Prepares the plots and computes the values.  Returns the axis and the figure. </li> <li>add_slider : Adds a <code>Slider</code> for the <code>dF</code> function. </li> <li>_prepare_plot : Prepares the plots. </li> <li>_scatter_start_point : Scatter all the start points. </li> <li>_scatter_trajectory : Scatter all the trajectories. </li> <li>_plot_lines : Plots the lines of all the trajectories. </li> <li>_create_sliders_plot : Creates the sliders plot.</li> </ul> Source code in <code>phaseportrait/Trajectories3D.py</code> <pre><code>class Trajectory3D(trajectory):\n\"\"\"\n    Trajectory3D\n    ----------\n    Class dedicated to compute and represent trajectories in 2D.\n\n    Methods\n    -------    \n    * thermalize : Adds thermalization steps and random initial position. \n    * initial_position : Adds a trajectory with the given initial position. \n    * plot : Prepares the plots and computes the values.  Returns the axis and the figure. \n    * add_slider : Adds a `Slider` for the `dF` function. \n    * _prepare_plot : Prepares the plots. \n    * _scatter_start_point : Scatter all the start points. \n    * _scatter_trajectory : Scatter all the trajectories. \n    * _plot_lines : Plots the lines of all the trajectories. \n    * _create_sliders_plot : Creates the sliders plot.\n    \"\"\" \n    _name_ = 'Trajectory3D'\n\n    def __init__(self, dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs):\n\"\"\"\n        Creates an instance of Trajectory3D\n\n        Args:\n            dF (callable) :A `dF` type function.\n            Range (list, optional) :Ranges of the axis in the main plot, by default None\n            dF_args (dict, optional) :If necesary, must contain the kargs for the `dF` function, by default {}\n            n_points (int, optional) :Maximum number of points to be calculated and represented, by default 10000\n            runge_kutta_step (float, optional) :Step of 'time' in the Runge-Kutta method, by default 0.01\n            runge_kutta_freq (int, optional) :Number of times `dF` is aplied between positions saved, by default 1\n            xlabel (str, optional) :x label of the plot, by default 'X'\n            ylabel (str, optional) :y label of the plot, by default 'Y'\n            zlabel (str, optional) :z label of the plot, by default 'Z'\n        \"\"\"\n\n        super().__init__(dF, 3, Range=Range, dF_args=dF_args, n_points=n_points, runge_kutta_step=runge_kutta_step, runge_kutta_freq=runge_kutta_freq, **kargs)\n\n        self.xlabel = kargs['xlabel'] if kargs.get('xlabel') else 'X'\n        self.ylabel = kargs['ylabel'] if kargs.get('ylabel') else 'Y'\n        self.zlabel = kargs['zlabel'] if kargs.get('zlabel') else 'Z'\n\n\n        # Variables for plots\n        figX, axX= plt.subplots()\n        figY, axY= plt.subplots()\n        figZ, axZ= plt.subplots()\n        fig3d = plt.figure()\n        ax3d = fig3d.add_subplot(projection='3d')\n\n        self.fig = {\n            'X': figX,\n            'Y': figY,\n            'Z': figZ,\n            '3d': fig3d\n        }\n        self.ax = {\n            'X': axX,\n            'Y': axY,\n            'Z': axZ,\n            '3d': ax3d\n        }\n\n\n    def _plot_lines(self, val, vel, val_init, *, cnorm=None):\n        label = f\"({','.join(tuple(map(str, val_init)))})\"\n\n        val_ = val.T.reshape(-1, 1, 3)\n        segments = np.concatenate([val_[:-1], val_[1:]], axis=1)\n\n        vel_ = np.sqrt(np.sum(np.square(vel), axis=0))\n        if cnorm is None:\n            cnorm = Normalize(vel_.min(), vel_.max())\n        C = plt.get_cmap(self.color)(cnorm(vel_))\n        line3d = Line3DCollection(segments, linewidth=self.size, color=C, label=label)\n        linex = LineCollection(segments[:,:,(1,2)], linewidth=self.size, color=C, label=label)\n        liney = LineCollection(segments[:,:,(0,2)], linewidth=self.size, color=C, label=label)\n        linez = LineCollection(segments[:,:,(0,1)], linewidth=self.size, color=C, label=label)\n\n\n\n        self.ax['3d'].add_collection(line3d)\n        self.ax['X'].add_collection(linex)\n        self.ax['Y'].add_collection(liney)\n        self.ax['Z'].add_collection(linez)\n\n\n\n        self.ax['3d'].plot(*[[val_init[i],val[i,0]] for i in range(3)], '-', linewidth=self.size, color=C[0])\n        self.ax['X'].plot([val_init[1],val[1,0]], [val_init[2], val[2,0]], '-', linewidth=self.size, color=C[0], zorder=-1)\n        self.ax['Y'].plot([val_init[0],val[0,0]], [val_init[2], val[2,0]], '-', linewidth=self.size, color=C[0], zorder=-1)\n        self.ax['Z'].plot([val_init[0],val[0,0]], [val_init[1], val[1,0]], '-', linewidth=self.size, color=C[0], zorder=-1)\n        self._update_3d_lims()\n\n    def _update_3d_lims(self):\n        self.ax['3d'].set_xlim(self.ax['Y'].get_xlim())\n        self.ax['3d'].set_ylim(self.ax['Z'].get_xlim())\n        self.ax['3d'].set_zlim(self.ax['X'].get_ylim())\n\n\n    def _scatter_start_point(self, val_init):\n        self.ax['3d'].scatter3D(*val_init, s=self.size*2, c=[0])\n        self.ax['X'].scatter(val_init[1], val_init[2], s=self.size*2, c=[0])\n        self.ax['Y'].scatter(val_init[0], val_init[2], s=self.size*2, c=[0])\n        self.ax['Z'].scatter(val_init[0], val_init[1], s=self.size*2, c=[0])\n\n\n    def _scatter_trajectory(self, val, color, cmap):\n        self.ax['3d'].scatter3D(*val, s=self.size, c=color, cmap=cmap)\n        self.ax['X'].scatter(val[1,:], val[2,:], s=self.size, c=color, cmap=cmap)\n        self.ax['Y'].scatter(val[0,:], val[2,:], s=self.size, c=color, cmap=cmap)\n        self.ax['Z'].scatter(val[0,:], val[1,:], s=self.size, c=color, cmap=cmap)\n        self._update_3d_lims()\n\n\n    def _prepare_plot(self, grid=False):\n        self.ax['3d'].set_title(f'{self.Title}')\n        if self.Range is not None:\n            self.ax['3d'].set_xlim(self.Range[0,:])\n            self.ax['3d'].set_ylim(self.Range[1,:])\n            self.ax['3d'].set_zlim(self.Range[2,:])\n        self.ax['3d'].set_xlabel(f'{self.xlabel}')\n        self.ax['3d'].set_ylabel(f'{self.ylabel}')\n        self.ax['3d'].set_zlabel(f'{self.zlabel}')\n        self.ax['3d'].grid(grid)\n\n        for coord, r0, r1, title, x_label, y_label in [\n            ('X', 1, 2, 'YZ', self.ylabel, self.zlabel),\n            ('Y', 0, 2, 'XZ', self.xlabel, self.zlabel),\n            ('Z', 0, 1, 'XY', self.xlabel, self.ylabel),\n        ]:\n\n            self.ax[coord].set_title(f'{self.Title}: {title}')\n            if self.Range is not None:\n                self.ax[coord].set_xlim(self.Range[r0,:])\n                self.ax[coord].set_ylim(self.Range[r1,:])\n            self.ax[coord].set_xlabel(f'{x_label}')\n            self.ax[coord].set_ylabel(f'{y_label}')\n            self.ax[coord].grid(grid)\n</code></pre>"},{"location":"reference/phaseportrait/Trajectories3D/#phaseportrait.Trajectories3D.Trajectory3D.__init__","title":"<code>__init__(dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs)</code>","text":"<p>Creates an instance of Trajectory3D</p> <p>Parameters:</p> Name Type Description Default <code>dF</code> <code>callable) </code> <p>A <code>dF</code> type function.</p> required <code>Range</code> <code>list, optional) </code> <p>Ranges of the axis in the main plot, by default None</p> <code>None</code> <code>dF_args</code> <code>dict, optional) </code> <p>If necesary, must contain the kargs for the <code>dF</code> function, by default {}</p> <code>{}</code> <code>n_points</code> <code>int, optional) </code> <p>Maximum number of points to be calculated and represented, by default 10000</p> <code>10000</code> <code>runge_kutta_step</code> <code>float, optional) </code> <p>Step of 'time' in the Runge-Kutta method, by default 0.01</p> <code>0.01</code> <code>runge_kutta_freq</code> <code>int, optional) </code> <p>Number of times <code>dF</code> is aplied between positions saved, by default 1</p> <code>1</code> <code>xlabel</code> <code>str, optional) </code> <p>x label of the plot, by default 'X'</p> required <code>ylabel</code> <code>str, optional) </code> <p>y label of the plot, by default 'Y'</p> required <code>zlabel</code> <code>str, optional) </code> <p>z label of the plot, by default 'Z'</p> required Source code in <code>phaseportrait/Trajectories3D.py</code> <pre><code>def __init__(self, dF, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs):\n\"\"\"\n    Creates an instance of Trajectory3D\n\n    Args:\n        dF (callable) :A `dF` type function.\n        Range (list, optional) :Ranges of the axis in the main plot, by default None\n        dF_args (dict, optional) :If necesary, must contain the kargs for the `dF` function, by default {}\n        n_points (int, optional) :Maximum number of points to be calculated and represented, by default 10000\n        runge_kutta_step (float, optional) :Step of 'time' in the Runge-Kutta method, by default 0.01\n        runge_kutta_freq (int, optional) :Number of times `dF` is aplied between positions saved, by default 1\n        xlabel (str, optional) :x label of the plot, by default 'X'\n        ylabel (str, optional) :y label of the plot, by default 'Y'\n        zlabel (str, optional) :z label of the plot, by default 'Z'\n    \"\"\"\n\n    super().__init__(dF, 3, Range=Range, dF_args=dF_args, n_points=n_points, runge_kutta_step=runge_kutta_step, runge_kutta_freq=runge_kutta_freq, **kargs)\n\n    self.xlabel = kargs['xlabel'] if kargs.get('xlabel') else 'X'\n    self.ylabel = kargs['ylabel'] if kargs.get('ylabel') else 'Y'\n    self.zlabel = kargs['zlabel'] if kargs.get('zlabel') else 'Z'\n\n\n    # Variables for plots\n    figX, axX= plt.subplots()\n    figY, axY= plt.subplots()\n    figZ, axZ= plt.subplots()\n    fig3d = plt.figure()\n    ax3d = fig3d.add_subplot(projection='3d')\n\n    self.fig = {\n        'X': figX,\n        'Y': figY,\n        'Z': figZ,\n        '3d': fig3d\n    }\n    self.ax = {\n        'X': axX,\n        'Y': axY,\n        'Z': axZ,\n        '3d': ax3d\n    }\n</code></pre>"},{"location":"reference/phaseportrait/exceptions/exceptions/","title":"Exceptions","text":""},{"location":"reference/phaseportrait/generators_base/generator_base/","title":"Generator base","text":""},{"location":"reference/phaseportrait/maps/map/","title":"Map","text":""},{"location":"reference/phaseportrait/maps/map/#phaseportrait.maps.map.Map","title":"<code>Map</code>","text":"<p>         Bases: <code>_Generator_</code></p> <p>This class is an implementation of Generator for maps generators.</p> Source code in <code>phaseportrait/maps/map.py</code> <pre><code>class Map(_Generator_):\n\"\"\"\n    This class is an implementation of _Generator_ for maps generators.\n    \"\"\"\n    def __init__(self, portrait, dF, dimension, max_values, *, dF_args=None, initial_values=None, thermalization=0, **kargs):\n\"\"\"\n        Args:\n            portrait (Object) : Class that uses the RungeKutta objects.\n            dF (callable) : A dF type funcion.\n            dimension (int) : Number of dimensions in which it calculates the next values. Must equal the amount of outputs the `dF` funcion gives.\n            max_values (int) : Max number of values saved.\n            dF_args (dict) : If necesary, must contain the kargs for the `dF` funcion. By default, None.\n            initial_values (float, list, optional) : Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate.\n            thermalization (int, optional) : Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0.\n        \"\"\"\n        super().__init__(portrait, dF, dimension, max_values, dF_args=dF_args,\n                         initial_values=initial_values, thermalization=thermalization, **kargs)\n\n        self.positions = self._create_values_array()\n    @classmethod\n    def _instance_and_compute_all(cls, tup):\n        instance = cls(tup[0], tup[1], tup[2], tup[3], dF_args=tup[4], initial_values=tup[5], thermalization=tup[6])\n\n        max_index = instance.compute_all(limit_cycle_check=tup[7], delta=tup[8])\n        if max_index is not None:\n            instance.positions = instance.positions[:,0:max_index-1]\n        return instance\n    @classmethod\n    def instance_and_compute_all(cls, portrait, dF, dimension, max_values, dF_args, initial_values, save_freq, thermalization, **kargs):\n\"\"\"Creates an instance of phase-portrait.maps.Map. \n        Computes all the data requested and returns the instance.\n\n        Args:\n            portrait (Object) : Class that uses the RungeKutta objects.\n            dF (callable) : A dF type funcion.\n            dimension (int) : Number of dimensions in which it calculates the next values. Must equal the amount of outputs the `dF` funcion gives.\n            max_values (int) : Max number of values saved.\n            dF_args (dict) : If necesary, must contain the kargs for the `dF` funcion. By default, None.\n            initial_values (float, list, optional) : Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat\n            save_freq (int, optional, by default 1) : Number of values computed before saving them.\n            thermalization (int, optional) : Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0.\n            limit_cycle_check (int, bool, optional, by default False) : Whenever to check it there os a limit cycle in the data.\n            delta (float, optional, by default 0.01) : If `limit_cycle_check==True` is the distance between data elements to be considerated equal.\n\n        Returns:\n            (phaseportrait.maps.Map): The instance with all the data requested\n        \"\"\"\n\n        instance = cls(portrait, dF, dimension, max_values, dF_args=dF_args,\n                       initial_values=initial_values, save_freq=save_freq, thermalization=thermalization, **kargs)\n\n        max_index = instance.compute_all(**kargs)\n        if max_index is not None:\n            instance.positions = instance.positions[:,0:max_index-1]\n        return instance\n\n    def _next(self): \n\"\"\"\n        Generates from `self.position` its following value.\n        \"\"\"\n        self.position[0] = self.dF(*(self.position), **self.dF_args)\n\n    def save(self, i):\n\"\"\"\n        Saves `self.position` in the attribute `self.positions`.\n\n        Args:\n            i (int) : Index in which the data is saved.\n        \"\"\"\n        try:\n            self.positions[:, i] = self.position\n        except IndexError:\n            np.concatenate(self.positions, self._create_values_array(), axis=1)\n            self.max_values *= 2\n            self.save(i)\n\n    def clear_values(self):\n\"\"\"\n        Clears the data arrays `self.positions`.\n        \"\"\"\n        self.positions[:, 1:] = 0\n\n    def _check_limit_cycle(self, delta):\n\"\"\"Checks if there is a limit cycle in the data.\n\n        Args:\n            delta (float) : Difference between data values to be considerated equal.\n\n        Returns:\n            (bool): Whenever data reached a limit cylce.\n        \"\"\"\n        for i in self.positions[0,0:-2]:\n            if np.linalg.norm(i - self.position)&lt;delta:\n                return True\n        return False    \n</code></pre>"},{"location":"reference/phaseportrait/maps/map/#phaseportrait.maps.map.Map.__init__","title":"<code>__init__(portrait, dF, dimension, max_values, *, dF_args=None, initial_values=None, thermalization=0, **kargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>portrait</code> <code>Object) </code> <p>Class that uses the RungeKutta objects.</p> required <code>dF</code> <code>callable) </code> <p>A dF type funcion.</p> required <code>dimension</code> <code>int) </code> <p>Number of dimensions in which it calculates the next values. Must equal the amount of outputs the <code>dF</code> funcion gives.</p> required <code>max_values</code> <code>int) </code> <p>Max number of values saved.</p> required <code>dF_args</code> <code>dict) </code> <p>If necesary, must contain the kargs for the <code>dF</code> funcion. By default, None.</p> <code>None</code> <code>initial_values</code> <code>float, list, optional) </code> <p>Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate.</p> <code>None</code> <code>thermalization</code> <code>int, optional) </code> <p>Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0.</p> <code>0</code> Source code in <code>phaseportrait/maps/map.py</code> <pre><code>def __init__(self, portrait, dF, dimension, max_values, *, dF_args=None, initial_values=None, thermalization=0, **kargs):\n\"\"\"\n    Args:\n        portrait (Object) : Class that uses the RungeKutta objects.\n        dF (callable) : A dF type funcion.\n        dimension (int) : Number of dimensions in which it calculates the next values. Must equal the amount of outputs the `dF` funcion gives.\n        max_values (int) : Max number of values saved.\n        dF_args (dict) : If necesary, must contain the kargs for the `dF` funcion. By default, None.\n        initial_values (float, list, optional) : Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate.\n        thermalization (int, optional) : Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0.\n    \"\"\"\n    super().__init__(portrait, dF, dimension, max_values, dF_args=dF_args,\n                     initial_values=initial_values, thermalization=thermalization, **kargs)\n\n    self.positions = self._create_values_array()\n</code></pre>"},{"location":"reference/phaseportrait/maps/map/#phaseportrait.maps.map.Map.clear_values","title":"<code>clear_values()</code>","text":"<p>Clears the data arrays <code>self.positions</code>.</p> Source code in <code>phaseportrait/maps/map.py</code> <pre><code>def clear_values(self):\n\"\"\"\n    Clears the data arrays `self.positions`.\n    \"\"\"\n    self.positions[:, 1:] = 0\n</code></pre>"},{"location":"reference/phaseportrait/maps/map/#phaseportrait.maps.map.Map.instance_and_compute_all","title":"<code>instance_and_compute_all(portrait, dF, dimension, max_values, dF_args, initial_values, save_freq, thermalization, **kargs)</code>  <code>classmethod</code>","text":"<p>Creates an instance of phase-portrait.maps.Map.  Computes all the data requested and returns the instance.</p> <p>Parameters:</p> Name Type Description Default <code>portrait</code> <code>Object) </code> <p>Class that uses the RungeKutta objects.</p> required <code>dF</code> <code>callable) </code> <p>A dF type funcion.</p> required <code>dimension</code> <code>int) </code> <p>Number of dimensions in which it calculates the next values. Must equal the amount of outputs the <code>dF</code> funcion gives.</p> required <code>max_values</code> <code>int) </code> <p>Max number of values saved.</p> required <code>dF_args</code> <code>dict) </code> <p>If necesary, must contain the kargs for the <code>dF</code> funcion. By default, None.</p> required <code>initial_values</code> <code>float, list, optional) </code> <p>Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat</p> required <code>save_freq</code> <code>int, optional, by default 1) </code> <p>Number of values computed before saving them.</p> required <code>thermalization</code> <code>int, optional) </code> <p>Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0.</p> required <code>limit_cycle_check</code> <code>int, bool, optional, by default False) </code> <p>Whenever to check it there os a limit cycle in the data.</p> required <code>delta</code> <code>float, optional, by default 0.01) </code> <p>If <code>limit_cycle_check==True</code> is the distance between data elements to be considerated equal.</p> required <p>Returns:</p> Type Description <code>phaseportrait.maps.Map</code> <p>The instance with all the data requested</p> Source code in <code>phaseportrait/maps/map.py</code> <pre><code>@classmethod\ndef instance_and_compute_all(cls, portrait, dF, dimension, max_values, dF_args, initial_values, save_freq, thermalization, **kargs):\n\"\"\"Creates an instance of phase-portrait.maps.Map. \n    Computes all the data requested and returns the instance.\n\n    Args:\n        portrait (Object) : Class that uses the RungeKutta objects.\n        dF (callable) : A dF type funcion.\n        dimension (int) : Number of dimensions in which it calculates the next values. Must equal the amount of outputs the `dF` funcion gives.\n        max_values (int) : Max number of values saved.\n        dF_args (dict) : If necesary, must contain the kargs for the `dF` funcion. By default, None.\n        initial_values (float, list, optional) : Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat\n        save_freq (int, optional, by default 1) : Number of values computed before saving them.\n        thermalization (int, optional) : Thermalization steps before data is saved, by default None. If None, thermalization steps are set to 0.\n        limit_cycle_check (int, bool, optional, by default False) : Whenever to check it there os a limit cycle in the data.\n        delta (float, optional, by default 0.01) : If `limit_cycle_check==True` is the distance between data elements to be considerated equal.\n\n    Returns:\n        (phaseportrait.maps.Map): The instance with all the data requested\n    \"\"\"\n\n    instance = cls(portrait, dF, dimension, max_values, dF_args=dF_args,\n                   initial_values=initial_values, save_freq=save_freq, thermalization=thermalization, **kargs)\n\n    max_index = instance.compute_all(**kargs)\n    if max_index is not None:\n        instance.positions = instance.positions[:,0:max_index-1]\n    return instance\n</code></pre>"},{"location":"reference/phaseportrait/maps/map/#phaseportrait.maps.map.Map.save","title":"<code>save(i)</code>","text":"<p>Saves <code>self.position</code> in the attribute <code>self.positions</code>.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int) </code> <p>Index in which the data is saved.</p> required Source code in <code>phaseportrait/maps/map.py</code> <pre><code>def save(self, i):\n\"\"\"\n    Saves `self.position` in the attribute `self.positions`.\n\n    Args:\n        i (int) : Index in which the data is saved.\n    \"\"\"\n    try:\n        self.positions[:, i] = self.position\n    except IndexError:\n        np.concatenate(self.positions, self._create_values_array(), axis=1)\n        self.max_values *= 2\n        self.save(i)\n</code></pre>"},{"location":"reference/phaseportrait/nullclines/nullclines/","title":"Nullclines","text":""},{"location":"reference/phaseportrait/nullclines/nullclines/#phaseportrait.nullclines.nullclines.Nullcline2D","title":"<code>Nullcline2D</code>","text":""},{"location":"reference/phaseportrait/nullclines/nullclines/#phaseportrait.nullclines.nullclines.Nullcline2D--nullcline2d","title":"Nullcline2D","text":"<p>Class dedicated to 2 dimensions phase portraits.  Useful where it is necessary to plot nulclines in a plot.</p> <p>Integrated via method <code>add_nullclines</code> in: - PhasePortrait2D </p>"},{"location":"reference/phaseportrait/nullclines/nullclines/#phaseportrait.nullclines.nullclines.Nullcline2D--methods","title":"Methods","text":"<ul> <li>plot : Plots the nullclines.</li> </ul> Source code in <code>phaseportrait/nullclines/nullclines.py</code> <pre><code>class Nullcline2D():\n\"\"\"\n    Nullcline2D\n    --------\n    Class dedicated to 2 dimensions phase portraits. \n    Useful where it is necessary to plot nulclines in a plot.\n\n    Integrated via method `add_nullclines` in:\n    - PhasePortrait2D \n\n    Methods\n    -------\n    * plot : Plots the nullclines.\n    \"\"\"\n\n    def __init__(self, portrait, funcion, *, precision=0.01, xprecision=None, yprecision=None, show: Literal['x', 'y', None]=None, offset=0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='b', bgcolor='w', alpha=0, polar=False):\n\"\"\"Creates an instance of Nullcline2D\n\n        Args:\n            portrait (Object) : The class that uses Nullcline2D\n            funcion (callable) : A `dF` type funcion.\n            precision (float, optional) : The minimum diferencie from `offset` to be considerated a nullcline, by default 0.01\n            xprecision (float, optional) : For a different precision value only in the x axis, by default `precision`\n            yprecision (float, optional) : For a different precision value only in the y axis, by default `precision`\n            show (Literal['x', 'y', None], optinal) : Used to show only x or y nullclines, both if None, by default None\n            offset (float, optional) : If you want, for instance, a twoclide, by default 0\n            density (int, optional) : Number of inner divisions on the x axis and y axis, by default 50\n            xRange (Union[float,list], optional) : The range in which the nullclines are calculated, by default `portrait.Range[0]`\n            yRange (Union[float,list], optional) : The range in which the nullclines are calculated, by default `portrait.Range[1]`\n            dF_args (dict, optional) : If necesary, must contain the kargs for the `dF` funcion, by default None\n            xcolor (str, optional) : X nullcline color, by default 'r'\n            ycolor (str, optional) : Y nullcline color], by default 'b'\n            bgcolor (str, optional) : Background color, by default 'w'\n            alpha (int, optional) : Opacity of the background, by default 0\n            polar (bool, optional) : If the dF funcion requires polar coordinates, by default False\n        \"\"\"                         \n        self.portrait = portrait\n        self.funcion = funcion\n        self.precision = precision\n        self.xprecision = xprecision if xprecision is not None else precision\n        self.yprecision = yprecision if yprecision is not None else precision\n        self.show = show\n        self.offset = offset\n        self.xcolor = to_hex(xcolor)\n        self.ycolor = to_hex(ycolor)\n        self.bgcolor = bgcolor\n        self.density = density\n        self.xRange = xRange if xRange is not None else self.portrait.Range[0,:]\n        self.yRange = yRange if yRange is not None else self.portrait.Range[0,:]\n        self.alpha = alpha\n        self.polar = polar\n\n        try:\n            self.dF_args = dF_args if dF_args is not None else self.portrait.dF_args\n        except:\n            self.dF_args = {}\n\n    def update_dF_args(self):\n        self.dF_args = self.portrait.dF_args.copy()\n\n    def plot(self, *, axis=None):\n\"\"\"Plots the nullclines in the given axis\n\n        Args:\n            axis (matplotlib.Axis, optional) : The axis in which the nullclines will be represented, by default `portrait.ax`\n\n        Returns:\n            (matplotlib.contour.QuadContourSet, matplotlib.contour.QuadContourSet): X and Y contours.\n        \"\"\"\n\n\n        self.update_dF_args()\n\n        if axis is None:\n            axis = self.portrait.ax\n\n        _x = np.linspace(*self.xRange, self.density)\n        _y = np.linspace(*self.yRange, self.density)\n\n        _xdF = np.zeros([self.density, self.density])\n        _ydF = np.zeros([self.density, self.density])\n\n\n        if self.polar:\n            for i,xx in enumerate(_x):\n                for j,yy in enumerate(_y):\n                    _r, _t = (xx**2 + yy**2)**0.5, np.arctan2(yy, xx)\n                    _dr, _dt = self.funcion(_r,_t, **self.dF_args)\n                    _xdF[j,i], _ydF[j,i] = _dr*np.cos(_t) - _r*np.sin(_t)*_dt, _dr*np.sin(_t) + _r*np.cos(_t)*_dt       \n        else:\n            for i,xx in enumerate(_x):\n                for j,yy in enumerate(_y):\n                    _xdF[j,i], _ydF[j,i] = self.funcion(xx,yy, **self.dF_args)\n\n\n        xct, yct = None, None\n\n        if self.show is None or self.show == 'x':\n            xct = axis.contourf(_x, _y,_xdF, levels=[-self.xprecision + self.offset, self.xprecision + self.offset], colors=[self.xcolor], extend='neither')\n            xct.cmap.set_over(self.bgcolor, alpha=self.alpha)\n            xct.cmap.set_under(self.bgcolor, alpha=self.alpha)\n\n        if self.show is None or self.show == 'y':   \n            yct = axis.contourf(_x, _y,_ydF, levels=[-self.yprecision + self.offset, self.yprecision + self.offset], colors=[self.ycolor], extend='neither')\n            yct.cmap.set_over(self.bgcolor, alpha=self.alpha)\n            yct.cmap.set_under(self.bgcolor, alpha=self.alpha)\n\n        return xct, yct\n</code></pre>"},{"location":"reference/phaseportrait/nullclines/nullclines/#phaseportrait.nullclines.nullclines.Nullcline2D.__init__","title":"<code>__init__(portrait, funcion, *, precision=0.01, xprecision=None, yprecision=None, show=None, offset=0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='b', bgcolor='w', alpha=0, polar=False)</code>","text":"<p>Creates an instance of Nullcline2D</p> <p>Parameters:</p> Name Type Description Default <code>portrait</code> <code>Object) </code> <p>The class that uses Nullcline2D</p> required <code>funcion</code> <code>callable) </code> <p>A <code>dF</code> type funcion.</p> required <code>precision</code> <code>float, optional) </code> <p>The minimum diferencie from <code>offset</code> to be considerated a nullcline, by default 0.01</p> <code>0.01</code> <code>xprecision</code> <code>float, optional) </code> <p>For a different precision value only in the x axis, by default <code>precision</code></p> <code>None</code> <code>yprecision</code> <code>float, optional) </code> <p>For a different precision value only in the y axis, by default <code>precision</code></p> <code>None</code> <code>show</code> <code>Literal['x', 'y', None], optinal) </code> <p>Used to show only x or y nullclines, both if None, by default None</p> <code>None</code> <code>offset</code> <code>float, optional) </code> <p>If you want, for instance, a twoclide, by default 0</p> <code>0</code> <code>density</code> <code>int, optional) </code> <p>Number of inner divisions on the x axis and y axis, by default 50</p> <code>50</code> <code>xRange</code> <code>Union[float,list], optional) </code> <p>The range in which the nullclines are calculated, by default <code>portrait.Range[0]</code></p> <code>None</code> <code>yRange</code> <code>Union[float,list], optional) </code> <p>The range in which the nullclines are calculated, by default <code>portrait.Range[1]</code></p> <code>None</code> <code>dF_args</code> <code>dict, optional) </code> <p>If necesary, must contain the kargs for the <code>dF</code> funcion, by default None</p> <code>None</code> <code>xcolor</code> <code>str, optional) </code> <p>X nullcline color, by default 'r'</p> <code>'r'</code> <code>ycolor</code> <code>str, optional) </code> <p>Y nullcline color], by default 'b'</p> <code>'b'</code> <code>bgcolor</code> <code>str, optional) </code> <p>Background color, by default 'w'</p> <code>'w'</code> <code>alpha</code> <code>int, optional) </code> <p>Opacity of the background, by default 0</p> <code>0</code> <code>polar</code> <code>bool, optional) </code> <p>If the dF funcion requires polar coordinates, by default False</p> <code>False</code> Source code in <code>phaseportrait/nullclines/nullclines.py</code> <pre><code>def __init__(self, portrait, funcion, *, precision=0.01, xprecision=None, yprecision=None, show: Literal['x', 'y', None]=None, offset=0, density=50, xRange=None, yRange=None, dF_args=None, xcolor='r', ycolor='b', bgcolor='w', alpha=0, polar=False):\n\"\"\"Creates an instance of Nullcline2D\n\n    Args:\n        portrait (Object) : The class that uses Nullcline2D\n        funcion (callable) : A `dF` type funcion.\n        precision (float, optional) : The minimum diferencie from `offset` to be considerated a nullcline, by default 0.01\n        xprecision (float, optional) : For a different precision value only in the x axis, by default `precision`\n        yprecision (float, optional) : For a different precision value only in the y axis, by default `precision`\n        show (Literal['x', 'y', None], optinal) : Used to show only x or y nullclines, both if None, by default None\n        offset (float, optional) : If you want, for instance, a twoclide, by default 0\n        density (int, optional) : Number of inner divisions on the x axis and y axis, by default 50\n        xRange (Union[float,list], optional) : The range in which the nullclines are calculated, by default `portrait.Range[0]`\n        yRange (Union[float,list], optional) : The range in which the nullclines are calculated, by default `portrait.Range[1]`\n        dF_args (dict, optional) : If necesary, must contain the kargs for the `dF` funcion, by default None\n        xcolor (str, optional) : X nullcline color, by default 'r'\n        ycolor (str, optional) : Y nullcline color], by default 'b'\n        bgcolor (str, optional) : Background color, by default 'w'\n        alpha (int, optional) : Opacity of the background, by default 0\n        polar (bool, optional) : If the dF funcion requires polar coordinates, by default False\n    \"\"\"                         \n    self.portrait = portrait\n    self.funcion = funcion\n    self.precision = precision\n    self.xprecision = xprecision if xprecision is not None else precision\n    self.yprecision = yprecision if yprecision is not None else precision\n    self.show = show\n    self.offset = offset\n    self.xcolor = to_hex(xcolor)\n    self.ycolor = to_hex(ycolor)\n    self.bgcolor = bgcolor\n    self.density = density\n    self.xRange = xRange if xRange is not None else self.portrait.Range[0,:]\n    self.yRange = yRange if yRange is not None else self.portrait.Range[0,:]\n    self.alpha = alpha\n    self.polar = polar\n\n    try:\n        self.dF_args = dF_args if dF_args is not None else self.portrait.dF_args\n    except:\n        self.dF_args = {}\n</code></pre>"},{"location":"reference/phaseportrait/nullclines/nullclines/#phaseportrait.nullclines.nullclines.Nullcline2D.plot","title":"<code>plot(*, axis=None)</code>","text":"<p>Plots the nullclines in the given axis</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>matplotlib.Axis, optional) </code> <p>The axis in which the nullclines will be represented, by default <code>portrait.ax</code></p> <code>None</code> <p>Returns:</p> Type Description <code>matplotlib.contour.QuadContourSet, matplotlib.contour.QuadContourSet</code> <p>X and Y contours.</p> Source code in <code>phaseportrait/nullclines/nullclines.py</code> <pre><code>def plot(self, *, axis=None):\n\"\"\"Plots the nullclines in the given axis\n\n    Args:\n        axis (matplotlib.Axis, optional) : The axis in which the nullclines will be represented, by default `portrait.ax`\n\n    Returns:\n        (matplotlib.contour.QuadContourSet, matplotlib.contour.QuadContourSet): X and Y contours.\n    \"\"\"\n\n\n    self.update_dF_args()\n\n    if axis is None:\n        axis = self.portrait.ax\n\n    _x = np.linspace(*self.xRange, self.density)\n    _y = np.linspace(*self.yRange, self.density)\n\n    _xdF = np.zeros([self.density, self.density])\n    _ydF = np.zeros([self.density, self.density])\n\n\n    if self.polar:\n        for i,xx in enumerate(_x):\n            for j,yy in enumerate(_y):\n                _r, _t = (xx**2 + yy**2)**0.5, np.arctan2(yy, xx)\n                _dr, _dt = self.funcion(_r,_t, **self.dF_args)\n                _xdF[j,i], _ydF[j,i] = _dr*np.cos(_t) - _r*np.sin(_t)*_dt, _dr*np.sin(_t) + _r*np.cos(_t)*_dt       \n    else:\n        for i,xx in enumerate(_x):\n            for j,yy in enumerate(_y):\n                _xdF[j,i], _ydF[j,i] = self.funcion(xx,yy, **self.dF_args)\n\n\n    xct, yct = None, None\n\n    if self.show is None or self.show == 'x':\n        xct = axis.contourf(_x, _y,_xdF, levels=[-self.xprecision + self.offset, self.xprecision + self.offset], colors=[self.xcolor], extend='neither')\n        xct.cmap.set_over(self.bgcolor, alpha=self.alpha)\n        xct.cmap.set_under(self.bgcolor, alpha=self.alpha)\n\n    if self.show is None or self.show == 'y':   \n        yct = axis.contourf(_x, _y,_ydF, levels=[-self.yprecision + self.offset, self.yprecision + self.offset], colors=[self.ycolor], extend='neither')\n        yct.cmap.set_over(self.bgcolor, alpha=self.alpha)\n        yct.cmap.set_under(self.bgcolor, alpha=self.alpha)\n\n    return xct, yct\n</code></pre>"},{"location":"reference/phaseportrait/sliders/sliders/","title":"Sliders","text":""},{"location":"reference/phaseportrait/sliders/sliders/#phaseportrait.sliders.sliders.Slider","title":"<code>Slider</code>","text":""},{"location":"reference/phaseportrait/sliders/sliders/#phaseportrait.sliders.sliders.Slider--slider","title":"Slider","text":"<p>Internal class. Manages sliders.</p> <p>Integrated via method <code>add_slider</code> in: - Map1D - Cobweb - PhasePortrait2D - PhasePotrait3D - Trajectory2D - Trajectory3D</p>"},{"location":"reference/phaseportrait/sliders/sliders/#phaseportrait.sliders.sliders.Slider--methods","title":"Methods","text":"<ul> <li>call :  Updates internal dF_args and replots the graphs.</li> </ul> Source code in <code>phaseportrait/sliders/sliders.py</code> <pre><code>class Slider():\n\"\"\"\n    Slider\n    ------\n    Internal class. Manages sliders.\n\n    Integrated via method `add_slider` in:\n    - Map1D\n    - Cobweb\n    - PhasePortrait2D\n    - PhasePotrait3D\n    - Trajectory2D\n    - Trajectory3D\n\n    Methods\n    -------\n    * __call__ :  Updates internal dF_args and replots the graphs.\n    \"\"\"\n    def __init__(self, portrait, param_name, valinit=None, valstep=0.1, valinterval=[]):\n\"\"\"\n        Slider\n        ------\n        Internal class. Manages sliders.\n\n        Parameters\n        ----------\n        portrait : \n            Class that uses the Slider.\n        param_name : str\n            Name of the parameter to slide over.\n        valinit : float\n            Initial value of the parameter in the slider.\n        valsetp : float, default=0.1\n            Precision of the slider.\n        valinterval : Union[float, list]\n            Parameter range in the slider.\n        \"\"\"\n\n        self.portrait = portrait\n        self.param_name = param_name\n        self.value = valinit\n\n        valinterval = utils.construct_interval_1d(valinterval)\n        valinterval = np.array(valinterval)\n\n        if 'Trajectory' in self.portrait._name_ or 'Cobweb' in self.portrait._name_: \n            self.ax = self.portrait.sliders_fig.add_axes([0.25, 0.88 - 0.05*len(self.portrait.sliders), 0.4, 0.05])\n\n        if 'PhasePortrait' in self.portrait._name_ or 'Map1D' in self.portrait._name_:\n            self.ax = self.portrait.fig.add_axes([0.25, 0.015 + 0.05*len(self.portrait.sliders), 0.4, 0.03])\n\n        aux = {'valinit':valinit} if isinstance(self.value, (int, float)) else {}\n        self.slider = matplot_slider(self.ax, self.param_name, *valinterval, valstep=valstep, **aux)\n\n    def __call__(self, value):\n\"\"\"\n        Updates internal dF_args and replots the graphs.\n\n        Arguments\n        ---------\n        value : float\n            New value for the parameter of the slider\n        \"\"\"\n\n        try:\n            self.portrait.ax.cla()\n        except:\n            for ax in self.portrait.ax.values():\n                ax.cla()\n        self.value = value\n\n        if 'Cobweb' in self.portrait._name_:\n            self.portrait.update_dF_args()\n\n        self.portrait.plot()\n\n    def update_slider_ends(self, valmin, valmax):\n\"\"\"\n        Updates slider min and max values\n\n        Parameters\n        ----------\n        valmin : float\n            Min slider value\n        valmax : float\n            Max slider value\n        \"\"\"\n        self.slider.valmin = valmin\n        self.slider.valmax = valmax\n</code></pre>"},{"location":"reference/phaseportrait/sliders/sliders/#phaseportrait.sliders.sliders.Slider.__call__","title":"<code>__call__(value)</code>","text":"<p>Updates internal dF_args and replots the graphs.</p>"},{"location":"reference/phaseportrait/sliders/sliders/#phaseportrait.sliders.sliders.Slider.__call__--arguments","title":"Arguments","text":"float <p>New value for the parameter of the slider</p> Source code in <code>phaseportrait/sliders/sliders.py</code> <pre><code>def __call__(self, value):\n\"\"\"\n    Updates internal dF_args and replots the graphs.\n\n    Arguments\n    ---------\n    value : float\n        New value for the parameter of the slider\n    \"\"\"\n\n    try:\n        self.portrait.ax.cla()\n    except:\n        for ax in self.portrait.ax.values():\n            ax.cla()\n    self.value = value\n\n    if 'Cobweb' in self.portrait._name_:\n        self.portrait.update_dF_args()\n\n    self.portrait.plot()\n</code></pre>"},{"location":"reference/phaseportrait/sliders/sliders/#phaseportrait.sliders.sliders.Slider.__init__","title":"<code>__init__(portrait, param_name, valinit=None, valstep=0.1, valinterval=[])</code>","text":""},{"location":"reference/phaseportrait/sliders/sliders/#phaseportrait.sliders.sliders.Slider.__init__--slider","title":"Slider","text":"<p>Internal class. Manages sliders.</p>"},{"location":"reference/phaseportrait/sliders/sliders/#phaseportrait.sliders.sliders.Slider.__init__--parameters","title":"Parameters","text":"portrait <p>Class that uses the Slider.</p> str <p>Name of the parameter to slide over.</p> float <p>Initial value of the parameter in the slider.</p> float, default=0.1 <p>Precision of the slider.</p> Union[float, list] <p>Parameter range in the slider.</p> Source code in <code>phaseportrait/sliders/sliders.py</code> <pre><code>def __init__(self, portrait, param_name, valinit=None, valstep=0.1, valinterval=[]):\n\"\"\"\n    Slider\n    ------\n    Internal class. Manages sliders.\n\n    Parameters\n    ----------\n    portrait : \n        Class that uses the Slider.\n    param_name : str\n        Name of the parameter to slide over.\n    valinit : float\n        Initial value of the parameter in the slider.\n    valsetp : float, default=0.1\n        Precision of the slider.\n    valinterval : Union[float, list]\n        Parameter range in the slider.\n    \"\"\"\n\n    self.portrait = portrait\n    self.param_name = param_name\n    self.value = valinit\n\n    valinterval = utils.construct_interval_1d(valinterval)\n    valinterval = np.array(valinterval)\n\n    if 'Trajectory' in self.portrait._name_ or 'Cobweb' in self.portrait._name_: \n        self.ax = self.portrait.sliders_fig.add_axes([0.25, 0.88 - 0.05*len(self.portrait.sliders), 0.4, 0.05])\n\n    if 'PhasePortrait' in self.portrait._name_ or 'Map1D' in self.portrait._name_:\n        self.ax = self.portrait.fig.add_axes([0.25, 0.015 + 0.05*len(self.portrait.sliders), 0.4, 0.03])\n\n    aux = {'valinit':valinit} if isinstance(self.value, (int, float)) else {}\n    self.slider = matplot_slider(self.ax, self.param_name, *valinterval, valstep=valstep, **aux)\n</code></pre>"},{"location":"reference/phaseportrait/sliders/sliders/#phaseportrait.sliders.sliders.Slider.update_slider_ends","title":"<code>update_slider_ends(valmin, valmax)</code>","text":"<p>Updates slider min and max values</p>"},{"location":"reference/phaseportrait/sliders/sliders/#phaseportrait.sliders.sliders.Slider.update_slider_ends--parameters","title":"Parameters","text":"float <p>Min slider value</p> float <p>Max slider value</p> Source code in <code>phaseportrait/sliders/sliders.py</code> <pre><code>def update_slider_ends(self, valmin, valmax):\n\"\"\"\n    Updates slider min and max values\n\n    Parameters\n    ----------\n    valmin : float\n        Min slider value\n    valmax : float\n        Max slider value\n    \"\"\"\n    self.slider.valmin = valmin\n    self.slider.valmax = valmax\n</code></pre>"},{"location":"reference/phaseportrait/streamlines/size_gradient/","title":"Size gradient","text":""},{"location":"reference/phaseportrait/streamlines/size_gradient/#phaseportrait.streamlines.size_gradient.Streamlines_Size_Gradient","title":"<code>Streamlines_Size_Gradient</code>","text":"<p>         Bases: <code>Streamlines_base</code></p>"},{"location":"reference/phaseportrait/streamlines/size_gradient/#phaseportrait.streamlines.size_gradient.Streamlines_Size_Gradient--streamlines","title":"Streamlines","text":"<p>Creates trajectories given a <code>dF</code> function. Using Euler integrator.</p> <p>Integrated in: - PhasePortrait2D</p> Source code in <code>phaseportrait/streamlines/size_gradient.py</code> <pre><code>class Streamlines_Size_Gradient(Streamlines_base):\n\"\"\"\n    Streamlines\n    --------\n    Creates trajectories given a `dF` function. Using Euler integrator.\n\n    Integrated in:\n    - PhasePortrait2D\n    \"\"\"\n\n\n\n    def __init__(\n        self, dF, X, Y, *Z, maxLen=500, dF_args=None, **kargs\n    ):\n\"\"\"\n        Compute a set of streamlines given velocity function `dF`.\n\n        Args:\n            X (list, list[list]) : arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n            Y (list, list[list]) : arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n            maxLen (int default=500) : The maximum length of an individual streamline segment.\n            dF_args (dict|None default=None) : dF_args of `dF` function.\n        \"\"\"\n\n        if not Z:\n            self.proyection=\"2d\"\n            self.stream_base = Streamlines_base(dF, X, Y, maxLen, dF_args=dF_args, **kargs)\n        else:\n            self.proyection=\"3d\"\n            self.stream_base = Streamlines_base3D(dF, X, Y, Z[0], maxLen, dF_args=dF_args, **kargs)\n\n\n    def plot(self, ax, cmap, cnorm, arrow_width):\n        for streamline in self.stream_base.streamlines:\n            *x, v = streamline\n            points = np.array(x).T.reshape(-1 , 1, len(x))\n            segments = np.concatenate([points[:-1], points[1:]], axis=1)\n\n            n = len(segments)\n\n            D = np.sqrt(((points[1:] - points[:-1]) ** 2).sum(axis=-1))\n            L = D.cumsum().reshape(n, 1) + np.random.uniform(0, 1)\n            C = np.zeros((n, 3))\n            C[:] = (L * 1.5) % 1\n\n            C = cmap(((L * 1.5) % 1).ravel())\n\n            linewidths = np.zeros(n)\n            linewidths[:] = arrow_width - arrow_width*((L.reshape(n) * 1.5) % 1)\n            # line = LineCollection(segments, color=C, linewidth=linewidths)\n\n            if self.proyection == \"2d\":\n                line = LineCollection(segments, color=C, linewidths=linewidths)\n            if self.proyection == \"3d\":\n                line = Line3DCollection(segments, color=C, linewidths=linewidths)\n\n            # line = LineCollection(segments, color=C)\n            ax.add_collection(line)\n</code></pre>"},{"location":"reference/phaseportrait/streamlines/size_gradient/#phaseportrait.streamlines.size_gradient.Streamlines_Size_Gradient.__init__","title":"<code>__init__(dF, X, Y, *Z, maxLen=500, dF_args=None, **kargs)</code>","text":"<p>Compute a set of streamlines given velocity function <code>dF</code>.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>list, list[list]) </code> <p>arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.</p> required <code>Y</code> <code>list, list[list]) </code> <p>arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.</p> required <code>maxLen</code> <code>int default=500) </code> <p>The maximum length of an individual streamline segment.</p> <code>500</code> <code>dF_args</code> <code>dict|None default=None) </code> <p>dF_args of <code>dF</code> function.</p> <code>None</code> Source code in <code>phaseportrait/streamlines/size_gradient.py</code> <pre><code>def __init__(\n    self, dF, X, Y, *Z, maxLen=500, dF_args=None, **kargs\n):\n\"\"\"\n    Compute a set of streamlines given velocity function `dF`.\n\n    Args:\n        X (list, list[list]) : arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n        Y (list, list[list]) : arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n        maxLen (int default=500) : The maximum length of an individual streamline segment.\n        dF_args (dict|None default=None) : dF_args of `dF` function.\n    \"\"\"\n\n    if not Z:\n        self.proyection=\"2d\"\n        self.stream_base = Streamlines_base(dF, X, Y, maxLen, dF_args=dF_args, **kargs)\n    else:\n        self.proyection=\"3d\"\n        self.stream_base = Streamlines_base3D(dF, X, Y, Z[0], maxLen, dF_args=dF_args, **kargs)\n</code></pre>"},{"location":"reference/phaseportrait/streamlines/streamlines_base/","title":"Streamlines base","text":""},{"location":"reference/phaseportrait/streamlines/streamlines_base/#phaseportrait.streamlines.streamlines_base.Streamlines_base","title":"<code>Streamlines_base</code>","text":""},{"location":"reference/phaseportrait/streamlines/streamlines_base/#phaseportrait.streamlines.streamlines_base.Streamlines_base--streamlines","title":"Streamlines","text":"<p>Creates trajectories given a <code>dF</code> function. Using Scipy.integrate.odeint integrator.</p> <p>Integrated in: - PhasePortrait2D - PhasePorrtait3D</p> Source code in <code>phaseportrait/streamlines/streamlines_base.py</code> <pre><code>class Streamlines_base:\n\"\"\"\n    Streamlines\n    --------\n    Creates trajectories given a `dF` function. Using Scipy.integrate.odeint integrator.\n\n    Integrated in:\n    - PhasePortrait2D\n    - PhasePorrtait3D\n    \"\"\"\n\n    def __init__(self, odeint_method=\"scipy\") -&gt; None:\n        if odeint_method == \"scipy\":\n            self._integration_method = self._scipy_odeint\n        elif odeint_method == \"euler\":\n            self._integration_method = self._euler_odeint\n        elif odeint_method == \"rungekutta3\":\n            self._integration_method = self._runge_kutta_3rd_odeint\n        else:\n            raise NameError(f\"Integration method {odeint_method} is not in [scipy, euler or rungekutta3]\")\n\n    def _makeStreamline(self, y0):\n\"\"\"\n        Compute a streamline extending in both directions from the given point. Using Euler integrator.\n        \"\"\"\n        *s, svelocity = self._makeHalfStreamline(y0, 1)  # forwards\n        *r, rvelocity = self._makeHalfStreamline(y0, -1)  # backwards\n\n        for _r in r:\n            _r.reverse()\n        rvelocity.reverse()\n\n        speed = self._speed(y0)\n        if np.isnan(speed).any() or np.isinf(speed).any():\n            return None\n\n        return *[r[i] + [y0[i]] + s[i] for i in range(len(y0))],  rvelocity + [np.sqrt(np.sum(np.square(speed)))] + svelocity\n\n    def _speed_2d_no_polar(self, y0, *args, **kargs):\n        return np.array(self.dF(*y0, **self.dF_args))\n\n    def _speed_2d_polar(self, y0, *args, **kargs):\n        R, Theta = np.sqrt(np.sum(np.square(y0))), np.arctan2(y0[1], y0[0])\n        dR, dTheta = self.dF(R, Theta, **self.dF_args)\n        return np.array([dR*np.cos(Theta) - R*np.sin(Theta)*dTheta, dR*np.sin(Theta)+R*np.cos(Theta)*dTheta])\n\n    def _speed_3d_no_polar(self, y0, *args, **kargs):\n        return np.array(self.dF(*y0, **self.dF_args))\n\n    def _speed_3d_polar(self, y0, *args, **kargs):\n        R, Theta = np.sqrt(np.sum(np.square(y0))), np.arctan2(y0[1], y0[0])\n        Phi  = np.arccos(y0[2]/R) \n        dR, dTheta, dPhi = self.dF(R, Theta, Phi, **self.dF_args)\n        return np.array([\\\n            dR*np.cos(Theta)*np.sin(Phi) - R*np.sin(Theta)*np.sin(Phi)*dTheta + R*np.cos(Theta)*np.cos(Phi) * dPhi, \\\n            dR*np.sin(Theta)*np.sin(Phi) + R*np.cos(Theta)*np.sin(Phi)*dTheta + R*np.sin(Theta)*np.cos(Phi) * dPhi, \\\n            dR*np.cos(Phi) - R*np.sin(Phi)*dPhi\n        ])\n\n    def _speed(self, y0, *args, **kwargs):\n\"\"\"\n        Computes speed in given coordinates\n        \"\"\"\n        ...\n\n\n    def _scipy_odeint(self, coords, sign, deltat):\n        return integrate.odeint(self._speed, coords, [0.1*i*sign*deltat for i in range(4)])[-1]\n\n    def _euler_odeint(self, coords, sign, deltat):\n        return coords + self._speed(coords) * deltat * sign\n\n    def _runge_kutta_3rd_odeint(self, coords, sign, deltat):\n        k1 = self._speed(coords)\n        k2 = self._speed(coords + sign*deltat*1/4*k1)\n        k3 = self._speed(coords + sign*deltat*(-1*k1 + 2*k2))\n        return coords + sign * deltat * ((k1+k3)/6 + 2/3*k2)\n\n    def _integration_method(self, coords, sign, deltat):\n\"\"\"Function responsible to integrate the function the given delta time\n        \"\"\"\n        ...\n\n    def _makeHalfStreamline(self, y0, sign):\n\"\"\"\n        Compute a streamline extending in one direction from the given point. Using Euler integrator.\n        \"\"\"\n        # Coordinates to Numpy\n        coords = y0.copy()\n        # coords_mask_position = np.asarray(np.rint((coords-self.range_min)/self.delta_coords), int)\n        coords_mask_position = self.get_masked_coordinates(*coords)\n\n        # Set prev_coords_mask_position to actual position so backwards trajectory can, at least, start\n        prev_coords_mask_position = coords_mask_position.copy()\n\n        # Save arrays\n        s = [[] for i in range(self.dimension)]\n        svelocity = []\n\n        i = 0\n        persistency = 0\n\n        while (self.range_min &lt; coords).all() and (coords &lt; self.range_max).all():\n            if i &gt; self.maxLen / 2:\n                break\n            i += 1\n\n            coords_mask_position = self.get_masked_coordinates(*coords)\n\n            # If mask is False there is not trajectory there yet.\n            if not self.used[tuple(coords_mask_position,)]:\n                prev_coords_mask_position = coords_mask_position.copy()\n\n                self.used[tuple(prev_coords_mask_position)] = True\n\n            # Integration\n            _speed = self._speed(coords)\n            if (_speed == 0).all() or \\\n                np.isnan(_speed).any() or \\\n                np.isinf(_speed).any():\n                    break\n\n            # deltat = np.sum(np.square(self.get_delta_coordinates(*coords))) / (4 * _speed)\n            deltat = np.min(self.get_delta_coordinates(*coords)/(10*np.abs(_speed)))\n\n            if np.isnan(deltat) or np.isinf(deltat):\n                print(deltat, self.get_delta_coordinates(*coords), _speed)\n\n            new_coords = self._integration_method(coords, sign, deltat)\n\n            mean_speed = np.sqrt(np.sum(np.square(new_coords-coords)))/deltat\n            coords = new_coords\n\n            # Save values\n            for c, coord in enumerate(coords):\n                s[c].append(coord)\n            svelocity.append(mean_speed)\n\n\n            # If persistency iterations in a region with previous trajectory break.\n            if self.used[tuple(coords_mask_position)] and (prev_coords_mask_position!=coords_mask_position).any():\n                persistency -= 1\n                if persistency &lt;= 0:\n                    break\n\n        return *s, svelocity\n</code></pre>"},{"location":"reference/phaseportrait/streamlines/streamlines_base/#phaseportrait.streamlines.streamlines_base.Streamlines_base2D","title":"<code>Streamlines_base2D</code>","text":"<p>         Bases: <code>Streamlines_base</code></p>"},{"location":"reference/phaseportrait/streamlines/streamlines_base/#phaseportrait.streamlines.streamlines_base.Streamlines_base2D--streamlines2d","title":"Streamlines2D","text":"<p>Creates trajectories given a <code>dF</code> function. Using Euler integrator.</p> Integrated in <p>-PhasePortrait2D</p> Source code in <code>phaseportrait/streamlines/streamlines_base.py</code> <pre><code>class Streamlines_base2D(Streamlines_base):\n\"\"\"\n    Streamlines2D\n    --------\n    Creates trajectories given a `dF` function. Using Euler integrator.\n\n    Integrated in:\n        -PhasePortrait2D\n    \"\"\"\n\n\n    def __init__(\n        self, dF, X, Y, maxLen=500, deltat=0.01, *, dF_args=None, polar=False, density=1, odeint_method=\"scipy\"\n    ):\n\"\"\"\n        Compute a set of streamlines given velocity function `dF`.\n\n        Args:\n            dF (callable) : A dF type funcion. Computes the derivatives of given coordinates.\n            X (list, list[list]) : Arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n            Y (list, list[list]) : Arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n            maxLen (int, default=500) : The maximum length of an individual streamline segment.\n            polar (bool, default=false) : Whether to use polar coordinates or not.\n            density (int, default=1) : Density of mask grid. Used for making the stream lines not collide.\n            odeint_method (str, default=\"scipy\") : Selects integration method, by default uses scipy.odeint. `euler` and `rungekutta3` are also available.\n            dF_args (dict|None, default=None) : dF_args of `dF` function.\n        \"\"\"\n        super().__init__(odeint_method=odeint_method)\n\n        self.dimension = 2\n        self.dF = dF\n        self.dF_args = dF_args if dF_args is not None else  {}\n\n        self.maxLen = maxLen\n        self.deltat = deltat\n\n        self.density = int(abs(density))\n\n        xa = np.asanyarray(X)\n        ya = np.asanyarray(Y)\n        if np.isnan(xa).any() or np.isnan(ya).any():\n            raise Exception(\"Invalid range. Chech limits and scales.\")\n        self.x = xa if xa.ndim == 1 else xa[0]\n        self.y = ya if ya.ndim == 1 else ya[:, 0]\n\n        self.polar = polar\n        self._speed = self._speed_2d_no_polar if not polar else self._speed_2d_polar\n\n        # marker for which regions have contours. +1 outside the plot at the far side of every axis. \n        self.used = np.zeros((1 + X.shape[0]*self.density, 1 + X.shape[1]*self.density), dtype=bool)\n        self.used[0] = True\n        self.used[-1] = True\n        self.used[:, 0] = True\n        self.used[:, -1] = True\n\n        self.range_min = np.array((self.x[0], self.y[0]))\n        self.range_max = np.array((self.x[-1], self.y[-1]))\n\n        self.streamlines = []\n\n        while not self.used.all():\n            nz = np.transpose(np.logical_not(self.used).nonzero())\n            # Make a streamline starting at the first unrepresented grid point\n            # choose = np.random.randint(nz.shape[0])\n            choose = 0\n\n            x_ind = nz[choose][0]\n            x = self.x[x_ind-1] + 0.5 * (self.x[x_ind]-self.x[x_ind-1])\n            y_ind = nz[choose][1]\n            y = self.y[y_ind-1] + 0.5 * (self.y[y_ind]-self.y[y_ind-1])\n\n\n            # x = nz[choose][0]*self.dx + self.x[0]\n            # y = nz[choose][1]*self.dy + self.y[0]\n            self.streamlines.append(\n                self._makeStreamline(np.array([x, y]))\n            )\n\n    def get_masked_coordinates(self, x, y):\n\"\"\"\n        Returns index of position in masked coordinates\n        \"\"\"\n        x_ind = np.searchsorted(self.x, x)\n        y_ind = np.searchsorted(self.y, y)\n        return np.array([x_ind, y_ind])\n\n    def get_delta_coordinates(self, x, y):\n\"\"\"\n        Returns closest delta coordinates of grid\n        \"\"\"\n        x_mask, y_mask = self.get_masked_coordinates(x, y)\n        return np.array([\n            self.x[x_mask] - self.x[x_mask-1], \n            self.y[y_mask] - self.y[y_mask-1]])\n\n    @property\n    def Range(self):\n        return ((self.x[0], self.x[-1]), (self.y[0], self.y[-1])) \n</code></pre>"},{"location":"reference/phaseportrait/streamlines/streamlines_base/#phaseportrait.streamlines.streamlines_base.Streamlines_base2D.__init__","title":"<code>__init__(dF, X, Y, maxLen=500, deltat=0.01, *, dF_args=None, polar=False, density=1, odeint_method='scipy')</code>","text":"<p>Compute a set of streamlines given velocity function <code>dF</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dF</code> <code>callable) </code> <p>A dF type funcion. Computes the derivatives of given coordinates.</p> required <code>X</code> <code>list, list[list]) </code> <p>Arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.</p> required <code>Y</code> <code>list, list[list]) </code> <p>Arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.</p> required <code>maxLen</code> <code>int, default=500) </code> <p>The maximum length of an individual streamline segment.</p> <code>500</code> <code>polar</code> <code>bool, default=false) </code> <p>Whether to use polar coordinates or not.</p> <code>False</code> <code>density</code> <code>int, default=1) </code> <p>Density of mask grid. Used for making the stream lines not collide.</p> <code>1</code> <code>odeint_method</code> <code>str, default=\"scipy\") </code> <p>Selects integration method, by default uses scipy.odeint. <code>euler</code> and <code>rungekutta3</code> are also available.</p> <code>'scipy'</code> <code>dF_args</code> <code>dict|None, default=None) </code> <p>dF_args of <code>dF</code> function.</p> <code>None</code> Source code in <code>phaseportrait/streamlines/streamlines_base.py</code> <pre><code>def __init__(\n    self, dF, X, Y, maxLen=500, deltat=0.01, *, dF_args=None, polar=False, density=1, odeint_method=\"scipy\"\n):\n\"\"\"\n    Compute a set of streamlines given velocity function `dF`.\n\n    Args:\n        dF (callable) : A dF type funcion. Computes the derivatives of given coordinates.\n        X (list, list[list]) : Arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n        Y (list, list[list]) : Arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n        maxLen (int, default=500) : The maximum length of an individual streamline segment.\n        polar (bool, default=false) : Whether to use polar coordinates or not.\n        density (int, default=1) : Density of mask grid. Used for making the stream lines not collide.\n        odeint_method (str, default=\"scipy\") : Selects integration method, by default uses scipy.odeint. `euler` and `rungekutta3` are also available.\n        dF_args (dict|None, default=None) : dF_args of `dF` function.\n    \"\"\"\n    super().__init__(odeint_method=odeint_method)\n\n    self.dimension = 2\n    self.dF = dF\n    self.dF_args = dF_args if dF_args is not None else  {}\n\n    self.maxLen = maxLen\n    self.deltat = deltat\n\n    self.density = int(abs(density))\n\n    xa = np.asanyarray(X)\n    ya = np.asanyarray(Y)\n    if np.isnan(xa).any() or np.isnan(ya).any():\n        raise Exception(\"Invalid range. Chech limits and scales.\")\n    self.x = xa if xa.ndim == 1 else xa[0]\n    self.y = ya if ya.ndim == 1 else ya[:, 0]\n\n    self.polar = polar\n    self._speed = self._speed_2d_no_polar if not polar else self._speed_2d_polar\n\n    # marker for which regions have contours. +1 outside the plot at the far side of every axis. \n    self.used = np.zeros((1 + X.shape[0]*self.density, 1 + X.shape[1]*self.density), dtype=bool)\n    self.used[0] = True\n    self.used[-1] = True\n    self.used[:, 0] = True\n    self.used[:, -1] = True\n\n    self.range_min = np.array((self.x[0], self.y[0]))\n    self.range_max = np.array((self.x[-1], self.y[-1]))\n\n    self.streamlines = []\n\n    while not self.used.all():\n        nz = np.transpose(np.logical_not(self.used).nonzero())\n        # Make a streamline starting at the first unrepresented grid point\n        # choose = np.random.randint(nz.shape[0])\n        choose = 0\n\n        x_ind = nz[choose][0]\n        x = self.x[x_ind-1] + 0.5 * (self.x[x_ind]-self.x[x_ind-1])\n        y_ind = nz[choose][1]\n        y = self.y[y_ind-1] + 0.5 * (self.y[y_ind]-self.y[y_ind-1])\n\n\n        # x = nz[choose][0]*self.dx + self.x[0]\n        # y = nz[choose][1]*self.dy + self.y[0]\n        self.streamlines.append(\n            self._makeStreamline(np.array([x, y]))\n        )\n</code></pre>"},{"location":"reference/phaseportrait/streamlines/streamlines_base/#phaseportrait.streamlines.streamlines_base.Streamlines_base2D.get_delta_coordinates","title":"<code>get_delta_coordinates(x, y)</code>","text":"<p>Returns closest delta coordinates of grid</p> Source code in <code>phaseportrait/streamlines/streamlines_base.py</code> <pre><code>def get_delta_coordinates(self, x, y):\n\"\"\"\n    Returns closest delta coordinates of grid\n    \"\"\"\n    x_mask, y_mask = self.get_masked_coordinates(x, y)\n    return np.array([\n        self.x[x_mask] - self.x[x_mask-1], \n        self.y[y_mask] - self.y[y_mask-1]])\n</code></pre>"},{"location":"reference/phaseportrait/streamlines/streamlines_base/#phaseportrait.streamlines.streamlines_base.Streamlines_base2D.get_masked_coordinates","title":"<code>get_masked_coordinates(x, y)</code>","text":"<p>Returns index of position in masked coordinates</p> Source code in <code>phaseportrait/streamlines/streamlines_base.py</code> <pre><code>def get_masked_coordinates(self, x, y):\n\"\"\"\n    Returns index of position in masked coordinates\n    \"\"\"\n    x_ind = np.searchsorted(self.x, x)\n    y_ind = np.searchsorted(self.y, y)\n    return np.array([x_ind, y_ind])\n</code></pre>"},{"location":"reference/phaseportrait/streamlines/streamlines_base/#phaseportrait.streamlines.streamlines_base.Streamlines_base3D","title":"<code>Streamlines_base3D</code>","text":"<p>         Bases: <code>Streamlines_base</code></p>"},{"location":"reference/phaseportrait/streamlines/streamlines_base/#phaseportrait.streamlines.streamlines_base.Streamlines_base3D--streamlines","title":"Streamlines","text":"<p>Creates trajectories given a <code>dF</code> function. Using Euler integrator.</p> Integrated in <p>-PhasePortrait3D</p> Source code in <code>phaseportrait/streamlines/streamlines_base.py</code> <pre><code>class Streamlines_base3D(Streamlines_base):\n\"\"\"\n    Streamlines\n    --------\n    Creates trajectories given a `dF` function. Using Euler integrator.\n\n    Integrated in:\n        -PhasePortrait3D\n    \"\"\"\n\n\n    def __init__(\n        self, dF, X, Y, Z, maxLen=2500, *, dF_args=None, polar=False, density=1, odeint_method=\"scipy\"\n    ):\n\"\"\"\n        Compute a set of streamlines given velocity function `dF`.\n\n        Args:\n            X (list, list[list]): arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n            Y (list, list[list]): arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n            Z (list, list[list]): arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n            maxLen (int default=500) : The maximum length of an individual streamline segment.\n            polar (bool default=false) : Whether to use polar coordinates or not.\n            density (int, default=1) : Density of mask grid. Used for making the stream lines not collide.\n            odeint_method (str, default=\"scipy\") : Selects integration method, by default uses scipy.odeint. `euler` and `rungekutta3` are also available.\n            dF_args (dict|None default=None) : dF_args of `dF` function.\n        \"\"\"\n        super().__init__(odeint_method=odeint_method)\n        self.dF = dF\n        self.dF_args = dF_args if dF_args is not None else  {}\n\n        self.maxLen = maxLen\n\n        self.dimension = 3\n\n        self.density = int(abs(density))\n\n        xa = np.asanyarray(X)\n        ya = np.asanyarray(Y)\n        za = np.asanyarray(Z)\n        self.x = xa if xa.ndim == 1 else xa[0,:,0]\n        self.y = ya if ya.ndim == 1 else ya[:,0,0]\n        self.z = za if za.ndim == 1 else za[0,0,:]\n\n        self.polar = polar\n        self._speed = self._speed_3d_no_polar if not polar else self._speed_3d_polar\n\n        # marker for which regions have contours. +1 outside the plot at the far side of every axis. \n        self.used = np.zeros((1 + X.shape[0]*self.density, 1 + X.shape[1]*self.density, 1 + X.shape[2]*self.density), dtype=bool)\n        self.used[0] = True\n        self.used[-1] = True\n        self.used[:, 0] = True\n        self.used[:, -1] = True\n        self.used[:,:, 0] = True\n        self.used[:,:, -1] = True\n\n\n        self.range_min = np.array((self.x[0], self.y[0], self.z[0]))\n        self.range_max = np.array((self.x[-1], self.y[-1], self.z[-1]))\n\n        # Make the streamlines\n        self.streamlines = []\n\n        while not self.used.all():\n            nz = np.transpose(np.logical_not(self.used).nonzero())\n            # Make a streamline starting at the first unrepresented grid point\n            # choose = np.random.randint(nz.shape[0])\n            choose = 0\n\n            x_ind = nz[choose][0]\n            x = self.x[x_ind-1] + 0.5 * (self.x[x_ind]-self.x[x_ind-1])\n            y_ind = nz[choose][1]\n            y = self.y[y_ind-1] + 0.5 * (self.y[y_ind]-self.y[y_ind-1])\n            z_ind = nz[choose][2]\n            z = self.z[z_ind-1] + 0.5 * (self.z[z_ind]-self.z[z_ind-1])\n            self.streamlines.append(\n                self._makeStreamline(np.array([x, y, z]))\n            )\n\n\n    def get_masked_coordinates(self, x, y, z):\n\"\"\"\n        Returns index of position in masked coordinates\n        \"\"\"\n        x_ind = np.searchsorted(self.x, x)\n        y_ind = np.searchsorted(self.y, y)\n        z_ind = np.searchsorted(self.z, z)\n        return np.array([x_ind, y_ind, z_ind])\n\n    def get_delta_coordinates(self, x, y, z):\n\"\"\"\n        Returns closest delta coordinates of grid\n        \"\"\"\n        x_mask, y_mask, z_mask = self.get_masked_coordinates(x, y, z)\n        return np.array([\n            self.x[x_mask] - self.x[x_mask-1], \n            self.y[y_mask] - self.y[y_mask-1], \n            self.z[z_mask] - self.z[z_mask-1]])\n\n    @property\n    def Range(self):\n        return ((self.x[0], self.x[-1]), (self.y[0], self.y[-1]), (self.z[0], self.z[-1])) \n</code></pre>"},{"location":"reference/phaseportrait/streamlines/streamlines_base/#phaseportrait.streamlines.streamlines_base.Streamlines_base3D.__init__","title":"<code>__init__(dF, X, Y, Z, maxLen=2500, *, dF_args=None, polar=False, density=1, odeint_method='scipy')</code>","text":"<p>Compute a set of streamlines given velocity function <code>dF</code>.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>list, list[list]</code> <p>arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.</p> required <code>Y</code> <code>list, list[list]</code> <p>arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.</p> required <code>Z</code> <code>list, list[list]</code> <p>arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.</p> required <code>maxLen</code> <code>int default=500) </code> <p>The maximum length of an individual streamline segment.</p> <code>2500</code> <code>polar</code> <code>bool default=false) </code> <p>Whether to use polar coordinates or not.</p> <code>False</code> <code>density</code> <code>int, default=1) </code> <p>Density of mask grid. Used for making the stream lines not collide.</p> <code>1</code> <code>odeint_method</code> <code>str, default=\"scipy\") </code> <p>Selects integration method, by default uses scipy.odeint. <code>euler</code> and <code>rungekutta3</code> are also available.</p> <code>'scipy'</code> <code>dF_args</code> <code>dict|None default=None) </code> <p>dF_args of <code>dF</code> function.</p> <code>None</code> Source code in <code>phaseportrait/streamlines/streamlines_base.py</code> <pre><code>def __init__(\n    self, dF, X, Y, Z, maxLen=2500, *, dF_args=None, polar=False, density=1, odeint_method=\"scipy\"\n):\n\"\"\"\n    Compute a set of streamlines given velocity function `dF`.\n\n    Args:\n        X (list, list[list]): arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n        Y (list, list[list]): arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n        Z (list, list[list]): arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n        maxLen (int default=500) : The maximum length of an individual streamline segment.\n        polar (bool default=false) : Whether to use polar coordinates or not.\n        density (int, default=1) : Density of mask grid. Used for making the stream lines not collide.\n        odeint_method (str, default=\"scipy\") : Selects integration method, by default uses scipy.odeint. `euler` and `rungekutta3` are also available.\n        dF_args (dict|None default=None) : dF_args of `dF` function.\n    \"\"\"\n    super().__init__(odeint_method=odeint_method)\n    self.dF = dF\n    self.dF_args = dF_args if dF_args is not None else  {}\n\n    self.maxLen = maxLen\n\n    self.dimension = 3\n\n    self.density = int(abs(density))\n\n    xa = np.asanyarray(X)\n    ya = np.asanyarray(Y)\n    za = np.asanyarray(Z)\n    self.x = xa if xa.ndim == 1 else xa[0,:,0]\n    self.y = ya if ya.ndim == 1 else ya[:,0,0]\n    self.z = za if za.ndim == 1 else za[0,0,:]\n\n    self.polar = polar\n    self._speed = self._speed_3d_no_polar if not polar else self._speed_3d_polar\n\n    # marker for which regions have contours. +1 outside the plot at the far side of every axis. \n    self.used = np.zeros((1 + X.shape[0]*self.density, 1 + X.shape[1]*self.density, 1 + X.shape[2]*self.density), dtype=bool)\n    self.used[0] = True\n    self.used[-1] = True\n    self.used[:, 0] = True\n    self.used[:, -1] = True\n    self.used[:,:, 0] = True\n    self.used[:,:, -1] = True\n\n\n    self.range_min = np.array((self.x[0], self.y[0], self.z[0]))\n    self.range_max = np.array((self.x[-1], self.y[-1], self.z[-1]))\n\n    # Make the streamlines\n    self.streamlines = []\n\n    while not self.used.all():\n        nz = np.transpose(np.logical_not(self.used).nonzero())\n        # Make a streamline starting at the first unrepresented grid point\n        # choose = np.random.randint(nz.shape[0])\n        choose = 0\n\n        x_ind = nz[choose][0]\n        x = self.x[x_ind-1] + 0.5 * (self.x[x_ind]-self.x[x_ind-1])\n        y_ind = nz[choose][1]\n        y = self.y[y_ind-1] + 0.5 * (self.y[y_ind]-self.y[y_ind-1])\n        z_ind = nz[choose][2]\n        z = self.z[z_ind-1] + 0.5 * (self.z[z_ind]-self.z[z_ind-1])\n        self.streamlines.append(\n            self._makeStreamline(np.array([x, y, z]))\n        )\n</code></pre>"},{"location":"reference/phaseportrait/streamlines/streamlines_base/#phaseportrait.streamlines.streamlines_base.Streamlines_base3D.get_delta_coordinates","title":"<code>get_delta_coordinates(x, y, z)</code>","text":"<p>Returns closest delta coordinates of grid</p> Source code in <code>phaseportrait/streamlines/streamlines_base.py</code> <pre><code>def get_delta_coordinates(self, x, y, z):\n\"\"\"\n    Returns closest delta coordinates of grid\n    \"\"\"\n    x_mask, y_mask, z_mask = self.get_masked_coordinates(x, y, z)\n    return np.array([\n        self.x[x_mask] - self.x[x_mask-1], \n        self.y[y_mask] - self.y[y_mask-1], \n        self.z[z_mask] - self.z[z_mask-1]])\n</code></pre>"},{"location":"reference/phaseportrait/streamlines/streamlines_base/#phaseportrait.streamlines.streamlines_base.Streamlines_base3D.get_masked_coordinates","title":"<code>get_masked_coordinates(x, y, z)</code>","text":"<p>Returns index of position in masked coordinates</p> Source code in <code>phaseportrait/streamlines/streamlines_base.py</code> <pre><code>def get_masked_coordinates(self, x, y, z):\n\"\"\"\n    Returns index of position in masked coordinates\n    \"\"\"\n    x_ind = np.searchsorted(self.x, x)\n    y_ind = np.searchsorted(self.y, y)\n    z_ind = np.searchsorted(self.z, z)\n    return np.array([x_ind, y_ind, z_ind])\n</code></pre>"},{"location":"reference/phaseportrait/streamlines/velocity_color_gradient/","title":"Velocity color gradient","text":""},{"location":"reference/phaseportrait/streamlines/velocity_color_gradient/#phaseportrait.streamlines.velocity_color_gradient.Arrow3D","title":"<code>Arrow3D</code>","text":"<p>         Bases: <code>FancyArrowPatch</code></p> <p>3D FancyArrowPatch proyection</p> Source code in <code>phaseportrait/streamlines/velocity_color_gradient.py</code> <pre><code>class Arrow3D(FancyArrowPatch):\n\"\"\"\n    3D FancyArrowPatch proyection\n    \"\"\"\n    def __init__(self, posA, posB, *args, **kwargs):\n        super().__init__((0,0), (0,0), *args, **kwargs)\n        self._verts3d = [[posA[i], posB[i]] for i in range(len(posA))]\n\n    def do_3d_projection(self, renderer=None):\n        xs3d, ys3d, zs3d = self._verts3d\n        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M)\n        self.set_positions((xs[0],ys[0]),(xs[1],ys[1]))\n        return np.min(zs)\n</code></pre>"},{"location":"reference/phaseportrait/streamlines/velocity_color_gradient/#phaseportrait.streamlines.velocity_color_gradient.Streamlines_Velocity_Color_Gradient","title":"<code>Streamlines_Velocity_Color_Gradient</code>","text":""},{"location":"reference/phaseportrait/streamlines/velocity_color_gradient/#phaseportrait.streamlines.velocity_color_gradient.Streamlines_Velocity_Color_Gradient--streamlines","title":"Streamlines","text":"<p>Creates trajectories given a <code>dF</code> function. Using Euler integrator.</p> <p>Integrated in: - PhasePortrait2D</p> Source code in <code>phaseportrait/streamlines/velocity_color_gradient.py</code> <pre><code>class Streamlines_Velocity_Color_Gradient:\n\"\"\"\n    Streamlines\n    --------\n    Creates trajectories given a `dF` function. Using Euler integrator.\n\n    Integrated in:\n    - PhasePortrait2D\n    \"\"\"\n\n\n\n    def __init__(\n        self, dF, X, Y, *Z, maxLen=500, dF_args=None, **kargs\n    ):\n\"\"\"\n        Compute a set of streamlines given velocity function `dF`.\n\n        Args:\n            X (list, list[list]): arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n            Y (list, list[list]): arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n            maxLen (int default=500): The maximum length of an individual streamline segment.\n            dF_args (dict|None default=None) : dF_args of `dF` function.\n        \"\"\"\n        if not Z:\n            self.proyection=\"2d\"\n            self.stream_base = Streamlines_base2D(dF, X, Y, maxLen, dF_args=dF_args, **kargs)\n        else:\n            self.proyection=\"3d\"\n            self.stream_base = Streamlines_base3D(dF, X, Y, Z[0], maxLen, dF_args=dF_args, **kargs)\n\n\n    def _velocity_normalization(self):\n\"\"\" Returns a colour normalization function for colouring the stream lines. \"\"\"\n        vmax = None\n        vmin = None\n\n        for streamline in self.stream_base.streamlines:\n            *_, v = streamline\n            vmax = max(v + ([vmax] if vmax is not None else []))\n            vmin = min(v + ([vmin] if vmin is not None else []))\n\n        return Normalize(vmin, vmax)\n\n    def plot(self, ax, cmap, cnorm, *, linewidth=None, arrowsize=1, arrowstyle='-|&gt;'):\n        # n_segments = 0\n        # for streamline in self.stream_base.streamlines:\n        #     x, *_ = streamline\n        #     n_segments += len(x)\n\n\n\n        if self.proyection == \"2d\":\n            LineClass = LineCollection\n            ArrowClass = FancyArrowPatch\n        if self.proyection == \"3d\":\n            LineClass = Line3DCollection\n            ArrowClass = Arrow3D\n\n        if linewidth is None:\n            linewidth = matplotlib.rcParams['lines.linewidth']\n\n        line_kw = {}\n        arrow_kw = dict(arrowstyle=arrowstyle, mutation_scale=10 * arrowsize)\n\n        for streamline in self.stream_base.streamlines:\n            *coords, v = streamline\n            points = np.array(coords).T.reshape(-1 , 1, 2 if self.proyection==\"2d\" else 3)\n            segments = np.concatenate([points[:-1], points[1:]], axis=1)\n\n            s = np.sqrt(np.sum(np.square(points), 2))\n            s = np.cumsum(s)\n            n = np.searchsorted(s, s[-1] / 2.)\n\n            arrows = []\n\n            arrows_C = cmap(cnorm(v[n]))\n\n            arrow_tail = points[n][0]\n            arrow_head = np.mean(points[n:n + 2], 0)[0]\n\n            arrows.append(ArrowClass(arrow_tail, arrow_head, color=arrows_C, **arrow_kw))\n\n            C = cmap(cnorm(v))\n\n            line = LineClass(segments, color=C, **line_kw)\n            ax.add_collection(line)\n\n            for a in arrows:\n                ax.add_patch(a)\n</code></pre>"},{"location":"reference/phaseportrait/streamlines/velocity_color_gradient/#phaseportrait.streamlines.velocity_color_gradient.Streamlines_Velocity_Color_Gradient.__init__","title":"<code>__init__(dF, X, Y, *Z, maxLen=500, dF_args=None, **kargs)</code>","text":"<p>Compute a set of streamlines given velocity function <code>dF</code>.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>list, list[list]</code> <p>arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.</p> required <code>Y</code> <code>list, list[list]</code> <p>arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.</p> required <code>maxLen</code> <code>int default=500</code> <p>The maximum length of an individual streamline segment.</p> <code>500</code> <code>dF_args</code> <code>dict|None default=None) </code> <p>dF_args of <code>dF</code> function.</p> <code>None</code> Source code in <code>phaseportrait/streamlines/velocity_color_gradient.py</code> <pre><code>def __init__(\n    self, dF, X, Y, *Z, maxLen=500, dF_args=None, **kargs\n):\n\"\"\"\n    Compute a set of streamlines given velocity function `dF`.\n\n    Args:\n        X (list, list[list]): arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n        Y (list, list[list]): arrays of the grid points. The mesh spacing is assumed to be uniform in each dimension.\n        maxLen (int default=500): The maximum length of an individual streamline segment.\n        dF_args (dict|None default=None) : dF_args of `dF` function.\n    \"\"\"\n    if not Z:\n        self.proyection=\"2d\"\n        self.stream_base = Streamlines_base2D(dF, X, Y, maxLen, dF_args=dF_args, **kargs)\n    else:\n        self.proyection=\"3d\"\n        self.stream_base = Streamlines_base3D(dF, X, Y, Z[0], maxLen, dF_args=dF_args, **kargs)\n</code></pre>"},{"location":"reference/phaseportrait/trajectories/rungekutta/","title":"Rungekutta","text":""},{"location":"reference/phaseportrait/trajectories/rungekutta/#phaseportrait.trajectories.rungekutta.RungeKutta","title":"<code>RungeKutta</code>","text":"<p>         Bases: <code>_Generator_</code></p> <p>This class is an implementation of Generator for a Runge-Kutta 4th order data generator.</p> Source code in <code>phaseportrait/trajectories/rungekutta.py</code> <pre><code>class RungeKutta(_Generator_):\n\"\"\"\n    This class is an implementation of _Generator_ for a Runge-Kutta 4th order data generator.\n    \"\"\"\n    def __init__(self, portrait, dF, dimension, max_values, *, dt=0.1, dF_args=None, initial_values=None, thermalization=0):\n\"\"\"\n        Args:\n            portrait (Object) : Class that uses the RungeKutta objects.\n            dF (callable) : A dF type funcion.\n            dimension (int) : Number of dimensions in which it calculates the next values. Must equal the amount of outputs the `dF`\n                funcion gives.\n            max_values (int) : Max number of values saved.\n            dt (float, optional, by default 0.1) : Time interval used in the Runge-Kutta 4th order method.\n            dF_args (dict) : If necesary, must contain the kargs for the `dF` funcion. By default, None. \n            initial_values (float, list, optional) : Initial set of conditions, by default None.\n                If None, random initial conditions are aplied in the interval [0,1) for each coordinate.\n            thermalization (int, optional) : Thermalization steps before data is saved, by default None. \n                If None, thermalization steps are set to 0.\n        \"\"\"\n        super().__init__(portrait, dF, dimension, max_values, dF_args=dF_args,\n                         initial_values=initial_values, thermalization=thermalization)\n\n        self.dt = dt\n        self.positions = self._create_values_array()\n        self.velocities = self._create_values_array()\n\n    @classmethod\n    def instance_and_compute_all(cls, portrait, dF, dimension, dF_args, initial_values, max_values, save_freq=1, dt=0.1, thermalization=0):\n\"\"\"Creates an instance of phase-portrait.trajectories.RungeKutta. \n        Computes all the data requested and returns the instance.\n\n        Args:\n            portrait (Object):  Class that uses the RungeKutta objects.\n            dF (callable) : A dF type funcion.\n            dimension (int) : Number of dimensions in which it calculates the next values. Must equal the amount of outputs the `dF`\n                funcion gives.\n            dF_args (dict) : If necesary, must contain the kargs for the `dF` funcion. By default, None.\n            initial_values (float, list, optional) : Initial set of conditions, by default None.\n                If None, random initial conditions are aplied in the interval [0,1) for each coordinat\n            max_values (int) : Max number of values saved.\n            save_freq (int, optional, by default 1) : Number of values computed before saving them.\n            dt (float, optional, by default 0.1) : Time interval used in the Runge-Kutta 4th order method.\n            thermalization (int, optional) : Thermalization steps before data is saved, by default None. \n                If None, thermalization steps are set to 0.\n        \"\"\"\n        instance = cls(portrait, dF, dimension, dt=dt, dF_args=dF_args, initial_values=initial_values, thermalization=thermalization)\n\n        instance.compute_all()\n        return instance\n\n\n    def _next(self):\n\"\"\"\n        Generates from `self.position` its following value via the Runge-Kutta 4th order method.\n        \"\"\"\n        k1 = np.array(self.dF(*(self.position), **self.dF_args))\n        k2 = np.array(self.dF(*(self.position+0.5*k1*self.dt), **self.dF_args))\n        k3 = np.array(self.dF(*(self.position+0.5*k2*self.dt), **self.dF_args))\n        k4 = np.array(self.dF(*(self.position+k3*self.dt), **self.dF_args))\n        self.velocity = 1/6*(k1+2*k2+2*k3+k4)\n        if (self.velocity == 0).all():\n            self.flag_stop = True\n        self.position += self.velocity*self.dt\n\n\n    def save(self, i):\n\"\"\"\n        Saves `self.position` in the attribute `self.positions`, and `self.velocity` in `self.velocities`.\n\n        Args:\n            i (int) : Index in which the data is saved.\n        \"\"\"\n        try:\n            self.positions[:, i] = self.position\n            self.velocities[:, i] = self.velocity\n        except IndexError:\n            np.concatenate(self.positions, self._create_values_array(), axis=1)\n            np.concatenate(self.velocities, self._create_values_array(), axis=1)\n            self.max_values += 2000\n            self.save(i)\n\n\n    def clear_values(self):\n\"\"\"\n        Clears the data arrays `self.positions` and `self.velocities`.\n        \"\"\"\n        self.positions[:,1:] = 0\n        self.velocity[:,1:] = 0\n</code></pre>"},{"location":"reference/phaseportrait/trajectories/rungekutta/#phaseportrait.trajectories.rungekutta.RungeKutta.__init__","title":"<code>__init__(portrait, dF, dimension, max_values, *, dt=0.1, dF_args=None, initial_values=None, thermalization=0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>portrait</code> <code>Object) </code> <p>Class that uses the RungeKutta objects.</p> required <code>dF</code> <code>callable) </code> <p>A dF type funcion.</p> required <code>dimension</code> <code>int) </code> <p>Number of dimensions in which it calculates the next values. Must equal the amount of outputs the <code>dF</code> funcion gives.</p> required <code>max_values</code> <code>int) </code> <p>Max number of values saved.</p> required <code>dt</code> <code>float, optional, by default 0.1) </code> <p>Time interval used in the Runge-Kutta 4th order method.</p> <code>0.1</code> <code>dF_args</code> <code>dict) </code> <p>If necesary, must contain the kargs for the <code>dF</code> funcion. By default, None. </p> <code>None</code> <code>initial_values</code> <code>float, list, optional) </code> <p>Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinate.</p> <code>None</code> <code>thermalization</code> <code>int, optional) </code> <p>Thermalization steps before data is saved, by default None.  If None, thermalization steps are set to 0.</p> <code>0</code> Source code in <code>phaseportrait/trajectories/rungekutta.py</code> <pre><code>def __init__(self, portrait, dF, dimension, max_values, *, dt=0.1, dF_args=None, initial_values=None, thermalization=0):\n\"\"\"\n    Args:\n        portrait (Object) : Class that uses the RungeKutta objects.\n        dF (callable) : A dF type funcion.\n        dimension (int) : Number of dimensions in which it calculates the next values. Must equal the amount of outputs the `dF`\n            funcion gives.\n        max_values (int) : Max number of values saved.\n        dt (float, optional, by default 0.1) : Time interval used in the Runge-Kutta 4th order method.\n        dF_args (dict) : If necesary, must contain the kargs for the `dF` funcion. By default, None. \n        initial_values (float, list, optional) : Initial set of conditions, by default None.\n            If None, random initial conditions are aplied in the interval [0,1) for each coordinate.\n        thermalization (int, optional) : Thermalization steps before data is saved, by default None. \n            If None, thermalization steps are set to 0.\n    \"\"\"\n    super().__init__(portrait, dF, dimension, max_values, dF_args=dF_args,\n                     initial_values=initial_values, thermalization=thermalization)\n\n    self.dt = dt\n    self.positions = self._create_values_array()\n    self.velocities = self._create_values_array()\n</code></pre>"},{"location":"reference/phaseportrait/trajectories/rungekutta/#phaseportrait.trajectories.rungekutta.RungeKutta.clear_values","title":"<code>clear_values()</code>","text":"<p>Clears the data arrays <code>self.positions</code> and <code>self.velocities</code>.</p> Source code in <code>phaseportrait/trajectories/rungekutta.py</code> <pre><code>def clear_values(self):\n\"\"\"\n    Clears the data arrays `self.positions` and `self.velocities`.\n    \"\"\"\n    self.positions[:,1:] = 0\n    self.velocity[:,1:] = 0\n</code></pre>"},{"location":"reference/phaseportrait/trajectories/rungekutta/#phaseportrait.trajectories.rungekutta.RungeKutta.instance_and_compute_all","title":"<code>instance_and_compute_all(portrait, dF, dimension, dF_args, initial_values, max_values, save_freq=1, dt=0.1, thermalization=0)</code>  <code>classmethod</code>","text":"<p>Creates an instance of phase-portrait.trajectories.RungeKutta.  Computes all the data requested and returns the instance.</p> <p>Parameters:</p> Name Type Description Default <code>portrait</code> <code>Object</code> <p>Class that uses the RungeKutta objects.</p> required <code>dF</code> <code>callable) </code> <p>A dF type funcion.</p> required <code>dimension</code> <code>int) </code> <p>Number of dimensions in which it calculates the next values. Must equal the amount of outputs the <code>dF</code> funcion gives.</p> required <code>dF_args</code> <code>dict) </code> <p>If necesary, must contain the kargs for the <code>dF</code> funcion. By default, None.</p> required <code>initial_values</code> <code>float, list, optional) </code> <p>Initial set of conditions, by default None. If None, random initial conditions are aplied in the interval [0,1) for each coordinat</p> required <code>max_values</code> <code>int) </code> <p>Max number of values saved.</p> required <code>save_freq</code> <code>int, optional, by default 1) </code> <p>Number of values computed before saving them.</p> <code>1</code> <code>dt</code> <code>float, optional, by default 0.1) </code> <p>Time interval used in the Runge-Kutta 4th order method.</p> <code>0.1</code> <code>thermalization</code> <code>int, optional) </code> <p>Thermalization steps before data is saved, by default None.  If None, thermalization steps are set to 0.</p> <code>0</code> Source code in <code>phaseportrait/trajectories/rungekutta.py</code> <pre><code>@classmethod\ndef instance_and_compute_all(cls, portrait, dF, dimension, dF_args, initial_values, max_values, save_freq=1, dt=0.1, thermalization=0):\n\"\"\"Creates an instance of phase-portrait.trajectories.RungeKutta. \n    Computes all the data requested and returns the instance.\n\n    Args:\n        portrait (Object):  Class that uses the RungeKutta objects.\n        dF (callable) : A dF type funcion.\n        dimension (int) : Number of dimensions in which it calculates the next values. Must equal the amount of outputs the `dF`\n            funcion gives.\n        dF_args (dict) : If necesary, must contain the kargs for the `dF` funcion. By default, None.\n        initial_values (float, list, optional) : Initial set of conditions, by default None.\n            If None, random initial conditions are aplied in the interval [0,1) for each coordinat\n        max_values (int) : Max number of values saved.\n        save_freq (int, optional, by default 1) : Number of values computed before saving them.\n        dt (float, optional, by default 0.1) : Time interval used in the Runge-Kutta 4th order method.\n        thermalization (int, optional) : Thermalization steps before data is saved, by default None. \n            If None, thermalization steps are set to 0.\n    \"\"\"\n    instance = cls(portrait, dF, dimension, dt=dt, dF_args=dF_args, initial_values=initial_values, thermalization=thermalization)\n\n    instance.compute_all()\n    return instance\n</code></pre>"},{"location":"reference/phaseportrait/trajectories/rungekutta/#phaseportrait.trajectories.rungekutta.RungeKutta.save","title":"<code>save(i)</code>","text":"<p>Saves <code>self.position</code> in the attribute <code>self.positions</code>, and <code>self.velocity</code> in <code>self.velocities</code>.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int) </code> <p>Index in which the data is saved.</p> required Source code in <code>phaseportrait/trajectories/rungekutta.py</code> <pre><code>def save(self, i):\n\"\"\"\n    Saves `self.position` in the attribute `self.positions`, and `self.velocity` in `self.velocities`.\n\n    Args:\n        i (int) : Index in which the data is saved.\n    \"\"\"\n    try:\n        self.positions[:, i] = self.position\n        self.velocities[:, i] = self.velocity\n    except IndexError:\n        np.concatenate(self.positions, self._create_values_array(), axis=1)\n        np.concatenate(self.velocities, self._create_values_array(), axis=1)\n        self.max_values += 2000\n        self.save(i)\n</code></pre>"},{"location":"reference/phaseportrait/trajectories/trajectory/","title":"Trajectory","text":""},{"location":"reference/phaseportrait/trajectories/trajectory/#phaseportrait.trajectories.trajectory.trajectory","title":"<code>trajectory</code>","text":""},{"location":"reference/phaseportrait/trajectories/trajectory/#phaseportrait.trajectories.trajectory.trajectory--trajectory","title":"trajectory","text":"<p>Base class of trajectory classes:  - Trajectory2D - Trajectory3D</p>"},{"location":"reference/phaseportrait/trajectories/trajectory/#phaseportrait.trajectories.trajectory.trajectory--methods","title":"Methods","text":"<ul> <li>_prepare_plot: Prepares the plots.</li> <li>_scatter_start_point: Scatter all the start points.</li> <li>_scatter_trajectory: Scatter all the trajectories.</li> <li>_plot_lines: Plots the lines of all the trajectories.</li> <li>_create_sliders_plot: Creates the sliders plot.</li> <li>thermalize: Adds thermalization steps and random initial position.</li> <li>initial_position: Adds a trajectory with the given initial position.</li> <li>plot: Prepares the plots and computes the values. Returns the axis and the figure.</li> <li>add_slider: Adds a <code>Slider</code> for the <code>dF</code> function.</li> <li>_calculate_values: Computes the trajectories.</li> </ul> Source code in <code>phaseportrait/trajectories/trajectory.py</code> <pre><code>class trajectory:\n\"\"\"\n    trajectory\n    ----------\n    Base class of trajectory classes: \n    - Trajectory2D\n    - Trajectory3D\n\n    Methods\n    -------    \n    * _prepare_plot: Prepares the plots.\n    * _scatter_start_point: Scatter all the start points.\n    * _scatter_trajectory: Scatter all the trajectories.\n    * _plot_lines: Plots the lines of all the trajectories.\n    * _create_sliders_plot: Creates the sliders plot.\n    * thermalize: Adds thermalization steps and random initial position.\n    * initial_position: Adds a trajectory with the given initial position.\n    * plot: Prepares the plots and computes the values. Returns the axis and the figure.\n    * add_slider: Adds a `Slider` for the `dF` function.\n    * _calculate_values: Computes the trajectories.\n    \"\"\"\n\n    _name_ = 'trajectory'\n\n    def __init__(self, dF, dimension, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs):\n\"\"\"\n        Creates an instance of trajectory\n\n        Args:\n            dF (callable) : A dF type function.\n            dimension : The number of dimensions in which the trajectory is calculated. Must equal `dF` return lengh.\n            Range (Union[float,list], default=None) : Range of every coordinate in the graphs.\n            dF_args (dict) : If necesary, must contain the kargs for the `dF` function.\n            n_points (int, default=10000    ) : Number of positions to be saved for every trajectory.\n            runge_kutta_step (float, default=0.1) : Step of 'time' in the Runge-Kutta method.\n            runge_kutta_freq (int) : Number of times `dF` is aplied between positions saved.\n            lines (bool, defaullt=True) : Must be `True` if method _plot_lines is used.\n            Titulo (str) : Title of the plot.\n            color (str) : Matplotlib `Cmap`.\n            size (float) : Size of the scattered points.\n            thermalization (int) : Thermalization steps before points saved.\n            mark_start_point (bool) : Marks the start position if True.\n        \"\"\"\n\n        self._dimension = dimension\n        self.dF_args = dF_args.copy()\n        self.dF = dF \n        self.Range = Range\n\n        try: \n            if kargs['numba']:\n                from numba import jit\n                self.dF = jit(self.dF, nopython=True)\n                if not self.dF_args:\n                    exceptions.dFArgsRequired()\n        except KeyError:\n            pass\n\n        # Genral Runge-Kutta variables\n        self.runge_kutta_step = runge_kutta_step\n        self.runge_kutta_freq = runge_kutta_freq\n        self.n_points = n_points\n        self.trajectories = []\n\n        # Plotting variables\n        self.Title = kargs['Title'] if kargs.get('Title') else 'Trajectory'\n\n        self.sliders = {}\n        self.sliders_fig = False\n\n        self.lines = kargs.get('lines', True)\n\n        self.thermalization = kargs.get('thermalization')\n        if not self.thermalization:\n            self.thermalization = 0\n        self.size = kargs.get('size')\n        if not self.size:\n            self.size = 0.5\n        self.color = kargs.get('color')\n        if self.color is None:\n            self.color =  'viridis'\n        self._mark_start_point = kargs.get('mark_start_point')\n\n    # This functions must be overwriten on child classes:\n    def _prepare_plot(self):...\n    def _scatter_start_point(self, val_init):...\n    def _scatter_trajectory(self, val, color, cmap):...\n    def _plot_lines(self, val, val_init):...\n\n\n    # General functions\n    def _create_sliders_plot(self):\n        if not isinstance(self.sliders_fig, plt.Figure):\n            self.sliders_fig, self.sliders_ax = plt.subplots() \n            self.sliders_ax.set_visible(False)\n\n\n    def thermalize(self, *, thermalization_steps=200):\n\"\"\"\n        Shortcut to:\n\n        ```py\n        self.thermalization = thermalization_steps\n        self.initial_position()\n        ```\n        \"\"\"\n\n        if self.thermalization is None:\n            self.thermalization = thermalization_steps\n        self.initial_position()\n\n\n    def initial_position(self, *args, **kargs):\n\"\"\"\n        Adds a initial position for the computation.\n        More than one can be added.\n\n        Args:\n            args (Union[float, list[2], list[3]], optional) : Initial position for the computation. If None, a random position is chosen.\n\n        Example:\n        -------\n        This example generates 2 circles with diferent radius. \n        ```\n        def Circle(x,y,*, w=1, z=1):\n            return w*y, -z*x\n\n        circle = Trayectoria2D(Circle, n_points=1300, size=2, mark_start_position=True, Titulo='Just a circle')\n        circle.initial_position(1,1)\n        circle.initial_position(2,2)\n        ```\n        \"\"\"\n        if not args:\n            args = np.random.rand(self._dimension)\n\n        if len(args) &lt; self._dimension:\n            raise InvalidInitialPositions(args, self._dimension)\n\n        flag = False\n        for trajectory in self.trajectories:\n            for a, b in zip(args, trajectory.initial_value):\n                if a!=b:\n                    flag = True\n\n        if not flag and len(self.trajectories)&gt;0:\n            return\n\n        self.trajectories.append(\n            RungeKutta(\n                self, self.dF, self._dimension, self.n_points, \n                dt=self.runge_kutta_step,\n                dF_args=self.dF_args, \n                initial_values=args,\n                thermalization=self.thermalization\n                )\n            )\n\n\n    def initial_positions(self, *positions, **kargs):\n\"\"\"\n        Adds initial positions for the computation.\n        Calls `trajectory.initial_position` for each position given.\n\n        Args:\n            postitions (list,list[list]): Initial positions for the computation.\n        \"\"\"\n        positions_standar = np.array(positions).reshape(-1, self._dimension)\n        for position in positions_standar:\n            if len(position) &lt; self._dimension:\n                raise InvalidInitialPositions(position, self._dimension)\n            self.initial_position(*position, **kargs)\n\n\n    def _calculate_values(self, *args, all_initial_conditions=False, **kargs):\n        if all_initial_conditions:\n            for trajectory in self.trajectories:\n                trajectory.position = trajectory.initial_value.copy()\n\n        for trajectory in self.trajectories:\n            trajectory.compute_all(save_freq=self.runge_kutta_freq)\n\n\n    def plot(self, color=None, labels=False, grid=False, **kargs):\n\"\"\"\n        Prepares the plots and computes the values.\n\n        Args:\n            color (str) : Matplotlib `Cmap`.\n            labels (str) : Label the initial positions\n\n        Returns: \n            (tuple(matplotlib Figure, matplotlib Axis)): \n        \"\"\"\n\n        self._prepare_plot(grid=grid)\n        self.dF_args.update({name: slider.value for name, slider in self.sliders.items() if slider.value!= None})\n        for trajectory in self.trajectories:\n            trajectory.dF_args = self.dF_args\n\n        self._calculate_values(all_initial_conditions=True)\n\n\n        # if self.color == 't':\n        #     cmap = color\n        # else:\n        #     cmap = self.color = color\n        if color is not None:\n            self.color = color\n        cmap = self.color\n\n        for trajectory in self.trajectories:\n            val = trajectory.positions\n            vel = trajectory.velocities\n            val_init = trajectory.initial_value\n\n            if self.lines:\n                self._plot_lines(val, vel, val_init)\n\n            else:\n                def norma(v):\n                    suma = 0\n                    for i in range(self._dimension):\n                        suma += np.nan_to_num(v[i]**2)\n                    return np.sqrt(suma)\n                if self.color == 't':\n                    color = np.linspace(0,1, vel.shape[1])\n                else:\n                    color = norma(vel[:])\n                    color /= color.max()\n\n                self._scatter_trajectory(val, color, cmap)\n\n            if self._mark_start_point:\n                self._scatter_start_point(val_init)\n\n        for fig in self.fig.values():\n            if self.lines and labels:\n                fig.legend()\n            fig.canvas.draw_idle()\n        try:\n            self.sliders_fig.canvas.draw_idle()\n        except:\n            pass\n\n        try:\n            return self.fig, self.ax\n        except AttributeError:\n            return None\n\n\n    def add_slider(self, param_name, *, valinit=None, valstep=0.1, valinterval=10):\n\"\"\"\n        Adds a `Slider` for the `dF` function.\n\n        Args:\n            param_name (str) : Name of the variable. Must be in the `dF` kargs of the `Map1D.dF` function.\n            valinit (float, defautl=None): Initial position of the Slider\n            valinterval (Union[float,list], default=10): Min and max value for the param range.\n            valstep (float, default=0.1): Separation between consecutive values in the param range.\n        \"\"\" \n        self._create_sliders_plot()\n        self.sliders.update({param_name: sliders.Slider(self, param_name, valinit=valinit, valstep=valstep, valinterval=valinterval)})\n\n        self.sliders[param_name].slider.on_changed(self.sliders[param_name])\n\n\n    @property\n    def dF(self):\n        return self._dF\n\n    @dF.setter\n    def dF(self, func):\n        if not callable(func):\n            raise exceptions.dFNotCallable(func)\n        try:\n            sig = signature(func)\n        except ValueError:\n            pass\n        else:\n            if len(sig.parameters)&lt;self._dimension + len(self.dF_args):\n                raise exceptions.dFInvalid(sig, self.dF_args)\n        self._dF = func\n\n\n    @property\n    def Range(self):\n        return self._Range\n\n    @Range.setter\n    def Range(self, value):\n        if value == None:\n            self._Range = None\n            return\n        self._Range = np.array(utils.construct_interval(value, dim=3))\n\n    @property\n    def dF_args(self):\n        return self._dF_args\n\n    @dF_args.setter\n    def dF_args(self, value):\n        if value:\n            if not isinstance(value, dict):\n                raise exceptions.dF_argsInvalid(value)\n        self._dF_args = value\n</code></pre>"},{"location":"reference/phaseportrait/trajectories/trajectory/#phaseportrait.trajectories.trajectory.trajectory.__init__","title":"<code>__init__(dF, dimension, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs)</code>","text":"<p>Creates an instance of trajectory</p> <p>Parameters:</p> Name Type Description Default <code>dF</code> <code>callable) </code> <p>A dF type function.</p> required <code>dimension</code> <p>The number of dimensions in which the trajectory is calculated. Must equal <code>dF</code> return lengh.</p> required <code>Range</code> <code>Union[float,list], default=None) </code> <p>Range of every coordinate in the graphs.</p> <code>None</code> <code>dF_args</code> <code>dict) </code> <p>If necesary, must contain the kargs for the <code>dF</code> function.</p> <code>{}</code> <code>n_points</code> <code>int, default=10000    ) </code> <p>Number of positions to be saved for every trajectory.</p> <code>10000</code> <code>runge_kutta_step</code> <code>float, default=0.1) </code> <p>Step of 'time' in the Runge-Kutta method.</p> <code>0.01</code> <code>runge_kutta_freq</code> <code>int) </code> <p>Number of times <code>dF</code> is aplied between positions saved.</p> <code>1</code> <code>lines</code> <code>bool, defaullt=True) </code> <p>Must be <code>True</code> if method _plot_lines is used.</p> required <code>Titulo</code> <code>str) </code> <p>Title of the plot.</p> required <code>color</code> <code>str) </code> <p>Matplotlib <code>Cmap</code>.</p> required <code>size</code> <code>float) </code> <p>Size of the scattered points.</p> required <code>thermalization</code> <code>int) </code> <p>Thermalization steps before points saved.</p> required <code>mark_start_point</code> <code>bool) </code> <p>Marks the start position if True.</p> required Source code in <code>phaseportrait/trajectories/trajectory.py</code> <pre><code>def __init__(self, dF, dimension, *, Range=None, dF_args={}, n_points=10000, runge_kutta_step=0.01, runge_kutta_freq=1, **kargs):\n\"\"\"\n    Creates an instance of trajectory\n\n    Args:\n        dF (callable) : A dF type function.\n        dimension : The number of dimensions in which the trajectory is calculated. Must equal `dF` return lengh.\n        Range (Union[float,list], default=None) : Range of every coordinate in the graphs.\n        dF_args (dict) : If necesary, must contain the kargs for the `dF` function.\n        n_points (int, default=10000    ) : Number of positions to be saved for every trajectory.\n        runge_kutta_step (float, default=0.1) : Step of 'time' in the Runge-Kutta method.\n        runge_kutta_freq (int) : Number of times `dF` is aplied between positions saved.\n        lines (bool, defaullt=True) : Must be `True` if method _plot_lines is used.\n        Titulo (str) : Title of the plot.\n        color (str) : Matplotlib `Cmap`.\n        size (float) : Size of the scattered points.\n        thermalization (int) : Thermalization steps before points saved.\n        mark_start_point (bool) : Marks the start position if True.\n    \"\"\"\n\n    self._dimension = dimension\n    self.dF_args = dF_args.copy()\n    self.dF = dF \n    self.Range = Range\n\n    try: \n        if kargs['numba']:\n            from numba import jit\n            self.dF = jit(self.dF, nopython=True)\n            if not self.dF_args:\n                exceptions.dFArgsRequired()\n    except KeyError:\n        pass\n\n    # Genral Runge-Kutta variables\n    self.runge_kutta_step = runge_kutta_step\n    self.runge_kutta_freq = runge_kutta_freq\n    self.n_points = n_points\n    self.trajectories = []\n\n    # Plotting variables\n    self.Title = kargs['Title'] if kargs.get('Title') else 'Trajectory'\n\n    self.sliders = {}\n    self.sliders_fig = False\n\n    self.lines = kargs.get('lines', True)\n\n    self.thermalization = kargs.get('thermalization')\n    if not self.thermalization:\n        self.thermalization = 0\n    self.size = kargs.get('size')\n    if not self.size:\n        self.size = 0.5\n    self.color = kargs.get('color')\n    if self.color is None:\n        self.color =  'viridis'\n    self._mark_start_point = kargs.get('mark_start_point')\n</code></pre>"},{"location":"reference/phaseportrait/trajectories/trajectory/#phaseportrait.trajectories.trajectory.trajectory.add_slider","title":"<code>add_slider(param_name, *, valinit=None, valstep=0.1, valinterval=10)</code>","text":"<p>Adds a <code>Slider</code> for the <code>dF</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>param_name</code> <code>str) </code> <p>Name of the variable. Must be in the <code>dF</code> kargs of the <code>Map1D.dF</code> function.</p> required <code>valinit</code> <code>float, defautl=None</code> <p>Initial position of the Slider</p> <code>None</code> <code>valinterval</code> <code>Union[float,list], default=10</code> <p>Min and max value for the param range.</p> <code>10</code> <code>valstep</code> <code>float, default=0.1</code> <p>Separation between consecutive values in the param range.</p> <code>0.1</code> Source code in <code>phaseportrait/trajectories/trajectory.py</code> <pre><code>def add_slider(self, param_name, *, valinit=None, valstep=0.1, valinterval=10):\n\"\"\"\n    Adds a `Slider` for the `dF` function.\n\n    Args:\n        param_name (str) : Name of the variable. Must be in the `dF` kargs of the `Map1D.dF` function.\n        valinit (float, defautl=None): Initial position of the Slider\n        valinterval (Union[float,list], default=10): Min and max value for the param range.\n        valstep (float, default=0.1): Separation between consecutive values in the param range.\n    \"\"\" \n    self._create_sliders_plot()\n    self.sliders.update({param_name: sliders.Slider(self, param_name, valinit=valinit, valstep=valstep, valinterval=valinterval)})\n\n    self.sliders[param_name].slider.on_changed(self.sliders[param_name])\n</code></pre>"},{"location":"reference/phaseportrait/trajectories/trajectory/#phaseportrait.trajectories.trajectory.trajectory.initial_position","title":"<code>initial_position(*args, **kargs)</code>","text":"<p>Adds a initial position for the computation. More than one can be added.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Union[float, list[2], list[3]], optional) </code> <p>Initial position for the computation. If None, a random position is chosen.</p> <code>()</code>"},{"location":"reference/phaseportrait/trajectories/trajectory/#phaseportrait.trajectories.trajectory.trajectory.initial_position--example","title":"Example:","text":"<p>This example generates 2 circles with diferent radius. </p> <pre><code>def Circle(x,y,*, w=1, z=1):\n    return w*y, -z*x\n\ncircle = Trayectoria2D(Circle, n_points=1300, size=2, mark_start_position=True, Titulo='Just a circle')\ncircle.initial_position(1,1)\ncircle.initial_position(2,2)\n</code></pre> Source code in <code>phaseportrait/trajectories/trajectory.py</code> <pre><code>def initial_position(self, *args, **kargs):\n\"\"\"\n    Adds a initial position for the computation.\n    More than one can be added.\n\n    Args:\n        args (Union[float, list[2], list[3]], optional) : Initial position for the computation. If None, a random position is chosen.\n\n    Example:\n    -------\n    This example generates 2 circles with diferent radius. \n    ```\n    def Circle(x,y,*, w=1, z=1):\n        return w*y, -z*x\n\n    circle = Trayectoria2D(Circle, n_points=1300, size=2, mark_start_position=True, Titulo='Just a circle')\n    circle.initial_position(1,1)\n    circle.initial_position(2,2)\n    ```\n    \"\"\"\n    if not args:\n        args = np.random.rand(self._dimension)\n\n    if len(args) &lt; self._dimension:\n        raise InvalidInitialPositions(args, self._dimension)\n\n    flag = False\n    for trajectory in self.trajectories:\n        for a, b in zip(args, trajectory.initial_value):\n            if a!=b:\n                flag = True\n\n    if not flag and len(self.trajectories)&gt;0:\n        return\n\n    self.trajectories.append(\n        RungeKutta(\n            self, self.dF, self._dimension, self.n_points, \n            dt=self.runge_kutta_step,\n            dF_args=self.dF_args, \n            initial_values=args,\n            thermalization=self.thermalization\n            )\n        )\n</code></pre>"},{"location":"reference/phaseportrait/trajectories/trajectory/#phaseportrait.trajectories.trajectory.trajectory.initial_positions","title":"<code>initial_positions(*positions, **kargs)</code>","text":"<p>Adds initial positions for the computation. Calls <code>trajectory.initial_position</code> for each position given.</p> <p>Parameters:</p> Name Type Description Default <code>postitions</code> <code>list, list[list]</code> <p>Initial positions for the computation.</p> required Source code in <code>phaseportrait/trajectories/trajectory.py</code> <pre><code>def initial_positions(self, *positions, **kargs):\n\"\"\"\n    Adds initial positions for the computation.\n    Calls `trajectory.initial_position` for each position given.\n\n    Args:\n        postitions (list,list[list]): Initial positions for the computation.\n    \"\"\"\n    positions_standar = np.array(positions).reshape(-1, self._dimension)\n    for position in positions_standar:\n        if len(position) &lt; self._dimension:\n            raise InvalidInitialPositions(position, self._dimension)\n        self.initial_position(*position, **kargs)\n</code></pre>"},{"location":"reference/phaseportrait/trajectories/trajectory/#phaseportrait.trajectories.trajectory.trajectory.plot","title":"<code>plot(color=None, labels=False, grid=False, **kargs)</code>","text":"<p>Prepares the plots and computes the values.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str) </code> <p>Matplotlib <code>Cmap</code>.</p> <code>None</code> <code>labels</code> <code>str) </code> <p>Label the initial positions</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple(matplotlib Figure, matplotlib Axis)</code> Source code in <code>phaseportrait/trajectories/trajectory.py</code> <pre><code>def plot(self, color=None, labels=False, grid=False, **kargs):\n\"\"\"\n    Prepares the plots and computes the values.\n\n    Args:\n        color (str) : Matplotlib `Cmap`.\n        labels (str) : Label the initial positions\n\n    Returns: \n        (tuple(matplotlib Figure, matplotlib Axis)): \n    \"\"\"\n\n    self._prepare_plot(grid=grid)\n    self.dF_args.update({name: slider.value for name, slider in self.sliders.items() if slider.value!= None})\n    for trajectory in self.trajectories:\n        trajectory.dF_args = self.dF_args\n\n    self._calculate_values(all_initial_conditions=True)\n\n\n    # if self.color == 't':\n    #     cmap = color\n    # else:\n    #     cmap = self.color = color\n    if color is not None:\n        self.color = color\n    cmap = self.color\n\n    for trajectory in self.trajectories:\n        val = trajectory.positions\n        vel = trajectory.velocities\n        val_init = trajectory.initial_value\n\n        if self.lines:\n            self._plot_lines(val, vel, val_init)\n\n        else:\n            def norma(v):\n                suma = 0\n                for i in range(self._dimension):\n                    suma += np.nan_to_num(v[i]**2)\n                return np.sqrt(suma)\n            if self.color == 't':\n                color = np.linspace(0,1, vel.shape[1])\n            else:\n                color = norma(vel[:])\n                color /= color.max()\n\n            self._scatter_trajectory(val, color, cmap)\n\n        if self._mark_start_point:\n            self._scatter_start_point(val_init)\n\n    for fig in self.fig.values():\n        if self.lines and labels:\n            fig.legend()\n        fig.canvas.draw_idle()\n    try:\n        self.sliders_fig.canvas.draw_idle()\n    except:\n        pass\n\n    try:\n        return self.fig, self.ax\n    except AttributeError:\n        return None\n</code></pre>"},{"location":"reference/phaseportrait/trajectories/trajectory/#phaseportrait.trajectories.trajectory.trajectory.thermalize","title":"<code>thermalize(*, thermalization_steps=200)</code>","text":"<p>Shortcut to:</p> <pre><code>self.thermalization = thermalization_steps\nself.initial_position()\n</code></pre> Source code in <code>phaseportrait/trajectories/trajectory.py</code> <pre><code>def thermalize(self, *, thermalization_steps=200):\n\"\"\"\n    Shortcut to:\n\n    ```py\n    self.thermalization = thermalization_steps\n    self.initial_position()\n    ```\n    \"\"\"\n\n    if self.thermalization is None:\n        self.thermalization = thermalization_steps\n    self.initial_position()\n</code></pre>"},{"location":"reference/phaseportrait/utils/manager/","title":"Manager","text":""},{"location":"reference/phaseportrait/utils/manager/#phaseportrait.utils.manager.Manager","title":"<code>Manager</code>","text":"Source code in <code>phaseportrait/utils/manager.py</code> <pre><code>class Manager:\n    def __init__(self, portrait):\n        self.portrait = portrait\n\n    def plot_update(self, configuration):\n\"\"\"Updates the plot with the new configuration configuration\n\n        Args:\n            configuration (dict): For more information check api examples\n\n        Returns:\n            (int): 0 if successfull. 1 otherwise.\n        \"\"\"\n        dimension = configuration.get('dimension')\n\n        # Parameters\n        kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xScale',  'yScale', 'xlabel', 'ylabel', 'color'] + \\\n            (['zScale', 'zlabel'] if dimension==3 else [])\n\n        for k,v in configuration.items():\n            if k in kargs:\n                setattr(self.portrait, k, v)\n\n        range = configuration.get('Range')\n        try:\n            if range:\n                if dimension == 2:\n                    self.portrait.Range = [[range['x_min'],range['x_max']],\n                                        [range['y_min'],range['y_max']]]\n                if dimension == 3:\n                    self.portrait.Range = [[range['x_min'],range['x_max']],\n                                        [range['y_min'],range['y_max']],\n                                        [range['z_min'], range['z_max']]]\n        except TypeError:\n            return 1\n\n        # Nullclines not implemented in 3d plot\n        if (nc:=configuration.get('nullcline')) and dimension != 3:\n            self.portrait.add_nullclines(**nc)\n        else:\n            self.portrait.nullclines = []\n\n        if sls:=configuration.get('sliders'):\n            for sl_name in sls:\n                # If a slider is already created with same name ends are updated and value is changed\n                if slider:=self.portrait.sliders.get(sl_name):\n                        slider.update_slider_ends(sls[sl_name][\"min\"], sls[sl_name][\"max\"])\n                        slider.value = configuration[\"dF_args\"][sl_name]\n                        slider.slider.set_val(configuration[\"dF_args\"][sl_name])\n\n                else:\n                    self.portrait.add_slider(sl_name, \n                        valinit=configuration[\"dF_args\"][sl_name],\n                        valinterval=[sls[sl_name][\"min\"], sls[sl_name][\"max\"]],\n                        valstep= (sls[sl_name][\"max\"]-sls[sl_name][\"min\"])/50\n                        )\n\n\n        if new_dF := configuration.get('dF'):\n            self.portrait.dF_args = {}\n            try:\n                match = re.search(r\"def\\s+(\\w+)\\(\", new_dF)\n                function_name = match.group(1)\n                # match = re.search(r\"(\\s+)def\", new_dF)\n                # if match is not None:\n                #     new_dF = new_dF.replace(match.group(0), \"\\ndef\")\n                # del match\n\n                exec(new_dF, globals())\n                self.portrait.dF = globals()[function_name]\n            except  Exception as e:\n                return 1\n\n        # Clean axis and replot\n        try:\n            self.portrait.ax.cla()\n        except Exception as e:\n            for ax in self.portrait.ax.values():\n                ax.cla()\n\n        if 'Cobweb' in self.portrait._name_:\n            self.portrait.update_dF_args()\n\n\n        colorbar_check = configuration.get(\"Colorbar\", False)\n        self.portrait.colorbar(toggle=colorbar_check)\n\n        self.portrait.plot()\n\n        self.portrait.fig.tight_layout()\n        # self.portrait.fig.subplots_adjust(left=0.2, bottom=0.2, right=1, top=0.9, wspace=0.01, hspace=0.01)\n        return 0\n\n\n    def equivalent_code(self, configuration):\n\"\"\"Returns equivalent code of given configuration\n\n        Args:\n            configuration (dict): For more information check api examples\n\n        Returns:\n            (str): equivalent code to the given configuration\n        \"\"\"\n\n        match = re.search(r\"def\\s+(\\w+)\\(\", configuration['dF'])\n        function_name = match.group(1)\n        dimension = configuration['dimension']\n\n        header = f\"\"\"from phaseportrait import *\\nimport matplotlib.pyplot as plt\"\"\"\n\n        function = f\"\"\"\\n{configuration['dF']}\"\"\"\n\n        portrait = f\"\"\"\\nphase_diagram = PhasePortrait{dimension}D({function_name}, [[{configuration['Range']['x_min']},{configuration['Range']['x_max']}],[{configuration['Range']['y_min']},{configuration['Range']['y_max']}]]\"\"\"\n        if dimension == 3:\n            portrait = portrait[:-1] + f\"\"\",[{configuration['Range']['z_min']},{configuration['Range']['z_max']}]]\"\"\"\n\n        portrait_kargs = \"\"\n        # kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xlabel', 'ylabel', 'color']\n        kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xScale',  'yScale', 'xlabel', 'ylabel', 'color'] + \\\n            (['zScale', 'zlabel'] if dimension==3 else [])\n        first = True\n        for k in configuration.keys():\n            if k in kargs:\n                if configuration[k]:\n                    if first:\n                        portrait += \",\"\n                        first = False\n                    if isinstance(configuration[k], str):\n                        portrait_kargs += f\"\\t{k} = '{configuration[k]}',\\n\"\n                    else:\n                        portrait_kargs += f\"\\t{k} = {configuration[k]},\\n\"\n\n        if first:\n            portrait += ')\\n'\n        else:\n            portrait_kargs += ')\\n'\n\n\n        nullcline = ''\n        if (nc := configuration.get('nullcline')) and dimension != 3:\n            nullcline = f\"\\nphase_diagram.add_nullclines(precision={nc['precision']}, offset={nc['offset']})\"\n\n        finisher = '\\nphase_diagram.plot()\\nplt.show()'\n\n        return header +\"\\n\\t\\n\"+ function +\"\\n\\t\\n\"+ portrait +\"\\n\"+ portrait_kargs +\"\\n\\t\\n\"+ nullcline +\"\\n\\t\\n\"+ finisher\n\n\n    def handle_json(self, message):\n        if message[\"phaseportrait_request\"] == '--plot':\n            return self.plot_update(message)\n\n        if message[\"phaseportrait_request\"] == '--code':\n            return self.equivalent_code(message)\n</code></pre>"},{"location":"reference/phaseportrait/utils/manager/#phaseportrait.utils.manager.Manager.equivalent_code","title":"<code>equivalent_code(configuration)</code>","text":"<p>Returns equivalent code of given configuration</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>dict</code> <p>For more information check api examples</p> required <p>Returns:</p> Type Description <code>str</code> <p>equivalent code to the given configuration</p> Source code in <code>phaseportrait/utils/manager.py</code> <pre><code>def equivalent_code(self, configuration):\n\"\"\"Returns equivalent code of given configuration\n\n    Args:\n        configuration (dict): For more information check api examples\n\n    Returns:\n        (str): equivalent code to the given configuration\n    \"\"\"\n\n    match = re.search(r\"def\\s+(\\w+)\\(\", configuration['dF'])\n    function_name = match.group(1)\n    dimension = configuration['dimension']\n\n    header = f\"\"\"from phaseportrait import *\\nimport matplotlib.pyplot as plt\"\"\"\n\n    function = f\"\"\"\\n{configuration['dF']}\"\"\"\n\n    portrait = f\"\"\"\\nphase_diagram = PhasePortrait{dimension}D({function_name}, [[{configuration['Range']['x_min']},{configuration['Range']['x_max']}],[{configuration['Range']['y_min']},{configuration['Range']['y_max']}]]\"\"\"\n    if dimension == 3:\n        portrait = portrait[:-1] + f\"\"\",[{configuration['Range']['z_min']},{configuration['Range']['z_max']}]]\"\"\"\n\n    portrait_kargs = \"\"\n    # kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xlabel', 'ylabel', 'color']\n    kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xScale',  'yScale', 'xlabel', 'ylabel', 'color'] + \\\n        (['zScale', 'zlabel'] if dimension==3 else [])\n    first = True\n    for k in configuration.keys():\n        if k in kargs:\n            if configuration[k]:\n                if first:\n                    portrait += \",\"\n                    first = False\n                if isinstance(configuration[k], str):\n                    portrait_kargs += f\"\\t{k} = '{configuration[k]}',\\n\"\n                else:\n                    portrait_kargs += f\"\\t{k} = {configuration[k]},\\n\"\n\n    if first:\n        portrait += ')\\n'\n    else:\n        portrait_kargs += ')\\n'\n\n\n    nullcline = ''\n    if (nc := configuration.get('nullcline')) and dimension != 3:\n        nullcline = f\"\\nphase_diagram.add_nullclines(precision={nc['precision']}, offset={nc['offset']})\"\n\n    finisher = '\\nphase_diagram.plot()\\nplt.show()'\n\n    return header +\"\\n\\t\\n\"+ function +\"\\n\\t\\n\"+ portrait +\"\\n\"+ portrait_kargs +\"\\n\\t\\n\"+ nullcline +\"\\n\\t\\n\"+ finisher\n</code></pre>"},{"location":"reference/phaseportrait/utils/manager/#phaseportrait.utils.manager.Manager.plot_update","title":"<code>plot_update(configuration)</code>","text":"<p>Updates the plot with the new configuration configuration</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>dict</code> <p>For more information check api examples</p> required <p>Returns:</p> Type Description <code>int</code> <p>0 if successfull. 1 otherwise.</p> Source code in <code>phaseportrait/utils/manager.py</code> <pre><code>def plot_update(self, configuration):\n\"\"\"Updates the plot with the new configuration configuration\n\n    Args:\n        configuration (dict): For more information check api examples\n\n    Returns:\n        (int): 0 if successfull. 1 otherwise.\n    \"\"\"\n    dimension = configuration.get('dimension')\n\n    # Parameters\n    kargs = ['MeshDim', 'dF_args', 'Density', 'Polar', 'Title', 'xScale',  'yScale', 'xlabel', 'ylabel', 'color'] + \\\n        (['zScale', 'zlabel'] if dimension==3 else [])\n\n    for k,v in configuration.items():\n        if k in kargs:\n            setattr(self.portrait, k, v)\n\n    range = configuration.get('Range')\n    try:\n        if range:\n            if dimension == 2:\n                self.portrait.Range = [[range['x_min'],range['x_max']],\n                                    [range['y_min'],range['y_max']]]\n            if dimension == 3:\n                self.portrait.Range = [[range['x_min'],range['x_max']],\n                                    [range['y_min'],range['y_max']],\n                                    [range['z_min'], range['z_max']]]\n    except TypeError:\n        return 1\n\n    # Nullclines not implemented in 3d plot\n    if (nc:=configuration.get('nullcline')) and dimension != 3:\n        self.portrait.add_nullclines(**nc)\n    else:\n        self.portrait.nullclines = []\n\n    if sls:=configuration.get('sliders'):\n        for sl_name in sls:\n            # If a slider is already created with same name ends are updated and value is changed\n            if slider:=self.portrait.sliders.get(sl_name):\n                    slider.update_slider_ends(sls[sl_name][\"min\"], sls[sl_name][\"max\"])\n                    slider.value = configuration[\"dF_args\"][sl_name]\n                    slider.slider.set_val(configuration[\"dF_args\"][sl_name])\n\n            else:\n                self.portrait.add_slider(sl_name, \n                    valinit=configuration[\"dF_args\"][sl_name],\n                    valinterval=[sls[sl_name][\"min\"], sls[sl_name][\"max\"]],\n                    valstep= (sls[sl_name][\"max\"]-sls[sl_name][\"min\"])/50\n                    )\n\n\n    if new_dF := configuration.get('dF'):\n        self.portrait.dF_args = {}\n        try:\n            match = re.search(r\"def\\s+(\\w+)\\(\", new_dF)\n            function_name = match.group(1)\n            # match = re.search(r\"(\\s+)def\", new_dF)\n            # if match is not None:\n            #     new_dF = new_dF.replace(match.group(0), \"\\ndef\")\n            # del match\n\n            exec(new_dF, globals())\n            self.portrait.dF = globals()[function_name]\n        except  Exception as e:\n            return 1\n\n    # Clean axis and replot\n    try:\n        self.portrait.ax.cla()\n    except Exception as e:\n        for ax in self.portrait.ax.values():\n            ax.cla()\n\n    if 'Cobweb' in self.portrait._name_:\n        self.portrait.update_dF_args()\n\n\n    colorbar_check = configuration.get(\"Colorbar\", False)\n    self.portrait.colorbar(toggle=colorbar_check)\n\n    self.portrait.plot()\n\n    self.portrait.fig.tight_layout()\n    # self.portrait.fig.subplots_adjust(left=0.2, bottom=0.2, right=1, top=0.9, wspace=0.01, hspace=0.01)\n    return 0\n</code></pre>"},{"location":"reference/phaseportrait/utils/utils/","title":"Utils","text":""},{"location":"reference/phaseportrait/utils/utils/#phaseportrait.utils.utils.construct_interval","title":"<code>construct_interval(var, *, dim=None, depth=0)</code>","text":"<p>Construct intervals from <code>var</code> for <code>dim</code> dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>Object</code> <p>Element from which a 1d interval is created</p> required <code>dim</code> <code>int</code> <p>Dimension of the requested interval, by default None</p> <code>None</code> <code>depth</code> <code>int</code> <p>Used for <code>dim==3</code> by default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>list</code> <p><code>dim</code> dimensional interval.</p> Source code in <code>phaseportrait/utils/utils.py</code> <pre><code>def construct_interval(var, *, dim=None, depth=0):\n\"\"\"Construct intervals from `var` for `dim` dimensions.\n\n    Args:\n        var (Object):  Element from which a 1d interval is created\n        dim (int, optional): Dimension of the requested interval, by default None\n        depth (int, optional): Used for `dim==3` by default 0\n\n    Returns:\n        (list): `dim` dimensional interval.\n    \"\"\"\n    if not dim:\n        dim = len(var) \n\n    if dim==1:\n        inter = construct_interval_1d(var)\n    elif dim==2:\n        inter = construct_interval_2d(var)\n    elif dim==3:\n        inter = construct_interval_3d(var, depth=depth)\n    while len(inter)&lt;dim:\n        inter.append(inter[-1])\n    return inter\n</code></pre>"},{"location":"reference/phaseportrait/utils/utils/#phaseportrait.utils.utils.construct_interval_1d","title":"<code>construct_interval_1d(var)</code>","text":"<p>Creates an 1d interval from a variable</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>float, list</code> <p>Element from which a 1d interval is created It supports: * number * [number, number]</p> required <p>Returns:</p> Type Description <code>list</code> <p>1d interval []</p> <p>Raises:</p> Type Description <code>exceptions.RangoInvalid</code> <p>If the parameter given is not a number nor a list or tuple.</p> Source code in <code>phaseportrait/utils/utils.py</code> <pre><code>def construct_interval_1d(var):\n\"\"\"Creates an 1d interval from a variable\n\n    Args:\n        var (float, list):\n            Element from which a 1d interval is created\n            It supports:\n            * number\n            * [number, number]\n\n    Returns:\n        (list): 1d interval []\n\n\n    Raises:\n        (exceptions.RangoInvalid): If the parameter given is not a number nor a list or tuple.\n    \"\"\"\n    try:\n        if is_number(var):\n            if var !=0:\n                return sorted([-var, var])\n            raise Exception('0 is not a valid range.')\n        if is_range(var):\n             return var\n    except Exception as e:\n        raise exceptions.InvalidRange(f\"{var} as 1D range gave the following error: \"+str(e))\n</code></pre>"},{"location":"reference/phaseportrait/utils/utils/#phaseportrait.utils.utils.construct_interval_2d","title":"<code>construct_interval_2d(var)</code>","text":"<p>Creates an 2d interval from a variable</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>float, list</code> <p>Element from which a 1d interval is created It supports: * number * [number, number] * [[number, number], number] * [[number, number],[number, number]]</p> <p>And all the permutations.</p> required <p>Returns:</p> Type Description <code>list[list]</code> <p>2d interval [[],[]]</p> <p>Raises:</p> Type Description <code>phaseportrait.exceptions.exceptions.RangoInvalid</code> <p>If the parameter given is not a number nor a list or tuple.</p> Source code in <code>phaseportrait/utils/utils.py</code> <pre><code>def construct_interval_2d(var):\n\"\"\"Creates an 2d interval from a variable\n\n    Args:\n        var (float, list):\n            Element from which a 1d interval is created\n            It supports:\n            * number\n            * [number, number]\n            * [[number, number], number]\n            * [[number, number],[number, number]]\n\n            And all the permutations.\n\n    Returns:\n        (list[list]): 2d interval [[],[]]\n\n    Raises:\n        (phaseportrait.exceptions.exceptions.RangoInvalid): If the parameter given is not a number nor a list or tuple.\n    \"\"\"\n    try:\n        [a,b],[c,d] = var\n    except Exception:\n        try:\n            b,d = var\n            if is_range(b) or is_range(d):\n                [a,b],[c,d] = construct_interval_1d(b), construct_interval_1d(d)\n            else:\n                a = c = b\n                b = d\n        except Exception:\n            try:\n                a = var\n                if a !=0:\n                    b = d = a\n                    a = c = 0\n                else:\n                    raise Exception\n            except Exception as e:    \n                raise exceptions.InvalidRange(f\"{var} is not a valid 2D range.\")\n    a1 = [a,b]\n    a2 = [c,d]\n    a1.sort()\n    a2.sort()\n    return [a1, a2]\n</code></pre>"},{"location":"reference/phaseportrait/utils/utils/#phaseportrait.utils.utils.construct_interval_3d","title":"<code>construct_interval_3d(var, *, depth=0)</code>","text":"<p>Creates an 3d interval from a variable</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>float, list</code> <p>Element from which a 1d interval is created It supports: * number * [number, number, number] * [[number, number], number, number] * [[number, number], [number, number], number] * [[number, number],[number, number], [number, number]]</p> <p>And all the permutations.</p> required <p>Returns:</p> Type Description <code>list</code> <p>3d interval: [[],[],[]]</p> <p>Raises:</p> Type Description <code>exceptions.RangoInvalid</code> <p>If the parameter given is not a number nor a list or tuple.</p> Source code in <code>phaseportrait/utils/utils.py</code> <pre><code>def construct_interval_3d(var, *, depth=0):\n\"\"\"Creates an 3d interval from a variable\n\n    Args:\n        var (float, list):\n            Element from which a 1d interval is created\n            It supports:\n            * number\n            * [number, number, number]\n            * [[number, number], number, number]\n            * [[number, number], [number, number], number]\n            * [[number, number],[number, number], [number, number]]\n\n            And all the permutations.\n\n    Returns:\n        (list): 3d interval: [[],[],[]]\n\n    Raises:\n        (exceptions.RangoInvalid): If the parameter given is not a number nor a list or tuple.\n    \"\"\"\n    try:\n        if is_number(var):\n            if depth == 0:\n                return [sorted([0, var])]*3\n            elif depth == 1:\n                return sorted([-var, var])\n        elif is_range(var):\n            if depth==0:\n                return [construct_interval_3d(i, depth=depth+1) for i in var]\n            if depth==1:\n                return var\n    except Exception as e:\n        raise exceptions.InvalidRange(f\"{var} as 3D range gave the following error: \"+str(e))\n</code></pre>"},{"location":"reference/phaseportrait/utils/utils/#phaseportrait.utils.utils.is_number","title":"<code>is_number(x)</code>","text":"<p>Checks if <code>x</code> is a number</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Object) </code> <p>The object.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether is a number or not.</p> Source code in <code>phaseportrait/utils/utils.py</code> <pre><code>def is_number(x):\n\"\"\"Checks if `x` is a number\n\n    Args:\n        x (Object) :  The object.\n\n    Returns:\n        (bool): Whether is a number or not.\n    \"\"\"\n    return isinstance(x, (float,int))\n</code></pre>"},{"location":"reference/phaseportrait/utils/utils/#phaseportrait.utils.utils.is_range","title":"<code>is_range(U)</code>","text":"<p>Checks if <code>x</code> is a list or a tuple</p> <p>Parameters:</p> Name Type Description Default <code>U</code> <code>Object</code> <p>The object.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether is a collection of elements or not.</p> Source code in <code>phaseportrait/utils/utils.py</code> <pre><code>def is_range(U):\n\"\"\"Checks if `x` is a list or a tuple\n\n    Args:\n        U (Object): The object.\n\n    Returns:\n        (bool): Whether is a collection of elements or not.\n    \"\"\"\n    return isinstance(U, (list,tuple))\n</code></pre>"}]}